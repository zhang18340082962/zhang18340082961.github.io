{"title":"python办公自动化：文件和目录操作","uid":"3d3f9536d1b98ac2adb8f0a4ceb774df","slug":"python办公自动化：文件和目录操作","date":"2021-03-06T15:07:45.000Z","updated":"2022-04-03T06:09:17.212Z","comments":true,"path":"api/articles/python办公自动化：文件和目录操作.json","keywords":null,"cover":null,"content":"<pre class=\"line-numbers language-none\"><code class=\"language-none\">import os</code></pre>\n<h3 id=\"创建目录结构\"><a href=\"#创建目录结构\" class=\"headerlink\" title=\"创建目录结构\"></a>创建目录结构</h3><ul>\n<li>os.makedirs 可以递归的创建目录结构，比如<pre class=\"line-numbers language-none\"><code class=\"language-none\">os.makedirs(&#39;tmp&#x2F;python&#x2F;fileop&#39;,exist_ok&#x3D;True)</code></pre>\n在当前工作目录下面创建 tmp目录，在tmp目录下面再创建 python目录，在Python目录下面再创建fileop目录；exist_ok=True 指定了，如果某个要创建的目录已经存在，也不报错</li>\n</ul>\n<h3 id=\"删除文件或目录\"><a href=\"#删除文件或目录\" class=\"headerlink\" title=\"删除文件或目录\"></a>删除文件或目录</h3><p>os.remove 可以删除一个文件，比如</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">os.remove(&#39;sdf.py&#39;)</code></pre>\n<p>shutil.rmtree() 可以递归的删除某个目录所有的子目录和子文件 比如</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">import shutil\nshutil.rmtree(&#39;tmp&#39;, ignore_errors&#x3D;True)</code></pre>\n<p>注意：参数 ignore_errors=True 保证如果目录不为空，不会抛出异常。</p>\n<h3 id=\"拷贝文件\"><a href=\"#拷贝文件\" class=\"headerlink\" title=\"拷贝文件\"></a>拷贝文件</h3><p>shutil 模块里面有很多 目录文件操作的函数<br>拷贝文件，可以使用shutil模块的copyfile函数。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">from shutil import copyfile\n# 拷贝 d:&#x2F;tools&#x2F;first.py 到 e:&#x2F;first.py\ncopyfile(&#39;d:&#x2F;tools&#x2F;first.py&#39;, &#39;e:&#x2F;first.py&#39;)</code></pre>\n<p>注意，如果拷贝前，e:/first.py 已经存在，则会被拷贝覆盖，所以使用该函数一定要小心。<br>###拷贝目录<br>如果我们要拷贝一个目录里面所有的内容（包括子目录和文件、子目录里面的子目录和文件，等等）到另外一个目录中，可以使用 shutil的copytree函数。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">from shutil import copytree\n# 拷贝 d:&#x2F;tools&#x2F;aaa 目录中所有的内容 到 e:&#x2F;bbb 中\ncopytree(&#39;d:&#x2F;tools&#x2F;aaa&#39;, &#39;e:&#x2F;new&#x2F;bbb&#39;)</code></pre>\n<p>注意拷贝前， 目标目录必须 不存在 ，否则会报错。</p>\n<p>上面的代码执行前面，如果 e:/new/bbb 已经存在，执行到copytree时，就会报错</p>\n<p>上面的代码执行前面，如果 e:/new 这个目录都不存在，执行到copytree时，就会 创建 e:/new 目录，再创建 e:/new/bbb 目录，再拷贝 d:/tools/aaa 目录中所有的内容 到 e:/new/bbb 中。</p>\n<p>上面的代码执行前面，如果 e:/new 这个目录存在，但是 e:/new/bbb 不存在，执行到copytree时，就只会 创建 e:/new/bbb ，再拷贝 d:/tools/aaa 目录中所有的内容 到 e:/new/bbb 中。<br>###修改文件名、目录名<br>要修改文件名、目录名，可以使用os模块的rename函数。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\"># 修改目录名 d:&#x2F;tools&#x2F;aaa 为 d:&#x2F;tools&#x2F;bbb\nos.rename(&#39;d:&#x2F;tools&#x2F;aaa&#39;,&#39;d:&#x2F;tools&#x2F;bbb&#39;)\n\n# 修改文件名 d:&#x2F;tools&#x2F;first.py 为 d:&#x2F;tools&#x2F;second.py\nos.rename(&#39;d:&#x2F;tools&#x2F;first.py&#39;,&#39;d:&#x2F;tools&#x2F;second.py&#39;)</code></pre>\n\n<h3 id=\"对文件路径名的操作\"><a href=\"#对文件路径名的操作\" class=\"headerlink\" title=\"对文件路径名的操作\"></a>对文件路径名的操作</h3><p>对于文件名的操作，比如 获取文件名称，文件所在目录，文件路径的拼接等，都可以使用 os.path 模块。</p>\n<p>通常我们喜欢使用格式化字符串的方法来做文件路径的拼接，但是如果你的程序需要在Linux、Windows等多个平台运行，它们的路径的分隔符是不同的，Windows上是 <code>\\</code> , 而 Linux上是 <code>/</code>。</p>\n<p>这时，我们应该使用 os.path 模块。 它能够自动处理类似 Data/data.csv 和 Data\\data.csv 这样的文件路径差异。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">path &#x3D; &#39;&#x2F;Users&#x2F;beazley&#x2F;Data&#x2F;data.csv&#39;\n# 获取路径中的文件名部分\nos.path.basename(path)\n&#39;data.csv&#39;\n# 获取路径中的目录部分\nos.path.dirname(path)\n&#39;&#x2F;Users&#x2F;beazley&#x2F;Data&#39;\n# 文件路径的拼接\nos.path.join(&#39;tmp&#39;, &#39;data&#39;, os.path.basename(path))\n&#39;tmp&#x2F;data&#x2F;data.csv&#39;</code></pre>\n<h3 id=\"判断文件、目录是否存在\"><a href=\"#判断文件、目录是否存在\" class=\"headerlink\" title=\"判断文件、目录是否存在\"></a>判断文件、目录是否存在</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">os.path.exists(&#39;d:&#x2F;systems&#x2F;cmd.exe&#39;)\nos.path.exists(&#39;d:&#x2F;systems&#39;)</code></pre>\n<p>exists方法返回值为True表示 存在，否则表示不存在。<br>如果你要判断指定路径是否是文件，可以这样<br>os.path.isfile(‘d:/systems/cmd.exe’)# 返回值为True 表示是文件<br>如果你要判断指定路径是否是目录，可以这样<br>os.path.isdir(‘d:/systems’)#返回值为True 表示是目录</p>\n<p>###文件大小和修改日期</p>\n<ul>\n<li><p>返回文件大小<br>os.path.getsize(‘file1’)<br>3669</p>\n</li>\n<li><p>返回文件的最后修改日期，是秒时间<br>参考下一章 日期和时间 里面的内容<br>os.path.getmtime(‘file1’)<br>1272478234.0</p>\n</li>\n<li><p>可以把秒时间 转化为日期时间<br>import time<br>time.ctime(os.path.getmtime(‘/etc/passwd’))<br>‘Wed Apr 28 13:10:34 2010’</p>\n</li>\n</ul>\n<p>###当前工作目录<br>当前工作目录的路径：<br>wd = os.getcwd()<br>改变当前工作目录到另外的路径：<br>os.chdir(path)<br>参数就是 新的当前工作目录 路径地址。</p>\n<p>###递归的遍历目录下面所有的文件<br>获取某个目录中所有的 文件， 包括子目录里面的文件。 可以使用 os库中的walk方法<br>比如我们要得到某个目录下面所有的子目录 和所有的文件，存放在两个列表中<br> os.walk(top[, topdown=True[, onerror=None[, followlinks=False]]])<br>    top ：是你所要遍历的目录的地址, 返回的是一个三元组 (dirpath, dirnames, filenames)<br>    topdown ：可选，True则优先遍历 top 文件夹，与top 文件夹中每一个子目录；否则优先遍历 top 的子目录(默认为开启)。<br>    onerror ：可选，需要一个 callable 对象，当 walk 需要异常时，会调用<br>    followlinks ：可选，如果为 True，则会遍历目录下的快捷方式(linux 下是软连接 symbolic link )实际所指的目录(默认关闭)，如果为 False，则优先遍历 top 的子目录；</p>\n<ul>\n<li>得到某个目录下所有文件的全路径<pre class=\"line-numbers language-none\"><code class=\"language-none\">import os\n# 目标目录\ntargetDir &#x3D; r&#39;d:\\tmp\\util\\dist\\check&#39;\nfor (dirpath, dirnames, filenames) in os.walk(targetDir):\n    for fn in filenames:\n        # 把 dirpath 和 每个文件名拼接起来 就是全路径\n        fpath &#x3D; os.path.join(dirpath, fn)\n# dirpath 代表当前遍历到的目录名\n# dirnames 是列表对象，存放当前dirpath中的所有子目录名\n# filenames 是列表对象，存放当前dirpath中的所有文件名</code></pre>\n<h3 id=\"得到目录中所有的文件和子目录名\"><a href=\"#得到目录中所有的文件和子目录名\" class=\"headerlink\" title=\"得到目录中所有的文件和子目录名\"></a>得到目录中所有的文件和子目录名</h3>listdir返回的是该目录下面所有的文件和子目录。<pre class=\"line-numbers language-none\"><code class=\"language-none\"># 目标目录\ntargetDir &#x3D; r&#39;d:\\tmp\\util\\dist\\check&#39;\nfiles &#x3D;  os.listdir(targetDir)\nprint(files)</code></pre>\n如果只需要获取目录中所有的文件，或者只需要子目录<pre class=\"line-numbers language-none\"><code class=\"language-none\">import os\nfrom os.path import isfile, join,isdir\n# 目标目录\ntargetDir &#x3D; r&#39;d:\\tmp\\util\\dist\\check&#39;\n# 所有的文件\nprint([f for f in os.listdir(targetDir) if isfile(join(targetDir, f))])\n# 所有的目录\nprint([f for f in os.listdir(targetDir) if isdir(join(targetDir, f))])</code></pre>\n###得到目录中指定扩展名的文件和子目录<br>可以使用glob库<pre class=\"line-numbers language-none\"><code class=\"language-none\">import glob\nexes &#x3D; glob.glob(r&#39;d:\\tmp\\*.txt&#39;)\nprint(exes)</code></pre>\n<a class=\"link\"   href=\"http://www.byhy.net/tut/py/extra/file_dir\" >http://www.byhy.net/tut/py/extra/file_dir<i class=\"fas fa-external-link-alt\"></i></a></li>\n</ul>\n","text":"import os 创建目录结构 os.makedirs 可以递归的创建目录结构，比如os.makedirs(&#39;tmp&#x2F;python&#x2F;fileop&#39;,exist_ok&#x3D;True) 在当前工作目录下面创建 tmp目录，在tmp目录下面再...","link":"","photos":[],"count_time":{"symbolsCount":"4.1k","symbolsTime":"4 mins."},"categories":[],"tags":[{"name":"自动化","slug":"自动化","count":4,"path":"api/tags/自动化.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%9B%E5%BB%BA%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">创建目录结构</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6%E6%88%96%E7%9B%AE%E5%BD%95\"><span class=\"toc-text\">删除文件或目录</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%8B%B7%E8%B4%9D%E6%96%87%E4%BB%B6\"><span class=\"toc-text\">拷贝文件</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AF%B9%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84%E5%90%8D%E7%9A%84%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">对文件路径名的操作</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%A4%E6%96%AD%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8\"><span class=\"toc-text\">判断文件、目录是否存在</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%BE%97%E5%88%B0%E7%9B%AE%E5%BD%95%E4%B8%AD%E6%89%80%E6%9C%89%E7%9A%84%E6%96%87%E4%BB%B6%E5%92%8C%E5%AD%90%E7%9B%AE%E5%BD%95%E5%90%8D\"><span class=\"toc-text\">得到目录中所有的文件和子目录名</span></a></li></ol>","author":{"name":"Aurora","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"python办公自动化：邮件发送","uid":"3836a474642d761a6e5b64bf08fc9275","slug":"python办公自动化：邮件发送","date":"2021-04-05T02:24:12.000Z","updated":"2022-04-03T06:09:35.722Z","comments":true,"path":"api/articles/python办公自动化：邮件发送.json","keywords":null,"cover":null,"text":" 邮件批量发送调用smtp.exmail.qq.com批量自动发送邮件注意文件路径，逗号分隔符，csv中不要有多余回车和空格import os import sys import csv import smtplib import pandas as pd import nump...","link":"","photos":[],"count_time":{"symbolsCount":"3.5k","symbolsTime":"3 mins."},"categories":[],"tags":[{"name":"自动化","slug":"自动化","count":4,"path":"api/tags/自动化.json"}],"author":{"name":"Aurora","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"python关联分析（apriori算法）","uid":"917af4fce65ef9c1196ef8527f6229c9","slug":"python关联分析（apriori算法）","date":"2021-02-28T14:05:20.000Z","updated":"2022-04-03T06:07:30.257Z","comments":true,"path":"api/articles/python关联分析（apriori算法）.json","keywords":null,"cover":null,"text":"若两个或多个变量的取值之间存在某种规律性，就称为关联。关联规则是寻找在同一个事件中出现的不同项的相关性，比如在一次购买活动中所买不同商品的相关性。例如：“在购买计算机的顾客中，有30％的人也同时购买了打印机”。 一个样本称为一个“事务”每个事务由多个属性来确定，这里的属性称为“项...","link":"","photos":[],"count_time":{"symbolsCount":"2.4k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"数据分析","slug":"数据分析","count":18,"path":"api/tags/数据分析.json"}],"author":{"name":"Aurora","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}