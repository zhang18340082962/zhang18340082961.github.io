{"title":"python连接mysql:读取、写入、更新、删除","uid":"f671959f062d49d2d4345cd4aa269a83","slug":"python数据分析：连接mysql，读取、写入、更新、删除","date":"2021-07-04T05:16:15.000Z","updated":"2022-05-29T15:36:21.952Z","comments":true,"path":"api/articles/python数据分析：连接mysql，读取、写入、更新、删除.json","keywords":null,"cover":null,"content":"<h2 id=\"1、连接读取数据\"><a href=\"#1、连接读取数据\" class=\"headerlink\" title=\"1、连接读取数据\"></a>1、连接读取数据</h2><h3 id=\"第一种：用pymysql连接\"><a href=\"#第一种：用pymysql连接\" class=\"headerlink\" title=\"第一种：用pymysql连接\"></a>第一种：用pymysql连接</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">#安装pymysql\nconda install pymysql\n#或者\npip install pymysql</code></pre>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">import pymysql\n#创建数据库连接，依次是主机名，用户名，密码，要打开的数据库，端口号和编码类型\ndef get_conn():\n    conn &#x3D; pymysql.connect(\n        host&#x3D;&quot;****&quot;,\n        user&#x3D;&quot;****&quot;,\n        password&#x3D;&quot;****&quot;,\n        db&#x3D;&quot;****&quot;,\n        charset&#x3D;&quot;utf8&quot;,\n        port&#x3D;3306,\n    )\n    # 创建游标：\n    cursor &#x3D; conn.cursor()\n    return conn, cursor\ndef close_conn(conn, cursor):\n    if cursor:\n        cursor.close()\n    if conn:\n        conn.close()\ndef query(sql, *args):\n    &#39;&#39;&#39;\n    :param sql:\n    :param args:\n    :return:返回结果，提取数据，返回的data是一个二维元组，((),())形式；\n    &#39;&#39;&#39;\n    conn, cursor&#x3D; get_conn()\n    cursor.execute(sql)\n    res &#x3D; cursor.fetchall() # 获取结果\n    close_conn(conn, cursor)\n    return res\n#返回的是所有行在对应列的值</code></pre>\n\n<pre class=\"line-numbers language-none\"><code class=\"language-none\"># connect.commit()\n#如果对数据进行了增删改查的话，执行该语句，相当于把对数据库的操作提交上去，否则修改不会生效\nclose_conn(conn, cursor)#当然要有关闭游标和数据库连接的习惯</code></pre>\n\n<ul>\n<li>fetchone与fetchall的理解；举个例子:cursor是我们连接数据库的实例<br>fetchone()的使用:返回值是单个的元组,也就是一行记录,如果没有结果,那就会返回null</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">cursor.execute(f&quot;select username,password,nickname from user where id&#x3D;&#123;input&#125;&quot;)\nresult&#x3D;cursor.fetchone();  \n此时我们可以通过result[0],result[1],result[2]得到username,password,nickname</code></pre>\n<p>fetchall()的使用:返回值是多个元组,即返回多个行记录,如果没有结果,返回的是()</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">cursor.execute(select * from user)\nresult&#x3D;cursor.fetchall();此时select得到的可能是多行记录,那么我们通过fetchall得到的就是多行记录,是一个二维元组\n((username1,password1,nickname1),(username2,password2,nickname2),(username3,password3,nickname))</code></pre>\n<h3 id=\"第二种：pandas内置的read-sql\"><a href=\"#第二种：pandas内置的read-sql\" class=\"headerlink\" title=\"第二种：pandas内置的read_sql\"></a>第二种：pandas内置的read_sql</h3><p>  需要安装sqlalchemy,但是可以DataFrame的形式读出来，方便多了</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">conda install sqlalchemy\n#或者\npip install sqlalchemy</code></pre>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">import pandas as pd\nfrom sqlalchemy import create_engine\ndef reader_sql(query,db&#x3D;&#39;myemployees&#39;):\n    sql &#x3D; query\n    engine &#x3D; create_engine(f&#39;mysql+pymysql:&#x2F;&#x2F;root:&#123;pwd&#125;@localhost:3306&#x2F;&#123;db&#125;?charset&#x3D;utf8&#39;)\n    #格式一点不能错，依次是用户名，密码（###），主机名，端口号，要连接的数据库，指定编码\n    df &#x3D; pd.read_sql(sql,engine)\n    return df\ndf_departments &#x3D; reader_sql(&#39;select  * from departments&#39;)#这里输出的是一个dataframe</code></pre>\n<h2 id=\"2、写入数据\"><a href=\"#2、写入数据\" class=\"headerlink\" title=\"2、写入数据\"></a>2、写入数据</h2><h3 id=\"第一种：to-sql写入\"><a href=\"#第一种：to-sql写入\" class=\"headerlink\" title=\"第一种：to_sql写入\"></a>第一种：to_sql写入</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">result.to_sql(name&#x3D;&#39;newtable&#39;,con&#x3D;engine,if_exists&#x3D;&#39;append&#39;,index&#x3D;False)\n#这里的index如果为True的话也会报错，数据库中没有索引列（建表的时候没有预留索引列的位置）\n#默认参数是fail，如果这张表本来存在的话，操作就会fail失败掉\n#不建议这种直接建表操作，这样的表中字段类型会有变化，不符合原先数据要求\n#建议在workbench中先create table并把所有字段的类型定义好，在使用to_sql进行写入</code></pre>\n<ul>\n<li>新建表设置好字段类型或者用cursor.execute执行建表语句后，就可以用to_sql写入了</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">result.to_sql(name&#x3D;&#39;new_table2&#39;,con&#x3D;engine,if_exists&#x3D;&#39;append&#39;,index&#x3D;False)\n#这里注意新建表的时候一定要把各个字段的类型搞准确，编码搞清楚不然没意识到出个错，很难受\n#如果重复执行这行代码的话，会导致插入的数据成倍数增加，因为你传入的append参数，会在原数据上接着添加</code></pre>\n\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">del result[&#39;department_name&#39;]#删掉一列后再进行写入\nresult.to_sql(name&#x3D;&#39;new_table2&#39;,con&#x3D;engine,if_exists&#x3D;&#39;append&#39;,index&#x3D;False)\n#如果建表时在NN列未勾选上的话，不会报错，会发现原本的值数量多了一倍，且新增的数据中的department_name列均为空值\n#但如果建表时在NN列勾选上的话，表示该字段不允许为空值，就会报错\n#还有如果写入的数据字段多了，与建表时给定的字段数量不符也会报错</code></pre>\n<ul>\n<li>将excel中分sheet写入数据库</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">import pymysql\nimport pandas as pd\nfrom sqlalchemy import create_engine\nimport xlrd\nfile &#x3D; r&#39;C:\\Users\\sofia.xlsx&#39;\n#分sheet写入数据库\n# 然后调用df.to_sql()函数将dataframe数据写入：\n\n&quot;&quot;&quot; 打开excel表格&quot;&quot;&quot;\nworkbook &#x3D; xlrd.open_workbook(file)\nsheet_names &#x3D; workbook.sheet_names()\nfor i in sheet_names :\n    data &#x3D; pd.read_excel(file,sheet_name &#x3D; i,index &#x3D; False,encoding&#x3D;&#39;utf-8&#39;)\n    data.to_sql(i,con&#x3D;engine,if_exists&#x3D;&#39;replace&#39;,index&#x3D;False)</code></pre>\n\n<ul>\n<li>pd.read_sql()介绍</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">pandas.read_sql(sql, con, index_col&#x3D;None, coerce_float&#x3D;True, params&#x3D;None, parse_dates&#x3D;None, columns&#x3D;None, chunksize&#x3D;None)\n各参数意义：\nsql:SQL命令字符串\ncon：连接sql数据库的engine，一般可以用SQLalchemy或者pymysql之类的包建立\nindex_col: 选择某一列作为index\ncoerce_float:非常有用，将数字形式的字符串直接以float型读入\nparse_dates:将某一列日期型字符串转换为datetime型数据，与pd.to_datetime函数功能类似。可以直接提供需要转换的列名以默认的日期形式转换，也可以用字典的格式提供列名和转换的日期格式，比如&#123;column_name: format string&#125;（format string：&quot;%Y:%m:%H:%M:%S&quot;）。\ncolumns:要选取的列。一般没啥用，因为在sql命令里面一般就指定要选择的列了\nchunksize：如果提供了一个整数值，那么就会返回一个generator，每次输出的行数就是提供的值的大小。\n##read_sql本质上是read_sql_table、read_sql_query的统一方式。\n三者都return返回DataFrame。</code></pre>\n<p><a href=\"https://pandas.pydata.org/pandas-docs/stable/generated/pandas.read_sql_table.html#pandas.read_sql_table\"><code>read_sql_table</code></a></p>\n<p>Read SQL database table into a DataFrame.</p>\n<p><a href=\"https://pandas.pydata.org/pandas-docs/stable/generated/pandas.read_sql_query.html#pandas.read_sql_query\"><code>read_sql_query</code></a></p>\n<p>Read SQL query into a DataFrame.</p>\n<p><a href=\"http://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.to_sql.html\">to_sql</a><br>主要有以下几个参数：</p>\n<ul>\n<li>  name: 输出的表名</li>\n<li>  con: 与read_sql中相同</li>\n<li>  if_exits： 三个模式：fail，若表存在，则不输出；replace：若表存在，覆盖原来表里的数据；append：若表存在，将数据写到原表的后面。默认为fail</li>\n<li>  index：是否将df的index单独写到一列中</li>\n<li>  index_label:指定列作为df的index输出，此时index为True</li>\n<li>  chunksize： 同read_sql</li>\n<li>dtype: 指定列的输出到数据库中的数据类型。字典形式储存：{column_name: sql_dtype}。常见的数据类型有sqlalchemy.types.INTEGER(), sqlalchemy.types.NVARCHAR(),sqlalchemy.Datetime()等，具体数据类型可以参考<a href=\"http://docs.sqlalchemy.org/en/latest/core/type_basics.html#sql-standard-and-multiple-vendor-types\">这里</a><br>  还是以写到mysql数据库为例：<pre class=\"line-numbers language-none\"><code class=\"language-none\">df.to_sql(name&#x3D;&#39;table&#39;, \n          con&#x3D;con, \n          if_exists&#x3D;&#39;append&#39;, \n          index&#x3D;False,\n          dtype&#x3D;&#123;&#39;col1&#39;:sqlalchemy.types.INTEGER(),\n                 &#39;col2&#39;:sqlalchemy.types.NVARCHAR(length&#x3D;255),\n                 &#39;col_time&#39;:sqlalchemy.DateTime(),\n                 &#39;col_bool&#39;:sqlalchemy.types.Boolean\n          &#125;)</code></pre></li>\n<li>*注：**如果不提供dtype,to_sql会自动根据df列的dtype选择默认的数据类型输出，比如字符型会以sqlalchemy.types.TEXT类型输出，相比NVARCHAR，TEXT类型的数据所占的空间更大，所以一般会指定输出为NVARCHAR；而如果df的列的类型为np.int64时，将会导致无法识别并转换成INTEGER型，需要事先转换成int类型（用map，apply函数可以方便的转换）。<br><a href=\"https://www.cnblogs.com/arkenstone/p/6271923.html\">https://www.cnblogs.com/arkenstone/p/6271923.html</a></li>\n</ul>\n<h3 id=\"第二种：cursor-execute-直接写入\"><a href=\"#第二种：cursor-execute-直接写入\" class=\"headerlink\" title=\"第二种：cursor.execute()直接写入\"></a>第二种：cursor.execute()直接写入</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">#插入方法无需改动，传入一个动态变化的字典\nconnect &#x3D; pymysql.connect(host&#x3D;&#39;&#39;,user&#x3D;&#39;&#39;,db &#x3D; &#39;&#39;,password&#x3D;&#39;&#39;,port&#x3D;3306,charset&#x3D;&#39;utf8&#39;)\ncursor&#x3D;connect.cursor()\ndata &#x3D; &#123;&quot;id&quot;:&#39;100&#39;,&#39;name&#39;:&#39;Bob&#39;&#125;\ntable&#x3D; &#39;stuinfo&#39;\nkeys &#x3D; &#39;, &#39;.join(data.keys())\nvalues &#x3D; &#39;, &#39;.join([&#39;%s&#39;]*len(data))\nsql &#x3D; f&quot;insert into &#123;table&#125;(&#123;keys&#125;) values(&#123;values&#125;)&quot;\ntry:\n    cursor.execute(sql,tuple(data.values()))\n    connect.commit()\n    cursor.execute(&#39;select * from &#123;table&#125;&#39;.format(table&#x3D;table))\n    print(&#39;执行成功&#39;,cursor.fetchall())\nexcept:\n    print(&quot;插入失败，数据回滚&quot;)\n    connect.rollback()</code></pre>\n<h2 id=\"更新数据\"><a href=\"#更新数据\" class=\"headerlink\" title=\"更新数据\"></a>更新数据</h2><pre class=\"line-numbers language-none\"><code class=\"language-none\">#更新，把Bon的age更新为28\nsql &#x3D; &quot;update stuinfo set id&#x3D;%s where name &#x3D; %s&quot;\ncursor.execute(sql,(&quot;28&quot;,&#39;Bob&#39;))\nconnect.commit()\ncursor.execute(&#39;select * from stuinfo&#39;)\nprint(&quot;Successful:&quot;,cursor.fetchall())</code></pre>\n<h2 id=\"删除数据\"><a href=\"#删除数据\" class=\"headerlink\" title=\"删除数据\"></a>删除数据</h2><pre class=\"line-numbers language-none\"><code class=\"language-none\">#删除数据\nsql &#x3D; &quot;delete from stuinfo where id &gt;&#x3D;10&quot;\ncursor.execute(sql)\nconnect.commit()\ncursor.execute(&quot;select * from stuinfo&quot;)\nprint(cursor.fetchall())</code></pre>","text":"1、连接读取数据第一种：用pymysql连接#安装pymysql conda install pymysql #或者 pip install pymysql import pymysql #创建数据库连接，依次是主机名，用户名，密码，要打开的数据库，端口号和编码类型 def ge...","link":"","photos":[],"count_time":{"symbolsCount":"6.6k","symbolsTime":"6 mins."},"categories":[{"name":"python","slug":"python","count":18,"path":"api/categories/python.json"}],"tags":[{"name":"数据分析","slug":"数据分析","count":17,"path":"api/tags/数据分析.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1%E3%80%81%E8%BF%9E%E6%8E%A5%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE\"><span class=\"toc-text\">1、连接读取数据</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%AC%AC%E4%B8%80%E7%A7%8D%EF%BC%9A%E7%94%A8pymysql%E8%BF%9E%E6%8E%A5\"><span class=\"toc-text\">第一种：用pymysql连接</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%AC%AC%E4%BA%8C%E7%A7%8D%EF%BC%9Apandas%E5%86%85%E7%BD%AE%E7%9A%84read-sql\"><span class=\"toc-text\">第二种：pandas内置的read_sql</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2%E3%80%81%E5%86%99%E5%85%A5%E6%95%B0%E6%8D%AE\"><span class=\"toc-text\">2、写入数据</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%AC%AC%E4%B8%80%E7%A7%8D%EF%BC%9Ato-sql%E5%86%99%E5%85%A5\"><span class=\"toc-text\">第一种：to_sql写入</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%AC%AC%E4%BA%8C%E7%A7%8D%EF%BC%9Acursor-execute-%E7%9B%B4%E6%8E%A5%E5%86%99%E5%85%A5\"><span class=\"toc-text\">第二种：cursor.execute()直接写入</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE\"><span class=\"toc-text\">更新数据</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE\"><span class=\"toc-text\">删除数据</span></a></li></ol>","author":{"name":"弦好想断","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"处女座男生，热爱技术、吉他、旅行。","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"python-flask疫情数据可视化","uid":"d36edaa00a28ef96e171ed217c165e70","slug":"python-flask疫情数据可视化","date":"2021-07-21T06:18:39.000Z","updated":"2022-05-29T15:35:35.179Z","comments":true,"path":"api/articles/python-flask疫情数据可视化.json","keywords":null,"cover":[],"text":"Flask是一个轻量级的web框架，看了https://www.bilibili.com/video/BV177411j7qJ 大佬的视频，做的一个疫情可视化项目,（电脑屏幕小看着有点拥挤。大屏展示还是挺好看的），热搜词云的数据找不到网站了，就弄了个表格；自己修改了一些部分，感兴...","link":"","photos":[],"count_time":{"symbolsCount":309,"symbolsTime":"1 mins."},"categories":[{"name":"python","slug":"python","count":18,"path":"api/categories/python.json"}],"tags":[{"name":"数据分析","slug":"数据分析","count":17,"path":"api/tags/数据分析.json"}],"author":{"name":"弦好想断","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"处女座男生，热爱技术、吉他、旅行。","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"python数据采集：selenium爬虫、自动化","uid":"8ca00045c38562501faacb57ba3b1700","slug":"python数据采集：selenium爬虫、自动化","date":"2021-05-05T02:34:57.000Z","updated":"2022-05-29T15:36:15.691Z","comments":true,"path":"api/articles/python数据采集：selenium爬虫、自动化.json","keywords":null,"cover":null,"text":"中文文档https:&#x2F;&#x2F;python-selenium-zh.readthedocs.io&#x2F;zh_CN&#x2F;latest&#x2F; 装包：pip install selenium下载chrome：https://www.google.cn/c...","link":"","photos":[],"count_time":{"symbolsCount":"1.7k","symbolsTime":"2 mins."},"categories":[{"name":"python","slug":"python","count":18,"path":"api/categories/python.json"}],"tags":[{"name":"数据分析","slug":"数据分析","count":17,"path":"api/tags/数据分析.json"}],"author":{"name":"弦好想断","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"处女座男生，热爱技术、吉他、旅行。","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}