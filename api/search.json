[{"id":"93839c1fe9dbfd84d387b7dc441e6dcb","title":"python实现鼠标键盘自动化——pyautogui、opencv","content":"概述：总的来说这是一个通过个人自定义流程，在python环境下通过自定义鼠标键盘操作来实现自动化办公的RPA工具~\n所需环境：pip install -i https://pypi.tuna.tsinghua.edu.cn/simple pyperclip 回车\npip install -i https://pypi.tuna.tsinghua.edu.cn/simple xlrd 回车\npip install -i https://pypi.tuna.tsinghua.edu.cn/simple pyautogui==0.9.50 回车\npip install -i https://pypi.tuna.tsinghua.edu.cn/simple opencv-python 回车\npip install -i https://pypi.tuna.tsinghua.edu.cn/simple pillow 回车\n初始化操作import pyautogui\nimport xlrd\nimport pyperclip\nimport time\nimport os\nimport shutil\nimport sys\n\n# pyautogui.PAUSE &#x3D; 1 # 调用在执行动作后暂停的秒数，只能在执行一些pyautogui动作后才能使用，建议用time.sleep\npyautogui.FAILSAFE &#x3D; False # 启用自动防故障功能，左上角的坐标为（0，0），将鼠标移到屏幕的左上角，来抛出failSafeException异常\n\ndef resource_path(relative_path):\n    if getattr(sys, &#39;frozen&#39;, False):  # 是否Bundle Resource\n        base_path &#x3D; sys._MEIPASS\n    else:\n        base_path &#x3D; os.path.abspath(&quot;.&quot;)\n    return os.path.join(base_path, relative_path)\n\ndef ClearTemp():\n    MEIpath &#x3D; &quot;C:\\\\Users\\\\&quot; + os.getlogin() + &quot;\\\\AppData\\\\Local\\\\Temp&quot;\n    # mylog(&quot;当前临时文件位置&quot;, MEIpath)\n    # print(os.getlogin()) #获取计算机使用对象\n    for root, dirs, files in os.walk(MEIpath):\n        if &quot;_MEI&quot; in root:\n            try:\n                print(&quot;正在清理:&quot;,root)\n                shutil.rmtree(root)\n            except:\n                pass\n        else:\n            pass\n\n\n定义鼠标事件# pyautogui库其他用法 https:&#x2F;&#x2F;blog.csdn.net&#x2F;qingfengxd1&#x2F;article&#x2F;details&#x2F;108270159\ndef mouseClick(clickTimes, lOrR, img, reTry,fail_retry,retry_interval):\n    try:\n        time.sleep(retry_interval&#x2F;1000000)\n        fail_retry &#x3D; int(fail_retry)\n    except:\n        fail_retry&#x3D;10\n        retry_interval&#x3D;0.1\n    f &#x3D; open(f&quot;日志文件\\&#123;time.strftime(&#39;%Y-%m-%d&#39;, time.localtime())&#125;.txt&quot;,&quot;a+&quot;)\n    global pic_exist\n    pic_exist&#x3D; False\n    if reTry &#x3D;&#x3D; 1:\n        fail_retry_num&#x3D; 1\n        while True:\n            location &#x3D; pyautogui.locateCenterOnScreen(img, confidence&#x3D;0.98)\n            if location is not None:\n                pyautogui.click(location.x, location.y, clicks&#x3D;clickTimes, interval&#x3D;0.2, duration&#x3D;0.2, button&#x3D;lOrR)\n                break\n\n            print(f&quot;未找到匹配图片&#123;img&#125;,我将在&#123;retry_interval&#125;秒后重试&quot;)\n            f.write(f&quot;未找到匹配图片&#123;img&#125;,我将在&#123;retry_interval&#125;秒后重试\\n&quot;)\n            time.sleep(retry_interval)\n            fail_retry_num+&#x3D;1\n            if fail_retry_num&gt;fail_retry:\n                print(f&quot;已重试&#123;fail_retry&#125;次&quot;)\n                f.write(f&quot;已重试&#123;fail_retry&#125;次\\n&quot;)\n                pic_exist &#x3D; True\n                break\n    elif reTry &#x3D;&#x3D; -1:\n        #不建议这么搞\n        fail_retry_num&#x3D;1\n        while True:\n            location &#x3D; pyautogui.locateCenterOnScreen(img, confidence&#x3D;0.98)\n            if location is not None:\n                pyautogui.click(location.x, location.y, clicks&#x3D;clickTimes, interval&#x3D;0.2, duration&#x3D;0.2, button&#x3D;lOrR)\n            else:\n                print(f&quot;未找到匹配图片&#123;img&#125;,我将在&#123;retry_interval&#125;秒后重试&quot;)\n                f.write(f&quot;未找到匹配图片&#123;img&#125;,我将在&#123;retry_interval&#125;秒后重试\\n&quot;)\n    \n            time.sleep(retry_interval)\n            fail_retry_num +&#x3D; 1\n            if fail_retry_num &gt; fail_retry:\n                print(f&quot;已重试&#123;fail_retry&#125;次，无限重复且找不到图,你这是在玩火啊！&quot;)\n                f.write(f&quot;已重试&#123;fail_retry&#125;次，无限重复且找不到图!你这是在玩火啊！\\n&quot;)\n                pic_exist &#x3D; True\n                break\n\n\n    elif reTry &gt; 1:\n        i &#x3D; 1\n        fail_retry_num&#x3D;1\n        while i &lt; reTry + 1:\n            location &#x3D; pyautogui.locateCenterOnScreen(img, confidence&#x3D;0.98)\n            if location is not None:\n                pyautogui.click(location.x, location.y, clicks&#x3D;clickTimes, interval&#x3D;0.2, duration&#x3D;0.2, button&#x3D;lOrR)\n                print(&quot;重复&quot;)\n                i +&#x3D; 1\n            else:\n                print(f&quot;未找到匹配图片&#123;img&#125;,我将在&#123;retry_interval&#125;秒后重试&quot;)\n                f.write(f&quot;未找到匹配图片&#123;img&#125;,我将在&#123;retry_interval&#125;秒后重试\\n&quot;)\n            time.sleep(retry_interval)\n            fail_retry_num +&#x3D; 1\n            if fail_retry_num &gt; fail_retry:\n                print(f&quot;已重试&#123;fail_retry&#125;次&quot;)\n                f.write(f&quot;已重试&#123;fail_retry&#125;次\\n&quot;)\n                pic_exist &#x3D; True\n                break\n\n定义热键事件# hotkey_get方法用来判断热键组合个数,还是文字输入。此方法由B站up主 尔茄无双 提供。\ndef hotkey_get(hk_g_inputValue):\n    try:\n        newinput &#x3D; hk_g_inputValue.split(&#39;,&#39;)\n        pyautogui.hotkey(*tuple(newinput))\n    except:\n        pyperclip.copy(hk_g_inputValue)\n        pyautogui.hotkey(&#39;ctrl&#39;, &#39;v&#39;)\n# hotkey_get方法用来判断热键组合个数，并把热键传到对应的变量上newinput[0],[1],[2],[3]……[9]只写了10个后续可以添加。【老方法弃用】\n# newinput &#x3D; hk_g_inputValue.split(&#39;,&#39;)\n#         if len(newinput)&#x3D;&#x3D;1:\n#                 pyautogui.hotkey(hk_g_inputValue)\n#         elif len(newinput)&#x3D;&#x3D;2:\n#                 pyautogui.hotkey(newinput[0],newinput[1])\n#         elif len(newinput)&#x3D;&#x3D;3:\n#                 pyautogui.hotkey(newinput[0],newinput[1],newinput[2])\n#         elif len(newinput)&#x3D;&#x3D;4:\n#                 pyautogui.hotkey(newinput[0],newinput[1],newinput[2],newinput[3])\n#         elif len(newinput)&#x3D;&#x3D;4:\n#                     pyautogui.hotkey(newinput[0],newinput[1],newinput[2],newinput[3])\n#         elif len(newinput)&#x3D;&#x3D;5:\n#                     pyautogui.hotkey(newinput[0],newinput[1],newinput[2],newinput[3],newinput[4])\n#         elif len(newinput)&#x3D;&#x3D;6:\n#                     pyautogui.hotkey(newinput[0],newinput[1],newinput[2],newinput[3],newinput[4],newinput[5])\n#         elif len(newinput)&#x3D;&#x3D;7:\n#                     pyautogui.hotkey(newinput[0],newinput[1],newinput[2],newinput[3],newinput[4],newinput[5],newinput[6])\n#         elif len(newinput)&#x3D;&#x3D;8:\n#                     pyautogui.hotkey(newinput[0],newinput[1],newinput[2],newinput[3],newinput[4],newinput[5],newinput[6],newinput[7])\n#         elif len(newinput)&#x3D;&#x3D;9:\n#                     pyautogui.hotkey(newinput[0],newinput[1],newinput[2],newinput[3],newinput[4],newinput[5],newinput[6],newinput[7],newinput[8])\n#         elif len(newinput)&#x3D;&#x3D;10:\n#                     pyautogui.hotkey(newinput[0],newinput[1],newinput[2],newinput[3],newinput[4],newinput[5],newinput[6],newinput[7],newinput[8],newinput[9])\n\n# hotkey_Group方法调用hotkey_get方法，并判断其热键内容是否需要循环。\n#键盘热键\ndef hotkeyGroup(reTry, hkg_inputValue):\n    if reTry &#x3D;&#x3D; 1:\n        hotkey_get(hkg_inputValue)\n        print(&quot;执行了：&quot;, hkg_inputValue)\n        time.sleep(0.1)\n    elif reTry &#x3D;&#x3D; -1:\n        while True:\n            hotkey_get(hkg_inputValue)\n            print(&quot;执行了：&quot;, hkg_inputValue)\n            time.sleep(0.1)\n    elif reTry &gt; 1:\n        i &#x3D; 1\n        while i &lt; reTry + 1:\n            hotkey_get(hkg_inputValue)\n            print(&quot;执行了：&quot;, hkg_inputValue)\n            i +&#x3D; 1\n            time.sleep(0.1)\n\n数据检查# cmdType.value  1.0 左键单击    2.0 左键双击  3.0 右键单击  4.0 输入  5.0 等待  6.0 滚轮\n# 7.0 热键组合（最多4个）\n# 8.0 粘贴当前时间\n# 9.0 系统命令集\n# ctype     空：0\n#           字符串：1\n#           数字：2\n#           日期：3\n#           布尔：4\n#           error：5\ndef dataCheck(sheet1):\n    checkCmd &#x3D; True\n    # 行数检查\n    if sheet1.nrows &lt; 2:\n        print(&quot;没数据啊哥&quot;)\n        checkCmd &#x3D; False\n    # 每行数据检查\n    i &#x3D; 1\n    while i &lt; sheet1.nrows:\n        # 第1列 操作类型检查\n        cmdType &#x3D; sheet1.row(i)[0]\n        if cmdType.ctype !&#x3D; 2 or (cmdType.value !&#x3D; 1.0 and cmdType.value !&#x3D; 2.0 and cmdType.value !&#x3D; 3.0\n                                  and cmdType.value !&#x3D; 4.0 and cmdType.value !&#x3D; 5.0 and cmdType.value !&#x3D; 6.0\n                                  and cmdType.value !&#x3D; 7.0 and cmdType.value !&#x3D; 8.0 and cmdType.value !&#x3D; 9.0):\n            print(&#39;第&#39;, i + 1, &quot;行,第1列数据有毛病&quot;)\n            checkCmd &#x3D; False\n        # 第2列 内容检查\n        cmdValue &#x3D; sheet1.row(i)[1]\n        # 读图点击类型指令，内容必须为字符串类型\n        if cmdType.value &#x3D;&#x3D; 1.0 or cmdType.value &#x3D;&#x3D; 2.0 or cmdType.value &#x3D;&#x3D; 3.0:\n            if cmdValue.ctype !&#x3D; 1:\n                print(&#39;第&#39;, i + 1, &quot;行,第2列数据有毛病&quot;)\n                checkCmd &#x3D; False\n        # 输入类型，内容不能为空\n        if cmdType.value &#x3D;&#x3D; 4.0:\n            if cmdValue.ctype &#x3D;&#x3D; 0:\n                print(&#39;第&#39;, i + 1, &quot;行,第2列数据有毛病&quot;)\n                checkCmd &#x3D; False\n        # 等待类型，内容必须为数字\n        if cmdType.value &#x3D;&#x3D; 5.0:\n            if cmdValue.ctype !&#x3D; 2:\n                print(&#39;第&#39;, i + 1, &quot;行,第2列数据有毛病&quot;)\n                checkCmd &#x3D; False\n        # 滚轮事件，内容必须为数字\n        if cmdType.value &#x3D;&#x3D; 6.0:\n            if cmdValue.ctype !&#x3D; 2:\n                print(&#39;第&#39;, i + 1, &quot;行,第2列数据有毛病&quot;)\n                checkCmd &#x3D; False\n        # 7.0 热键组合，内容不能为空\n        if cmdType.value &#x3D;&#x3D; 7.0:\n            if cmdValue.ctype &#x3D;&#x3D; 0:\n                print(&#39;第&#39;, i + 1, &quot;行,第2列数据有毛病&quot;)\n                checkCmd &#x3D; False\n        # 8.0 时间，内容不能为空\n        if cmdType.value &#x3D;&#x3D; 8.0:\n            if cmdValue.ctype &#x3D;&#x3D; 0:\n                print(&#39;第&#39;, i + 1, &quot;行,第2列数据有毛病&quot;)\n                checkCmd &#x3D; False\n        # 9.0 系统命令集模式，内容不能为空\n        if cmdType.value &#x3D;&#x3D; 9.0:\n            if cmdValue.ctype &#x3D;&#x3D; 0:\n                print(&#39;第&#39;, i + 1, &quot;行,第2列数据有毛病&quot;)\n                checkCmd &#x3D; False\n        i +&#x3D; 1\n    return checkCmd\n\n任务def mainWork(img):\n    # cur_path &#x3D; os.getcwd()\n    i &#x3D; 1\n    f &#x3D; open(f&quot;日志文件\\&#123;time.strftime(&#39;%Y-%m-%d&#39;, time.localtime())&#125;.txt&quot;,&quot;a+&quot;)\n    # f.write(f&quot;\\n当前时间：&#123;time.strftime(&#39;%Y-%m-%d %H:%M:%S&#39;, time.localtime())&#125;\\n&quot;)\n    while i &lt; sheet1.nrows:\n        try:\n            # 取本行指令的操作类型\n            cmdType &#x3D; sheet1.row(i)[0]\n\n            if cmdType.value &#x3D;&#x3D; 1.0:\n                # 取图片名称\n                img &#x3D; sheet1.row(i)[1].value\n                reTry &#x3D; 1# 取重试次数\n                fail_retry &#x3D;sheet1.row(i)[3].value # 取查找图片失败重试次数\n                retry_interval &#x3D; sheet1.row(i)[4].value #取重试间隔\n                if sheet1.row(i)[2].ctype &#x3D;&#x3D; 2 and sheet1.row(i)[2].value !&#x3D; 0:\n                    reTry &#x3D; sheet1.row(i)[2].value\n                mouseClick(1, &quot;left&quot;, img, reTry,fail_retry,retry_interval)\n                if sheet1.row(i)[5].value&#x3D;&#x3D;1:\n                    print(f&quot;第&#123;i&#125;步，查找&#123;img&#125;超时将跳过\\n&quot;)\n                    f.write(f&quot;第&#123;i&#125;步，查找&#123;img&#125;超时将跳过\\n&quot;)\n                    pass\n                else:\n                    if pic_exist:\n                        #查找图片已超时\n                        print(f&quot;第&#123;i&#125;步，查找&#123;img&#125;超时将终止\\n&quot;)\n                        f.write(f&quot;第&#123;i&#125;步，查找&#123;img&#125;超时将终止\\n&quot;)\n                        break\n                    else:\n                        #查找未超时\n                        f.write(f&quot;第&#123;i&#125;步，单击左键&#123;reTry&#125;次，&#123;img&#125;\\n&quot;)\n                print(&quot;单击左键&quot;, img)\n    \n            # 2代表双击左键\n            elif cmdType.value &#x3D;&#x3D; 2.0:\n                # 取图片名称\n                img &#x3D; sheet1.row(i)[1].value\n                # 取重试次数\n                reTry &#x3D; 1\n                fail_retry &#x3D; sheet1.row(i)[3].value  # 取查找图片失败重试次数\n                retry_interval &#x3D; sheet1.row(i)[4].value  # 取重试间隔\n    \n                if sheet1.row(i)[2].ctype &#x3D;&#x3D; 2 and sheet1.row(i)[2].value !&#x3D; 0:\n                    reTry &#x3D; sheet1.row(i)[2].value\n                mouseClick(2, &quot;left&quot;, img, reTry,fail_retry,retry_interval)\n                if sheet1.row(i)[5].value&#x3D;&#x3D;1:\n                    print(f&quot;第&#123;i&#125;步，查找&#123;img&#125;超时将跳过\\n&quot;)\n                    f.write(f&quot;第&#123;i&#125;步，查找&#123;img&#125;超时将跳过\\n&quot;)\n                    pass\n                else:\n                    if pic_exist:\n                        #查找图片已超时\n                        print(f&quot;第&#123;i&#125;步，查找&#123;img&#125;超时将终止\\n&quot;)\n                        f.write(f&quot;第&#123;i&#125;步，查找&#123;img&#125;超时将终止\\n&quot;)\n                        break\n                    else:\n                        #查找未超时\n                        f.write(f&quot;第&#123;i&#125;步，双击左键&#123;reTry&#125;次，&#123;img&#125;\\n&quot;)\n                print(&quot;双击左键&quot;, img)\n                # f.write(f&quot;第&#123;i&#125;步，双击左键&#123;reTry&#125;次，&#123;img&#125;\\n&quot;)\n            # 3代表右键\n            elif cmdType.value &#x3D;&#x3D; 3.0:\n                # 取图片名称\n                img &#x3D; sheet1.row(i)[1].value\n                # 取重试次数\n                reTry &#x3D; 1\n                fail_retry &#x3D; sheet1.row(i)[3].value  # 取查找图片失败重试次数\n                retry_interval &#x3D; sheet1.row(i)[4].value  # 取重试间隔\n    \n                if sheet1.row(i)[2].ctype &#x3D;&#x3D; 2 and sheet1.row(i)[2].value !&#x3D; 0:\n                    reTry &#x3D; sheet1.row(i)[2].value\n                mouseClick(1, &quot;right&quot;, img, reTry,fail_retry,retry_interval)\n                if sheet1.row(i)[5].value &#x3D;&#x3D; 1:\n                    print(f&quot;第&#123;i&#125;步，查找&#123;img&#125;超时将跳过\\n&quot;)\n                    f.write(f&quot;第&#123;i&#125;步，查找&#123;img&#125;超时将跳过\\n&quot;)\n                    pass\n                else:\n                    if pic_exist:\n                        # 查找图片已超时\n                        print(f&quot;第&#123;i&#125;步，查找&#123;img&#125;超时将终止\\n&quot;)\n                        f.write(f&quot;第&#123;i&#125;步，查找&#123;img&#125;超时将终止\\n&quot;)\n                        break\n                    else:\n                        #查找未超时\n                        f.write(f&quot;第&#123;i&#125;步，单击右键&#123;reTry&#125;次，&#123;img&#125;\\n&quot;)\n                print(&quot;右键&quot;, img)\n                # f.write(f&quot;第&#123;i&#125;步，单击右键&#123;reTry&#125;次，&#123;img&#125;\\n&quot;)\n                # 4代表输入\n            elif cmdType.value &#x3D;&#x3D; 4.0:\n                inputValue &#x3D; sheet1.row(i)[1].value\n                pyperclip.copy(inputValue)\n                pyautogui.hotkey(&#39;ctrl&#39;, &#39;v&#39;)\n                print(f&quot;第&#123;i&#125;步，输入&#123;inputValue&#125;&quot;)\n                f.write(f&quot;第&#123;i&#125;步，输入&#123;inputValue&#125;\\n&quot;)\n                time.sleep(0.5)\n            # 5代表等待\n            elif cmdType.value &#x3D;&#x3D; 5.0:\n                #取等待时间\n                waitTime &#x3D; sheet1.row(i)[1].value\n                time.sleep(waitTime)\n                print(f&quot;第&#123;i&#125;步，等待&quot;, waitTime, &quot;秒&quot;)\n                f.write(f&quot;第&#123;i&#125;步，等待&#123;waitTime&#125;秒\\n&quot;)\n            # 6代表滚轮\n            elif cmdType.value &#x3D;&#x3D; 6.0:\n                #取滚动距离\n                scroll &#x3D; sheet1.row(i)[1].value\n                pyautogui.scroll(int(scroll))\n                print(f&quot;第&#123;i&#125;步，滚轮滑动,&#123;int(scroll)&#125;, 距离&quot;)\n                f.write(f&quot;第&#123;i&#125;步，滚轮滑动&#123;int(scroll)&#125;距离\\n&quot;)\n            # 7代表_热键组合\n            elif cmdType.value &#x3D;&#x3D; 7.0:\n                # 取重试次数,并循环。\n                reTry &#x3D; 1\n                if sheet1.row(i)[2].ctype &#x3D;&#x3D; 2 and sheet1.row(i)[2].value !&#x3D; 0:\n                    reTry &#x3D; sheet1.row(i)[2].value\n                inputValue &#x3D; sheet1.row(i)[1].value\n                hotkeyGroup(reTry, inputValue)\n                print(f&quot;第&#123;i&#125;步，执行了&#123;reTry&#125;次热键组合&#123;inputValue&#125;&quot;)\n                f.write(f&quot;第&#123;i&#125;步，执行了&#123;reTry&#125;次热键组合&#123;inputValue&#125;\\n&quot;)\n                time.sleep(0.5)\n            # 8代表_粘贴当前时间\n            elif cmdType.value &#x3D;&#x3D; 8.0:\n                # 设置本机当前时间。\n                localtime &#x3D; time.strftime(&quot;%Y-%m-%d %H：%M：%S&quot;, time.localtime())\n                pyperclip.copy(localtime)\n                pyautogui.hotkey(&#39;ctrl&#39;, &#39;v&#39;)\n                print(f&quot;第&#123;i&#125;步，粘贴了本机时间:&quot;, localtime)\n                f.write(f&quot;第&#123;i&#125;步，粘贴了本机时间: &#123;localtime&#125;\\n&quot;)\n                time.sleep(0.5)\n            # 9代表_系统命令集模式\n            elif cmdType.value &#x3D;&#x3D; 9.0:\n                wincmd &#x3D; sheet1.row(i)[1].value\n                os.system(wincmd)\n                print(f&quot;第&#123;i&#125;步，运行系统命令:&quot;, wincmd)\n                f.write(f&quot;第&#123;i&#125;步，运行系统命令 &#123;wincmd&#125;\\n&quot;)\n                time.sleep(0.5)\n    \n        except Exception as error:\n            print(f&quot;执行第&#123;i&#125;条步骤发生报错&#123;error&#125;,将中断当前流程，请解决错误后重新执行！&quot;)\n            f.write(f&quot;执行第&#123;i&#125;条步骤发生报错:\\n&#123;error&#125;,\\n将中断当前流程，请解决错误后重新执行！\\n&quot;)\n            # time.sleep(10)\n            break\n        i +&#x3D; 1\n    #关闭日志文件\n    f.write(f&quot;当前时间：&#123;time.strftime(&#39;%Y-%m-%d %H:%M:%S&#39;, time.localtime())&#125;\\n&quot;)\n    f.write(&quot;-----------本次流程执行日志记录完毕-----------\\n&quot;)\n    f.close()\n\n主程序while True:\n    if __name__ &#x3D;&#x3D; &#39;__main__&#39;:\n        file &#x3D; &#39;cmd.xls&#39;\n        # 打开文件\n        wb &#x3D; xlrd.open_workbook(filename&#x3D;file)\n        print(&#39;-----欢迎使用傻妞RPA~-----\\n&#39;)\n        try:\n            sheet_names &#x3D; wb.sheet_names()\n            sheet_name &#x3D; input(f&#39;请准确输入自动化流程sheet表名或位置序号(从1开始):  (输入0直接退出)\\n现有的sheet表名称有：&#39;\n                               f&#39;&#123;sheet_names&#125;\\nPS：执行包含“-0“的流程完毕后会自动退出\\n———————————————————————————————————————\\n&#39;)\n            if sheet_name&#x3D;&#x3D; &#39;0&#39;:\n                print(&quot;正清理缓存文件...&quot;)\n                # os.system(&#39;@echo off &amp; for &#x2F;d %i in (%temp%\\^_MEI*) do (rd &#x2F;s &#x2F;q &quot;%i&quot;)&gt;nul&#39;)\n                ClearTemp()\n                # exit(&quot;正在退出程序...&quot;)\n                break\n            elif type(int(sheet_name))&#x3D;&#x3D;int:\n                sheet_name &#x3D; sheet_names[int(sheet_name)-1]\n\n            # 通过索引获取表格sheet页\n            sheet1 &#x3D; wb.sheet_by_name(sheet_name)  # 这里选择你配置的工作表名称\n            f &#x3D; open(f&quot;日志文件\\&#123;time.strftime(&#39;%Y-%m-%d&#39;, time.localtime())&#125;.txt&quot;,&quot;a+&quot;)\n            f.write(f&quot;\\n当前时间：&#123;time.strftime(&#39;%Y-%m-%d %H:%M:%S&#39;, time.localtime())&#125;，即开始执行流程——&#123;sheet_name&#125;\\n&quot;)\n            f.close()\n        except Exception as e:\n            print(e,&quot;\\nsheet名输错了,没这个文件啊，重新输入吧(输入0可直接退出)\\n&quot;)\n            continue\n        # 避免多次循环导致的ctrl+v导入到，按ESC进行取消。\n        pyautogui.hotkey(&#39;esc&#39;)\n        # 数据检查\n        checkCmd &#x3D; dataCheck(sheet1)\n    \n        # 输入选项实现功能\n        if checkCmd:\n            key &#x3D; input(f&#39;即将开始执行流程：&#123;sheet_name&#125;\\n选择功能: 1.做一次 2.循环几次 0.退出程序\\n特殊功能：c.清理屏幕显示（请输入后最小化当前页面）\\n———————————————————————————————————————\\n&#39;)\n            if key &#x3D;&#x3D; &#39;1&#39; or key &#x3D;&#x3D;&quot;&quot;:\n                # 循环拿出每一行指令\n                print(&quot;正在执行第1次流程\\n&quot;)\n                mainWork(sheet1)\n                print(&quot;本次命令执行完了.&quot;)\n                print(&quot;正清理缓存文件...&quot;)\n                ClearTemp()\n                # os.system(&#39;@echo off &amp; for &#x2F;d %i in (%temp%\\^_MEI*) do (rd &#x2F;s &#x2F;q &quot;%i&quot;)&gt;nul&#39;)\n                # exit(&quot;正在退出程序...快去成为你想要的样子！&quot;)\n                print(&quot;清理缓存完毕，快去成为你想要的样子！&quot;)\n                print(&quot;——————————————————分割线——————————————————&quot;)\n                if &quot;-0&quot; in sheet_name:\n                    print(&quot;正清理缓存文件...&quot;)\n                    # os.system(&#39;@echo off &amp; for &#x2F;d %i in (%temp%\\^_MEI*) do (rd &#x2F;s &#x2F;q &quot;%i&quot;)&gt;nul&#39;)\n                    ClearTemp()\n                    exit(&quot;正在退出程序...&quot;)\n    \n            elif key &#x3D;&#x3D; &#39;2&#39;:\n                print(&quot;&quot;)\n                count &#x3D; 0\n                times &#x3D; input(&#39;想要执行几次呢? 最高执行10次喔\\n&#39;)\n                times &#x3D; int(times)\n                if count &lt; times and times&lt;&#x3D;10:\n                    while count &lt; times:\n                        count +&#x3D; 1\n                        print(&quot;正在执行第&quot;, count, &quot;次流程&quot;)\n                        mainWork(sheet1)\n                        time.sleep(0.1)\n                        print(&quot;等待0.1秒&quot;)\n                        print(&quot;已经完成第&quot;, count, &quot;次&quot;, &quot;命令&quot;)\n                        print(&quot;——————————————————分割线——————————————————&quot;)\n                if &quot;-0&quot; in sheet_name:\n                    print(&quot;正清理缓存文件...&quot;)\n                    # os.system(&#39;@echo off &amp; for &#x2F;d %i in (%temp%\\^_MEI*) do (rd &#x2F;s &#x2F;q &quot;%i&quot;)&gt;nul&#39;)\n                    ClearTemp()\n                    exit(&quot;正在退出程序...&quot;)\n                else:\n                    print(&#39;输入有误或者已经退出!&#39;)\n                    os.system(&#39;pause&#39;)\n                    print(&quot;——————————————————————————————————————————&quot;)\n    \n            # elif key &#x3D;&#x3D; &#39;3&#39;:\n            #     count &#x3D; 0\n            #     while True:\n            #         count +&#x3D; 1\n            #         print(&quot;正在执行第&quot;, count, &quot;次&quot;, &quot;命令&quot;)\n            #         print(&quot;&quot;)\n            #         mainWork(sheet1)\n            #         time.sleep(0.1)\n            #         print(&quot;等待0.1秒&quot;)\n            #         print(&quot;&quot;)\n            #         print(&quot;已经完成第&quot;, count, &quot;次&quot;, &quot;命令&quot;)\n            #         print(&quot;——————————————————分割线——————————————————&quot;)\n            #         print(&quot;&quot;)\n    \n            elif key &#x3D;&#x3D; &#39;0&#39;:\n                print(&quot;正清理缓存文件...&quot;)\n                # os.system(&#39;@echo off &amp; for &#x2F;d %i in (%temp%\\^_MEI*) do (rd &#x2F;s &#x2F;q &quot;%i&quot;)&gt;nul&#39;)\n                ClearTemp()\n                exit(&quot;正在退出程序...&quot;)\n    \n            elif key &#x3D;&#x3D; &#39;c&#39;:\n                os.system(&#39;cls&#39;)\n    \n            else:\n                print(&#39;输入有误或者已经退出!&#39;)\n                os.system(&#39;pause&#39;)\n                print(&quot;——————————————————————————————————————————&quot;)\n\n大致的操作说明\\1.   双击exe文件执行开始时请输入表名称；按照提示输入后回车即可；在cmd.xls 的每个sheet中，一个sheet对应一个自动化流程，自己新建命名即可配置每一步的指令，如：\n\\2.   指令类型1、2、3是操作鼠标单击、双击、右击，对应的内容在第二列填 截图文件路径（例如“./pic/chrome.png”；这里最前面有个点别忘了），把每一步要操作的图标、区域截图保存至pics文件夹图片为png格式，截图名称必须为英文，中文不行。（注意：如果同屏有多个相同图标，会默认找到最左上的一个，因此怎么截图，截多大的区域，是个学问，如输入框只截中间空白部分肯定是不行的，宗旨就是“唯一”）\n\\3.   指令5是等待时长（单位秒） ，建议每配置一步都加上一定等待时间，否则可能会容易卡顿；\n\\4.   指令6是滚轮的距离，正数表示向上滚，负数表示向下滚，滚动距离不确定的话可自己进行测试，可从50或100开始；\n\\5.   指令4是输入，实际实现逻辑为复制粘贴，会占用粘贴板资源。\n\\6.   指令7是热键，第二列将需要的组合的热键以英文半角逗号（”,”）分隔填写即可。例如：win,r,ctrl,shift,esc,1,2,3,4,del（del删除这类热键要慎用）\n当然单个的按键也是可以，单个按键时后面必须加”,” (例如：9, 按一下9这个键。)注意：英文中的逗号”,”无法作为热键被单独被识别，原因是这个符号被用来分隔其他按键组合了。\n\\7.   第三列，重复次数；不填写则默认为执行1次，填写的话只能填写正整数，-1为无限循环；目前重复次数仅支持 第一列为 1,2,3,7 的指令（分别为：鼠标单击，双击，右键，热键组合。）但不建议填-1可能会卡死喔。\n\\8.   第四列，失败重试次数（正整数，否则默认重试10次）\n\\9.   第五列，重试间隔（秒，默认间隔0.1秒）\n\\10. 第六列，失败后是否跳过（为1将跳过，其他或不填将中断；仅对指令1/2/3生效）\n\\11. 指令8是本机时间粘贴，获取当前系统时间。此指令也会使用粘贴板，实际为复制粘贴。第一列填写8，第二列填写“当前时间”（一定要填写，否者不执行），第三列重复次数无效。\n\\12. 指令9是执行系统指令，第二列填写系统指令，第三列重复次数无效。\n例如：start c:（在新窗口中打开C盘）；start cmd （打开CMD程序）\n\\13. 开始程序后请将程序框最小化，不然程序框挡住的区域是无法识别和操作的。\n\\14. 双击exe文件打开程序（目前只能win10/11使用，如果win7使用报错：需要安装kb2533623补丁，这里不提供。），根据提示输入相关指令后敲回车；如果不能运行或者开始后立马关闭；说明流程有问题，可检查cmd表格文件中的数据是否有错；一般都是图片路径填写错误，指令数据填写错误这类问题；如果实在无法解决那就关掉吧~\n\\15. 执行开始时或完毕后都会有退出选项；尽量使用这个选项（输入0之后回车）退出程序，（可以避免出现exe执行文件会产生临时文件，长久累积可能会占满C盘（这是python可执行文件的一个特性））；如果程序开始后因为你选择了多次重复而键鼠被占用但是想要停下来，关闭Dos控制台即可。点击右上角的x 或者ctrl+c或者alt+F4 都可以。\n代码参考B站大佬（不高兴就喝水）的源码 进行二次开发，加入查找失败重试，超时查找，快捷键组合，dos命令，实时日志记录等功能；（有些自动化操作受windows系统安全限制可能会失效，这里不一一列举了）一直想做个图形化界面客户端，还有些地方没有打通。。。\nhttps://www.bilibili.com/video/BV1T34y1o73U?spm_id_from=333.999.0.0\n","slug":"python实现鼠标键盘自动化","date":"2022-05-29T15:15:09.000Z","categories_index":"python","tags_index":"自动化","author_index":"弦好想断"},{"id":"74df2b30e38d008e4f87b397961dd215","title":"Python数据分析 :pandas数据读取、预处理、筛选、计算，时间序列、透视、拼接、导出","content":"一、Pandas数据结构S1&#x3D;pd.Series([‘a’,’b’,’c’]) series是一组数据与一组索引（行索引）组成的数据结构\nS1&#x3D;pd.Series([‘a’,’b’,’c’],index&#x3D;(1,3,4)) 指定索引\nS1&#x3D;pd.Series(&#123;1:‘a’,2:’b’,3:’c’&#125;) 用字典形式指定索引\nS1.index() 返回索引\nS1.values() 返回值\nDf&#x3D;pd.DataFrame([‘a’,’b’,’c’]) dataframe是一组数据与两组索引（行列索引）组成的数据结构\nDf&#x3D;pd.DataFrame([[a,A],[b,B],[c,C]],columns&#x3D;[‘小写’,’大写’]，index&#x3D;[‘一’,’二’,’三’])\nColumms 为列索引，index为行索引\npip install -i [https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple](https:&#x2F;&#x2F;link.zhihu.com&#x2F;?target&#x3D;https%3A&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple) pyspider 清华镜像\n\n查找某个包 anaconda search -t conda tensorflow下载某个包 anaconda show packagedata={‘小写’:[‘a’,’b’,’c’],’大写’:[‘A’,’B’,’C’]} 传入字典Df=Pd.DataFrame(data)Df.index() df.columns()\n建立分层索引的dataframe：pd.MultiIndex.from_arrays([[,,]],name=[,,]）\n\n二、读取数据df&#x3D;pd.read_excel(r’C:\\user\\...xlsx’,sheet_name&#x3D;’sheet1’) 或\npd.read_excel(r’C:\\user\\...xlsx’,sheet_name&#x3D;0) 读取excel表\npd.read_excel(r’C:\\user\\...xlsx’,index_col&#x3D;0,header&#x3D;0)\nindex_col指定行索引，header指定列索引\npd.read_excel(r’C:\\user\\...xlsx’,usecols&#x3D;[0,1]) 导入指定列,不能有index_col和header\npd.read_tablel(r’C:\\user\\...txt’，sep&#x3D;’ ’) 导入txt文件,sep指定分隔符是什么\ndf.head(2) 展示前两行，默认展示前5行\ndf.shape 显示数据几行几列，不包含行和列索引\ndf.info()可查看表中数据的类型\ndf.describe() 可获得表中数值类型指端的分布值（和、平均值、方差等）\n\n获取Excel文件下所有的sheet名称# 读取所有Sheet\ndf &#x3D; pd.read_excel(&#39;456.xlsx&#39;, sheet_name&#x3D;None)\n# 第一种\nfor i in df.keys():\n    print(i)\n# 第二种\ndf &#x3D; pd.read_excel(&#39;456.xlsx&#39;, sheet_name&#x3D;None)\nprint(list(df))\n\n三、数据预处理\n多个Series合并成DataFrame：pd.DataFrame(list(zip(series_1, series_2)))\n\npython在字符串前面加0：str(1).zfill(2)\ndf.info() 可显示表中哪个数据为空\ndf.isnull() 方法可以判断哪个值是缺失值，如果缺失返回True，否则为False\ndf.dropna() 默认删除含缺失值的行\ndf.dropna(how&#x3D;’all’) 删除全为空值的行，不全为空值的行不会删除\ndf.fillna(0) 用0填充所有空值\ndf.fillna(&#123;‘性别’:’男’,’年龄’:’30’&#125;) 对性别列中空值填充男，年龄填充30\n通过随机选择非缺失值来填充缺失值foo[‘A’].apply(lambda x: np.random.choice([x for x in range(min(foo[‘A’]),max(foo[‘A’])]) if (np.isnan(x)) else x)\n\n按一列数据填充另一列数据中的缺失值df_real[‘净含量’] = df_real[‘净含量’].fillna(df_real[‘净含量_y’])\n\ndf1.combine_first(df2)：将df2的非缺失值填充df1中的缺失（dataframe根据列名和索引）值；ser1.combine_first(ser2)：用ser2的非缺失值填充ser1中的缺失值（series根据索引）\n\n按指定的字符合并多列：df[‘A’].str.cat([df[‘B’], df[‘C’]], sep=’-‘)\ndf.drop_duplicates(inplace&#x3D;True) 默认对所有值进行重复值检查，保留第一行的值，inplace&#x3D;True表示直接在原来的DataFrame上删除重复项，而默认值False表示生成一个副本。\ndf.drop_duplicates(subset&#x3D;’性别’) 对性别列中重复值查询保留第一行\ndf.drop_duplicates(subset&#x3D;[’性别’,’公司’]，keep&#x3D;’last’) 对性别和公司两列查重\nkeep设置默认为first（保留第一个），可设置为last（保留最后一个） 或False(都不保留)\ndf[‘ID’].dtype 查看ID列的数据类型\ndf[‘ID’].astype(‘float’) 将ID列的数据类型转换为float类型\n数据类型：int、float、object、string、unicode、datetime\ndf[‘ID’][1] ID列的第二个数据\ndf.columns&#x3D;[‘大写’,’小写’,’中文’] 为无索引表添加列索引\ndf.index&#x3D;[1,2,3] 添加行索引\ndf.set_index(‘编号’) 指明要用的列作为行索列\ndf.rename(index&#x3D;&#123;‘订单编号’:’新订单编号’,’客户姓名’:’新客户姓名’&#125;) 对行索引进行重新命名\ndf.rename(columns&#x3D;&#123;1:’一’,2:’二’&#125;) 对列索引进行一次性重新命名所有列名\n如果你需要做的仅仅是将空格换成下划线，那么更好的办法是使用str.replace()方法，这是因为你都不需要输入所有的列名：\ndf.columns &#x3D; df.columns.str.replace(   ,  _ )\ndf.reset_index() 默认将全部index转化为column,\ndf.reset_index(level&#x3D;0) 将0级索引转化为column\ndf.reset_index(drop&#x3D;True) 删除原有索引\n多列合并为一行df = pd.DataFrame({‘id_part’:[‘a’,’b’,’c’,’d’], ‘pred’:[0.1,0.2,0.3,0.4], ‘pred_class’:[‘women’,’man’,’cat’,’dog’], ‘v_id’:[‘d1’,’d2’,’d3’,’d1’]})df.groupby([‘v_id’]).agg({‘pred_class’: [‘, ‘.join],’pred’: lambda x: list(x),’id_part’: ‘first’}).reset_index()\n\n字符串转换为数值df = pd.DataFrame({‘列1’:[‘1.1’,’2.2’,’3.3’],’列2’:[‘4.4’,’5.5’,’6.6’],’列3’:[‘7.7’,’8.8’,’-‘]})df.astype({‘列1’:’float’,’列2’:’float’}).dtypes用这种方式转换第三列会出错，因为这列里包含一个代表 0 的下划线，pandas 无法自动判断这个下划线。为了解决这个问题，可以使用 to_numeric() 函数来处理第三列，让 pandas 把任意无效输入转为 NaN。df = df.apply(pd.to_numeric, errors=’coerce’).fillna(0)\n\n优化 DataFrame 对内存的占用方法一：只读取切实所需的列，使用usecols参数cols = [‘beer_servings’,’continent’]small_drinks = pd.read_csv(‘data/drinks.csv’, usecols=cols)方法二：把包含类别型数据的 object 列转换为 Category 数据类型，通过指定 dtype 参数实现。dtypes ={‘continent’:’category’}smaller_drinks = pd.read_csv(‘data/drinks.csv’,usecols=cols, dtype=dtypes)\n\n把字符串分割为多列df = pd.DataFrame({‘姓名’:[‘张 三’,’李 四’,’王 五’],’所在地’:[‘北京-东城区’,’上海-黄浦区’,’广州-白云区’]})df.姓名.str.split(‘ ‘, expand=True)\n\n把 Series 里的列表转换为 DataFramedf = pd.DataFrame({‘列1’:[‘a’,’b’,’c’],’列2’:[[10,20], [20,30], [30,40]]})df_new = df.列2.apply(pd.Series)pd.concat([df,df_new], axis=’columns’)\n\nDataFrame迭代：iterrows():将DataFrame迭代为(insex, Series)对。iteritems():将DataFrame迭代为(列名, Series)对。itertuples(): 将DataFrame迭代为元组。for row in df.itertuples():  print(row)  print(‘—————-‘)  print(getattr(row,’col1’), getattr(row,’col2’))getattr() 函数用于返回一个对象属性值。\n\n\n四、数据选择\nQuery是pandas的过滤查询函数，使用布尔表达式来查询DataFrame的列，就是说按照列的规则进行过滤操作。pandas.DataFrame.query(self, expr, inplace = False, **kwargs)expr：要评估的查询字符串；inplace=False：查询是应该修改数据还是返回修改后的副本kwargs：dict关键字参数比如要查列value_1&lt;value_2的行记录：df.query(‘value_1 &lt; value_2’)查询列year&gt;=2016的行记录：df.query(‘year &gt;= 2016 ‘)\n\nInsert用于在DataFrame的指定位置中插入新的数据列。默认情况下新列是添加到末尾的，但可以更改位置参数，将新列添加到任何位置。Dataframe.insert(loc, column, value, allow_duplicates=False)loc: int型，表示插入位置在第几列；若在第一列插入数据，则 loc=0column: 给插入的列取名，如 column=’新的一列’value：新列的值，数字、array、series等都可以allow_duplicates: 是否允许列名重复，选择Ture表示允许新的列名与已存在的列名重复在第三列的位置插入新列：df.insert(2, ‘new_col’, new_col)\n\nDataFrame首行插入行\ndf.loc[-1] &#x3D; [10, 20, 30]  # 增加一行\ndf.index &#x3D; df.index + 1  # 把index的每一项增加1\ndf &#x3D; df.sort_index()  #重新排序一下\nCumsum是pandas的累加函数，用来求列的累加值。 用法：DataFrame.cumsum(axis=None, skipna=True, args, kwargs)axis：index或者轴的名字skipna：排除NA/null值df中的group列有A、B、C三组，year列有多个年份。我们只知道当年度的值value_1、value_2，现在求group分组下的累计值，比如A、2014之前的累计值，可以用cumsum函数来实现。当然仅用cumsum函数没办法对groups (A, B, C)进行区分，所以需要结合分组函数groupby分别对(A, B, C)进行值的累加。df[‘cumsum_2’] = df[[‘value_2’,’group’]].groupby(‘group’).cumsum()\n\nSample用于从DataFrame中随机选取若干个行或列。 用法：DataFrame.sample(n=None, frac=None, replace=False, weights=None, random_state=None, axis=None)n：要抽取的行数frac：抽取行的比例 例如frac=0.8，就是抽取其中80%replace：是否为有放回抽样， True:有放回抽样 False:未放回抽样weights：字符索引或概率数组random_state ：随机数发生器种子axis：选择抽取数据的行还是列 axis=0:抽取行 axis=1:抽取列从df中随机抽取5行：df.sample(n=5)从df随机抽取60%的行，并且设置随机数种子，每次能抽取到一样的样本：df.sample(frac=0.6,random_state=2)\n\nWhere用来根据条件替换行或列中的值。如果满足条件，保持原来的值，不满足条件则替换为其他值。默认替换为NaN，也可以指定特殊值。DataFrame.where(cond, other=nan, inplace=False, axis=None, level=None, errors=’raise’, try_cast=False, raise_on_error=None)cond：布尔条件，如果 cond 为真，保持原来的值，否则替换为otherother：替换的特殊值inplace：inplace为真则在原数据上操作，为False则在原数据的copy上操作axis：行或列将df中列value_1里小于5的值替换为0：df[‘value_1’].where(df[‘value_1’] &gt; 5 , 0)\n\n得到DataFrame中重复的数据\ndata&#x3D;&#123;&#39;one&#39;:[1,1,2,2,1,2,2],&#39;two&#39;:[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;]&#125;\nframe&#x3D;pd.DataFrame(data)\nprint(&quot;原始数据&quot;)\nprint(frame)\ndata1 &#x3D; frame.drop_duplicates(subset&#x3D;[&#39;two&#39;],keep&#x3D;&#39;first&#39;)\nprint(&quot;去重后的数据&quot;)\nprint(data1)\na &#x3D; frame.drop_duplicates(subset&#x3D;[&#39;two&#39;],keep&#x3D;&#39;last&#39;)\nb &#x3D; frame.drop_duplicates(subset&#x3D;[&#39;two&#39;],keep&#x3D;False)\nc&#x3D;a.append(b).drop_duplicates(subset&#x3D;[&#39;two&#39;],keep&#x3D;False)\nprint(&quot;重复的数据&quot;)\nprint(c)\n索引切片\ndf[[‘ID’,’姓名’]] 多个列名要装入list\ndf.iloc[[1,3],[2,4]] 用行列编号选择数据\ndf.iloc[1,1] 选取表中的第3行2列数据，第一行默认为列索引\ndf.iloc[:,0:4] #获取第1列到第4列的值\ndf.loc[‘一’] #loc用行名选取的行数据，格式是Series，但可以用列表形式访问\ndf.loc[‘一’][0] 或 df.loc[‘一’][‘序号’]\ndf.iloc[1]#iloc用行编号选取行数据\ndf.iloc[[1,3]]#多行编号选取行数据，要用list封装，不然变成行列选取\ndf.iloc[1:3]#选择第二行和第四行\ndf[df[‘年龄’]&lt;45] #加判断条件返回符合条件的全部数据，不局限年龄列\ndf[(df[‘年龄’]&lt;45)&amp;(df[‘ID’]&lt;4)] #判断多条件选择数据\ndf.iloc[[1,3],[2,4]] 相当于df.loc[[‘一’,’二’],[‘年龄’,’ID’]] #loc是名，iloc是编号\ndf[df[‘年龄’]&lt;45][[‘年龄’,’ID’]]#先通过年龄条件选择行，再通过不同索引指定列\ndf.iloc[1:3,2:4]#切片索引\npandas 筛选时间日期数据\n这里筛选2020年5月的数据为例：首先将日期格式化：\ndata[&#39;日期&#39;]&#x3D;data[&quot;日期&quot;].values.astype(&#39;datetime64&#39;)  #如果已为日期格式则此步骤可省略\nimport datetime\ns_date &#x3D; datetime.datetime.strptime(&#39;2020-04-30&#39;, &#39;%Y-%m-%d&#39;).date()  #起始日期\ne_date &#x3D; datetime.datetime.strptime(&#39;2020-06-01&#39;, &#39;%Y-%m-%d&#39;).date()  #结束日期\n第一种方法，用逻辑运算符号’&gt;’ ‘&lt;’和’&amp;’：\nPandasdatetime64[ns]不能直接与datetime.date相比，需要用pd.Timestamp进行转化\ndata[(data.日期&gt;pd.Timestamp(s_date))&amp;(data.日期&lt;pd.Timestamp(e_date))]\n第二种，用比较函数’gt’’lt’和’&amp;’:\ndata[(data[&#39;日期&#39;].lt(pd.Timestamp(e_date)))&amp;(data[&#39;日期&#39;].gt(pd.Timestamp(s_date)))]\n第三种，用apply函数实现:\nid_a&#x3D;data.日期.apply(lambda x: x.year &#x3D;&#x3D;2020  and x.month&#x3D;&#x3D;5)\ndata[id_a]\n第四种，用between函数实现:\nid_b&#x3D;data.日期.between(pd.Timestamp(s_date),pd.Timestamp(e_date))\ndata[id_b]\n行序、列序反转 ：行序反转最直接的办法是使用loc函数并传递::-1，跟Python中列表反转时使用的切片符号一致df.loc[::-1].reset_index(drop=True)列序反转就比较容易了，只需要如下操作：df.loc[:, ::-1]\n\n分组里最大值所在的行方法分为分组中有重复值和无重复值两种。无重复值的情况。df = pd.DataFrame({‘Sp’:[‘a’,’b’,’c’,’d’,’e’,’f’], ‘Mt’:[‘s1’, ‘s1’, ‘s2’,’s2’,’s2’,’s3’], ‘Value’:[1,2,3,4,5,6], ‘Count’:[3,2,5,10,10,6]})df.iloc[df.groupby([‘Mt’]).apply(lambda x: x[‘Count’].idxmax())]先按Mt列进行分组，然后对分组之后的数据框使用idxmax函数取出Count最大值所在的列，再用iloc位置索引将行取出。有重复值的情况df[“rank”] = df.groupby(“ID”)[“score”].rank(method=”min”, ascending=False).astype(np.int64)df[df[“rank”] == 1][[“ID”, “class”]]对ID进行分组之后再对分数应用rank函数，分数相同的情况会赋予相同的排名，然后取出排名为1的数据。\n\n选择特定类型的列drinks = pd.read_csv(‘data/drinks.csv’)选择所有数值型的列drinks.select_dtypes(include=[‘number’]).head()选择所有字符型的列drinks.select_dtypes(include=[‘object’]).head()drinks.select_dtypes(include=[‘number’,’object’,’category’,’datetime’]).head()用 exclude 关键字排除指定的数据类型drinks.select_dtypes(exclude=[‘number’]).head()\n\n根据最大的类别筛选 DataFramemovies = pd.read_csv(‘data/imdb_1000.csv’)counts = movies.genre.value_counts()movies[movies.genre.isin(counts.nlargest(3).index)].head()\n\n基于字符串的长度来筛选数据df[df.col1.str.len() &gt; 20].head()\n\n标注重点df_new.style.highlight_max(axis = 0, color = “yellow”)\n\n\n五、数值操作df[‘年龄’].replace(100,33)#对年龄列中的100替换成33\ndf.replace(np.NaN,0)#相当于fillna(),其中np.NaN是python中缺省值的表示方式\ndf.replace([A,B],C)#多对一替换，A、B替换成C\ndf.replace(&#123;‘A’:’a’,‘B’:’b’,‘C’:’c’&#125;)#多对多替换\ndf.sort_values(by&#x3D;[&#39;申请单编号&#39;],ascending&#x3D;False)#申请单编号列降序排列，Ture升序排列（默认）\ndf.sort_values(by&#x3D;[&#39;申请单编号&#39;],na_position&#x3D;’first’)#申请单编号列升序排列，缺失值排在第一位\n默认缺失值在最后一位last\ndf &#x3D; pd.DataFrame([[&#39;A&#39;,1],[&#39;A&#39;,3],[&#39;A&#39;,2],[&#39;B&#39;,5],[&#39;B&#39;,9]], columns &#x3D; [&#39;name&#39;,&#39;score&#39;])\ndf.sort_values([&#39;name&#39;,&#39;score&#39;], ascending &#x3D; [True,False])#多列排序\ndf.groupby(&#39;name&#39;).apply(lambda x: x.sort_values(&#39;score&#39;,ascending&#x3D;False)).reset_index(drop&#x3D;True)\n\nPct_change是一个统计函数，用于表示当前元素与前面元素的相差百分比，两元素的区间可以调整。比如说给定三个元素[2,3,6]，计算相差百分比后得到[NaN, 0.5, 1.0]，从第一个元素到第二个元素增加50％，从第二个元素到第三个元素增加100％。DataFrame.pct_change(periods=1, fill_method=‘pad’, limit=None, freq=None, **kwargs)periods：间隔区间，即步长fill_method：处理空值的方法对df的value_1列进行增长率的计算：df.value_1.pct_change()\n\n\n pandas 进行组内排序、单组排序、标号df[‘销量’].rank(method&#x3D;’first’)#销量排名（不是排序），method有first\\min\\max\\average\n组内进行排序(按user_id分组后对product_id排序)\ndata1[&#39;group_sort&#39;]&#x3D;data1[&#39;product_id&#39;].groupby(data1[&#39;user_id&#39;]).rank(ascending&#x3D;1,method&#x3D;&#39;first&#39;)\n\ndf.drop([‘销量’,’ID’],axis&#x3D;1)#删除列,直接是列名,inpace&#x3D;True是保留修改哦\ndf.drop(df.columns[[4,5]],axis&#x3D;1)#删除列,是编号\ndf.drop(colums&#x3D;[‘销量’,’ID’])#此种方式删除列，可以不写axis&#x3D;1\ndf.drop([‘a’,’b’],axis&#x3D;0)#删除行,直接是列名\ndf.drop(df.index[[4,5]],axis&#x3D;0)#删除行,是编号\ndf.drop(index&#x3D;[‘a’,’b’])#此种方式删除行，可以不写axis&#x3D;0\ndf[‘ID’].value_counts()#对ID列中数据出现的次数进行统计\ndf[‘ID’].value_counts(normalize&#x3D;Ture,sort&#x3D;False)#对ID列中数据出现的次数占比进行统计，并降序排序\ndf[‘ID’].unique()#获取列的唯一值\ndf[‘年龄’].isin([‘a’,11])#查看这列中是否包含a或11\npd.cut(df[‘ID’],bins&#x3D;[0,3,6,10])#用bins指明切分区间\npd.qcut(df[‘ID’],3)#ID列切分成3个部分，每部分数据个数尽量一致\ndf.insert(2,’商品’,[‘书’,’笔’,’计算器’])#插入第三列\ndf[’商品’]&#x3D;[‘书’,’笔’,’计算器’])#插新列，在表的最后面\ndf.T行列互换\ndf.tack()#把表格型数据转化成树形数据\ndf.set_index([‘ID’,’姓名’]).stack().reset_index()#宽表转换成长表，先将共同列设置成行索引，再对其他列\n进行转化成树形数据，再重置行索引\n\n堆叠：pd.DataFrame.stack(self, level=-1, dropna=True)，level默认为-1是将最内层col堆叠为索引的最内层，为0是将最外层col堆叠为索引的最内层，从最外层开始依次的level值为0，1，2…的顺序来指定对应col。当然直接指定索引名称或许是更好的选择。\n\n反堆叠、拆堆：pd.DataFrame.unstack(self, level=-1, fill_value=None)，默认将最内层的索引拆堆到列的最内层，其他同理stack()；\n\ndf.melt(id_vars=[‘ID’,’姓名’],var_name=’year’,value_name=’sale’)id_var参数指明宽表转换成长表时保持不变的列，var_name参数表示原来的列索引转化为行索引对应的列名，value_name表示新索引对应值的列名df[‘C1’].apply(lambda x:x+1)#相当于map(),只是需要和lambda配合df.applymap(lambda x:x+1),对表中的所有数据执行相同函数运算\n\napply搭配匿名函数lambda的神奇用法：df[‘数据3’] = df.apply(lambda x:(x.数据1-x.数据2)/x.上月 if x.col3!=0 else 0 ,axis=1)\n\n删除包含特定字符串所在的行：df[‘b’].values.astype(‘str’) 先转为字符串格式最好；df[df[‘b’].str.contains(‘exp’,na=False)]\n\n计算变量缺失率\ndef missing_cal(df):\n    &quot;&quot;&quot;\n    df :数据集\n    return：每个变量的缺失率\n    &quot;&quot;&quot;\n    missing_series &#x3D; df.isnull().sum()&#x2F;df.shape[0]\n    missing_df &#x3D; pd.DataFrame(missing_series).reset_index()\n    missing_df &#x3D; missing_df.rename(columns&#x3D;&#123;&#39;index&#39;:&#39;col&#39;,\n    0:&#39;missing_pct&#39;&#125;)\n    missing_df &#x3D; \tmissing_df.sort_values(&#39;missing_pct&#39;,ascending&#x3D;False).reset_index(drop&#x3D;True)\n    return missing_df\nmissing_cal(df)\n如果需要计算样本的缺失率分布，只要加上参数axis&#x3D;1。\n六、数据运算df[‘ID’]+Df[‘ID’]#可进行加减乘除\ndf[‘ID’]&gt;Df[‘ID’]#可进行&gt; &lt; &#x3D;&#x3D; !&#x3D;等比较运算\ndf.nunique()#统计每列不重复值的个数\ndf.count()#统计每列的非空值的个数\ndf.count(axis&#x3D;1)#统计每行的非空值的个数\ndf[‘ID’].count()#统计指定列的非空值的个数\ndf.sum(axis&#x3D;1)#每列&#x2F;行求和结果\ndf.mean(axis&#x3D;1)#每列&#x2F;行求均值\ndf.max(axis&#x3D;1)#每列&#x2F;行求最大值\ndf.min(axis&#x3D;1)#每列&#x2F;行求最小值\ndf.median(axis&#x3D;1)#每列&#x2F;行求中间值\ndf.mode(axis&#x3D;1)#每列&#x2F;行中出现最多的值\ndf.var(axis&#x3D;1)#每列&#x2F;行求方差\ndf.std(axis&#x3D;1)#每列&#x2F;行求标准差\ndf.quantile(0.25)#求1&#x2F;4分位数，可以0.5、0.75等分位数\ndf.corr()#求整个DataFrame表中的相关性\n七、时间序列from datetime import datetime\ndatatime.now()#返回现在的时间年月日时分秒\ndatatime.now().year#返回年，可以.month\\.day\ndatatime.now().weekday()-1#返回周几\ndatatime.now().isocalendar()#返回周数\n（2018，41，7）#2018年的第41周第7天\ndatatime.now().date()#只返回年月日\ndatatime.now().time()#只返回时间\ndatatime.now().strftime(‘%Y-%m-%d %H:%M:%S’)#返回2020-03-13 09:09:12\npd.to_datetime([&#39;201221&#39;],format &#x3D; &quot;%Y%m%d&quot;)#返回DatetimeIndex([&#39;2012-02-01&#39;], dtype&#x3D;&#39;datetime64[ns]&#39;, freq&#x3D;None)\npd.to_datetime(&#39;201221&#39;,format &#x3D; &quot;%Y%m%d&quot;)#不加列表，返回Timestamp(&#39;2012-02-01 00:00:00&#39;)，需要省去时分秒可以在后面加.strftime(&quot;%Y-%m-%d&quot;)\nfrom dateutil.parser import parse\nparse(str_time)#将字符串的时间转化成为时间格式\npd.Datetimeindex([‘2020-02-03’,2020-03-05’])#设置时间索引\ndata[‘2018’]#获取2018年的数据\ndata[‘2018-01’]#获取2018年1月的数据\ndata[‘2018-01-05’:‘2018-01-15’]#获取这个时段的数据\n非时间索引的表格处理\ndf[df[‘成交时间’]&#x3D;&#x3D;datetime(2018,08,05)]\ndf[df[‘成交时间’]&gt;datetime(2018,08,05)]\ndf[(df[‘成交时间’]&gt;datetime(2018,08,05))&amp;(df[‘成交时间’] &lt;datetime(2018,08,15))]\ncha&#x3D;datatime(2018,5,21,19,50)-datatime(2018,5,18,17,50)\ncha.days#返回天的时间差\ncha.seconds#返回秒的时间差\ncha.seconds&#x2F;3600#返回小时的时间差\ndatatime(2018,5,21,19,50)+timedelta(days&#x3D;1)#往后移一天\ndatatime(2018,5,21,19,50)+timedelta(seconds&#x3D;20)#往后移20秒\ndatatime(2018,5,21,19,50)-timedelta(days&#x3D;1)#往前移一天\n日期时间类型接口一览表\ndf &#x3D; generate_sample_data_datetime().reset_index()\ndf &#x3D; df.sample(500)\ndf[&quot;Year&quot;] &#x3D; df[&quot;index&quot;].dt.year\ndf[&quot;Month&quot;] &#x3D; df[&quot;index&quot;].dt.month\ndf[&quot;Day&quot;] &#x3D; df[&quot;index&quot;].dt.day\ndf[&quot;Hour&quot;] &#x3D; df[&quot;index&quot;].dt.hour\ndf[&quot;Minute&quot;] &#x3D; df[&quot;index&quot;].dt.minute\ndf[&quot;Second&quot;] &#x3D; df[&quot;index&quot;].dt.second\ndf[&quot;Nanosecond&quot;] &#x3D; df[&quot;index&quot;].dt.nanosecond\ndf[&quot;Date&quot;] &#x3D; df[&quot;index&quot;].dt.date\ndf[&quot;Time&quot;] &#x3D; df[&quot;index&quot;].dt.time\ndf[&quot;Time_Time_Zone&quot;] &#x3D; df[&quot;index&quot;].dt.timetz\ndf[&quot;Day_Of_Year&quot;] &#x3D; df[&quot;index&quot;].dt.dayofyear\ndf[&quot;Week_Of_Year&quot;] &#x3D; df[&quot;index&quot;].dt.weekofyear\ndf[&quot;Week&quot;] &#x3D; df[&quot;index&quot;].dt.week\ndf[&quot;Day_Of_week&quot;] &#x3D; df[&quot;index&quot;].dt.dayofweek\ndf[&quot;Week_Day&quot;] &#x3D; df[&quot;index&quot;].dt.weekday\ndf[&quot;Week_Day_Name&quot;] &#x3D; df[&quot;index&quot;].dt.weekday_name\ndf[&quot;Quarter&quot;] &#x3D; df[&quot;index&quot;].dt.quarter\ndf[&quot;Days_In_Month&quot;] &#x3D; df[&quot;index&quot;].dt.days_in_month\ndf[&quot;Is_Month_Start&quot;] &#x3D; df[&quot;index&quot;].dt.is_month_start\ndf[&quot;Is_Month_End&quot;] &#x3D; df[&quot;index&quot;].dt.is_month_end\ndf[&quot;Is_Quarter_Start&quot;] &#x3D; df[&quot;index&quot;].dt.is_quarter_start\ndf[&quot;Is_Quarter_End&quot;] &#x3D; df[&quot;index&quot;].dt.is_quarter_end\ndf[&quot;Is_Leap_Year&quot;] &#x3D; df[&quot;index&quot;].dt.is_leap_year\n八、数据透视表df.groupby(‘客户分类’).count()#客户分类后求数运算\ndf.groupby(‘客户分类’).sum()#客户分类后求和运算\ndf.groupby(‘客户分类’,’区域分类’).sum()#多列分类后求和运算\ndf.groupby(‘客户分类’,’区域分类’)[‘ID’].sum()#多列分类后ID求和运算\ndf[‘ID’]#DataFrame取出一列就是Series类型\ndf.groupby(df[‘ID’]).sum() 相当于 df.groupby(‘ID’).sum（）\ndf.groupby(‘客户分类’).aggregate([‘sum’,’count’]# aggregate可实现多种汇总方式\ndf.groupby(‘客户分类’).aggregate(&#123;‘ID’：‘count’,’销量’： ‘sum’&#125;)\n用多个函数聚合df.groupby(‘order_id’).item_price.agg([‘sum’,’count’]).head()\n\naggregate可针对不同列做不同的汇总运算df.groupby(‘客户分类’).sum().reset_index()#分组汇总后再重置索引，变为标准DataFramepd.pivot_table(data,values,index,columms,aggfunc,fill_value,margins,dropna,margins_name)数据透视表，data:数据表df,values:值，index:行索引，columns:列索引，aggfunc:values的计算类型，fill_value:对空值的填充方式；margins:是否有合计列；margins_name:合计列的列名pd.pivot_table(df,values=[’ID’,‘销量’],index=’客户分类’,columms=‘区域’,aggfunc={‘ID’：‘count’,’销量’：‘sum’}),fill_value=0,margins=Ture,dropna=None,margins_name=’总计’)\n\n分组聚合 dict(list(df.groupby(‘key1’)))通过字典或Series进行分组people = pd.DataFrame(np.random.randn(5, 5),columns=[‘a’, ‘b’, ‘c’, ‘d’, ‘e’],index=[‘Joe’, ‘Steve’, ‘Wes’, ‘Jim’, ‘Travis’])mapping = {‘a’:’red’, ‘b’:’red’, ‘c’:’blue’, ‘d’:’blue’, ‘e’:’red’, ‘f’:’orange’}by_column = people.groupby(mapping, axis=1)by_column.sum()\n\n\n九、多表格拼接pd.merge(df1,df2)#默认自动寻找两个表中的公共列进行拼接\npd.merge(df1,df2,on&#x3D;“学号“)#on来指定连接列，连接列要是公共列\npd.merge(df1,df2,on&#x3D;[‘学号’,’姓名’]#on来指定连接列，连接列要是公共列\npd.merge(df1,df2,left_on&#x3D;‘学号’right_on&#x3D;’编号’) #由公共列，但类名不同时用左右键指定 \npd.merge(df1,df2,left_index&#x3D;‘学号’right_index&#x3D;’编号’)#两表公共列都是索引列时\npd.merge(df1,df2,left_index&#x3D;‘学号’right_on&#x3D;’编号’)#公共列一个时索引列一个时普通列 \npd.merge(df1,df2,on&#x3D;’学号’,how&#x3D;’inner’)#返回公共列中对应的公共值拼接（内连接）\npd.merge(df1,df2,on&#x3D;’学号’,how&#x3D;’left’)#返回公共列中对应的左表值（左连接）\npd.merge(df1,df2,on&#x3D;’学号’,how&#x3D;’right’)#返回公共列中对应的右表值（右连接）\npd.merge(df1,df2,on&#x3D;’学号’,how&#x3D;’outer’)#返回公共列中对应的所有值（外连接）\npd.concat([df1,df2])#两个结构相同的表纵向连接，保留原索引值\npd.concat([df1,df2]，ignore_index&#x3D;True)#两个结构相同的表纵向连接，重新设置索引值\npd.concat([df1,df2]，ignore_index&#x3D;True).drop_duplicates()#拼接后去掉重复值\n\n十、导出文件df.to_excel(excel_writer=r’C:\\users\\zhoulifu\\Desktop\\测试.xlsx’,sheet_name=’文档’，index=False,columns=[‘ID’,’销量’,‘姓名’],encoding=’utf-8’,na_rep=0)\n\nexcel_writer参数指定文件路径，导出时去掉索引，设置导出的列，指定文件编码，na_rep缺失值填充writer=pd.ExcelWriter(excelpath,engine=’xlsxwirter’)导出多个文件至一个文件的多个sheet；\n方法1：from shutil import copyfile\n\ntemplate &#x3D; r&quot;test.xlsx&quot;\nout_xl &#x3D; r&quot;out.xlsx&quot;\ncopyfile(template, out_xl)\n\nwith pd.ExcelWriter(out_xl,engine&#x3D;&#39;openpyxl&#39;,mode&#x3D;&#39;a&#39;,if_sheet_exists&#x3D;&#39;replace&#39;) as writer:\n    #用openpyxl不会删除excel表中原有sheet，更保险！文件已存在需要替换掉就加if_sheet_exists&#x3D;&#39;replace&#39;，表名已存在的话就替换，不存在是新增的话，不要加这个参数，否则会报错\n    df1.to_excel(writer,sheet_name&#x3D;&#39;表一&#39;,index&#x3D; False)\n#writer.save()\n#writer.close()\n方法2：这种方式不会报数据错误df &#x3D; pd.read_excel(path,sheet_name&#x3D;&#39;test3&#39;)\n#写入到原Excel表中避免清空其他数据\nbook &#x3D; openpyxl.load_workbook(path)   #读取你要写入的workbook\n#和pd.read_excel() 用于将Dataframe写入excel。xls用xlwt。xlsx用openpyxl\nwith pd.ExcelWriter(path,engine&#x3D;&#39;openpyxl&#39;) as writer:\n    ##此时的writer里还只是读写器. 然后将上面读取的book复制给writer\n    writer.book &#x3D; book\n    #转化为字典的形式\n    writer.sheets &#x3D; dict((ws.title, ws) for ws in book.worksheets)#返回一个字典，sheet名和sheet对象组成的键值对\n    #将data写入writer，这里有时候需要对多个变量实现循环写入,可以使用for循环+eval()\n    df.to_excel(writer,sheet_name&#x3D;&quot;测试&quot;,index&#x3D;False)\n#writer.save()\n#writer.close()\nto_jsondata &#x3D; df([[&#39;a&#39;, &#39;b&#39;], [&#39;c&#39;, &#39;d&#39;]], index&#x3D;[&#39;row 1&#39;, &#39;row 2&#39;], columns&#x3D;[&#39;col 1&#39;, &#39;col 2&#39;])\njson_columns &#x3D; data.to_json(orient &#x3D; &quot;columns&quot;) # 返回结果：\n &#39;&#123;&quot;col 1&quot;:&#123;&quot;row 1&quot;:&quot;a&quot;,&quot;row 2&quot;:&quot;c&quot;&#125;,&quot;col 2&quot;:&#123;&quot;row 1&quot;:&quot;b&quot;,&quot;row 2&quot;:&quot;d&quot;&#125;&#125;&#39;\njson_split &#x3D; data.to_json(orient &#x3D; &quot;split&quot;)  # 返回结果：\n &#39;&#123;&quot;columns&quot;:[&quot;col 1&quot;,&quot;col 2&quot;],&quot;index&quot;:[&quot;row 1&quot;,&quot;row 2&quot;],&quot;data&quot;:[[&quot;a&quot;,&quot;b&quot;],[&quot;c&quot;,&quot;d&quot;]]&#125;&#39;\njson_records &#x3D; data.to_json(orient &#x3D; &quot;records&quot;)  # 返回结果：\n &#39;[&#123;&quot;col 1&quot;:&quot;a&quot;,&quot;col 2&quot;:&quot;b&quot;&#125;,&#123;&quot;col 1&quot;:&quot;c&quot;,&quot;col 2&quot;:&quot;d&quot;&#125;]&#39;\njson_index &#x3D; data.to_json(orient &#x3D; &quot;index&quot;)  # 返回结果：\n&#39;&#123;&quot;row 1&quot;:&#123;&quot;col 1&quot;:&quot;a&quot;,&quot;col 2&quot;:&quot;b&quot;&#125;,&quot;row 2&quot;:&#123;&quot;col 1&quot;:&quot;c&quot;,&quot;col 2&quot;:&quot;d&quot;&#125;&#125;&#39;\njson_values &#x3D; data.to_json(orient &#x3D; &quot;values&quot;)  # 返回结果： \n&#39;[[&quot;a&quot;,&quot;b&quot;],[&quot;c&quot;,&quot;d&quot;]]&#39;\n• format()函数，与lambda函数配合，可以设置：四舍五入保留小数位、转化为百分数、添加千位分隔符等保留1位小数：df[“A”].map(lambda x: format(x, ‘.1f’))设置百分数，并保留2位小数：df[“A”].map(lambda x: format(x, ‘.2%’))设置千位分隔，并保留3位小数：df[“A”].map(lambda x: format(x, ‘,.3f’))\n\n","slug":"Python数据分析：pandas数据读取、预处理、筛选、计算，时间序列、透视、拼接、导出","date":"2021-10-04T06:02:22.000Z","categories_index":"python","tags_index":"数据分析","author_index":"弦好想断"},{"id":"d36edaa00a28ef96e171ed217c165e70","title":"python-flask疫情数据可视化","content":"Flask是一个轻量级的web框架，看了https://www.bilibili.com/video/BV177411j7qJ 大佬的视频，做的一个疫情可视化项目,（电脑屏幕小看着有点拥挤。大屏展示还是挺好看的），热搜词云的数据找不到网站了，就弄了个表格；自己修改了一些部分，感兴趣的可以去康康视频，后续有时间再写点总结。\n\nflask 前端部分from flask import Flask,request,render_template,jsonify\nimport time\nimport utils\nimport pandas as pd\nfrom yiqin_data import update_history,update_details\nfrom selenium import webdriver\nimport threading\nimport webbrowser\n\n\napp &#x3D; Flask(__name__)\n\n@app.route(&#39;&#x2F;&#39;)\ndef index():\n    task  &#x3D; pd.DataFrame(utils.get_r2_data(),columns &#x3D;[&#39;省份&#39;,&#39;现存&#39;,&#39;累计&#39;,&#39;相比上日&#39;,&#39;治愈占比&#39;,&#39;死亡占比&#39;])\n    task[&#39;治愈占比&#39;] &#x3D; task[&#39;治愈占比&#39;].map(lambda x: format(x, &#39;.2%&#39;))\n    task[&#39;死亡占比&#39;] &#x3D; task[&#39;死亡占比&#39;].map(lambda x: format(x, &#39;.2%&#39;))\n    task &#x3D; task.to_html(index&#x3D;False,border&#x3D;0,max_cols&#x3D;8, max_rows&#x3D;7)\n    return render_template(&quot;main.html&quot;, task&#x3D; task)\n\n@app.route(&#39;&#x2F;time&#39;)\ndef gettime():\n    time_str &#x3D; time.strftime(&quot;%Y&#123;&#125;%m&#123;&#125;%d&#123;&#125; %X&quot;)\n    return time_str.format(&quot;年&quot;, &quot;月&quot;, &quot;日&quot;)\n\n@app.route(&#39;&#x2F;c1&#39;, methods&#x3D;[&#39;get&#39;,&#39;post&#39;])\ndef get_c1_data():\n    data &#x3D; utils.get_c1_data()\n    return jsonify(&#123;&quot;cumulative&quot;: str(data[1]),&quot;current&quot;: str(data[2]), &quot;overseas&quot;: str(data[3]), &quot;death&quot;: str(data[4]),\n                    &#39;新增确诊&#39;: str(data[5]), &#39;新增治愈&#39;: str(data[6]), &#39;新增境外&#39;: str(data[7]),&#39;新增死亡&#39;: str(data[8])&#125;)\n\n@app.route(&quot;&#x2F;c2&quot;, methods&#x3D;[&#39;get&#39;,&#39;post&#39;])\ndef get_c2_data():\n    res &#x3D; []\n    for tup in utils.get_c2_data():\n        res.append(&#123;&#39;name&#39;: tup[0],&#39;value&#39;: int(tup[1])&#125;)\n    return jsonify(&#123;&#39;data&#39;: res&#125;)\n\n@app.route(&quot;&#x2F;l1&quot;, methods&#x3D;[&#39;get&#39;,&#39;post&#39;])\ndef get_l1_data():\n    data &#x3D; utils.get_l1_data()\n    date, cumulative,current, overseas, death &#x3D; [], [], [], [], []\n    for a, b, c, d, e in data[:]:\n        date.append(pd.to_datetime(a,format &#x3D; &quot;%Y-%m-%d&quot;).strftime(&quot;%m-%d&quot;))\n        cumulative.append(b)\n        current.append(c)\n        overseas.append(d)\n        death.append(e)\n    return jsonify(&#123;&quot;date&quot;: date[-100:], &quot;cumulative&quot;: cumulative[-100:], &quot;current&quot;: current[-100:],\n                    &quot;overseas&quot;: overseas[-100:],&quot;death&quot;: death[-100:]&#125;)\n\n@app.route(&quot;&#x2F;l2&quot;, methods&#x3D;[&#39;get&#39;,&#39;post&#39;])\ndef get_l2_data():\n    data &#x3D; utils.get_l2_data()\n    date, cumulative, current, overseas, death  &#x3D; [], [], [], [], []\n    for a, b, c, d, e in data[:]:\n        date.append(pd.to_datetime(a,format &#x3D; &quot;%Y-%m-%d&quot;).strftime(&quot;%m-%d&quot;))\n        cumulative.append(b)\n        current.append(c)\n        overseas.append(d)\n        death.append(e)\n    return jsonify(&#123;&quot;date&quot;:date[-100:],&quot;cumulative&quot;:cumulative[-100:],&quot;current&quot;:current[-100:],\n                    &quot;overseas&quot;:overseas[-100:],&quot;death&quot;:death[-100:]&#125;)\n\n@app.route(&quot;&#x2F;r1&quot;, methods&#x3D;[&#39;get&#39;,&#39;post&#39;])\ndef get_r1_data():\n    data &#x3D; utils.get_r1_data()\n    city, confirm &#x3D; [], []\n    for a, b in data:\n        if a !&#x3D; &quot;地区待确认&quot; and  a !&#x3D;&quot;境外输入&quot;:\n            city.append(a)\n            confirm.append(int(b))\n    return jsonify(&#123;&quot;city&quot;:city[0:5],&quot;confirm&quot;:confirm[0:5]&#125;)\n\n\n# @app.route(&quot;&#x2F;r2&quot;, methods&#x3D;[&#39;get&#39;,&#39;post&#39;])\n# def get_r2_data():\n#     data &#x3D; utils.get_r2_data()\n#     d &#x3D; []\n#     for i in data:\n#         k &#x3D; i[0].rstrip(string.digits) # 移除热搜数字,从右边\n#         v &#x3D; i[0][len(k):] # 获取关键字\n#         ks &#x3D; extract_tags(k) # 使用结巴提取关键字\n#         for j in ks:\n#             if not j.isdigit():\n#                 d.append(&#123;&quot;name&quot;:j, &quot;value&quot;:v&#125;)\n#\n#     return jsonify(&#123;&quot;kws&quot;:d&#125;)\n\ndef start_web():\n    try:\n        browser &#x3D; webdriver.Chrome()\n        browser.maximize_window()\n        browser.get(f&#39;http:&#x2F;&#x2F;127.0.0.1:5000&#x2F;&#39;)\n    except Exception as e:\n        print(e)\n        pass\n\ndef start_web2():\n    webbrowser.open(&#39;http:&#x2F;&#x2F;127.0.0.1:5000&#x2F;&#39;)\n\ndef yiqing_run():\n    # app.run(host&#x3D;&#39;0.0.0.0&#39;,port&#x3D;8638)    #debug&#x3D;True,host&#x3D;&#39;0.0.0.0&#39;,port&#x3D;\n    app.run()\n\nif __name__&#x3D;&#x3D;&quot;__main__&quot;:\n    update_history()\n    update_details()\n    try:\n        t1 &#x3D; threading.Thread(target&#x3D;yiqing_run, )\n        t2 &#x3D; threading.Thread(target&#x3D;start_web2, )\n        t1.start()\n        time.sleep(1)\n        t2.start()\n    except Exception as e:\n        print(e)\n\n\nmysql 后台数据部分import time\nimport pymysql\nimport string\n\n\n# 连接数据库\ndef get_conn():\n    conn &#x3D; pymysql.connect(\n        host&#x3D;&quot;localhost&quot;,\n        user&#x3D;&quot;&quot;,\n        password&#x3D;&quot;&quot;,\n        db&#x3D;&quot;supermanzwg&quot;,\n        charset&#x3D;&quot;utf8&quot;,\n        port&#x3D;3306,\n    )\n    # 创建游标：\n    cursor &#x3D; conn.cursor()\n    return conn, cursor\n\ndef close_conn(conn, cursor):\n    if cursor:\n        cursor.close()\n    if conn:\n        conn.close()\n\ndef query(sql, *args):\n    &#39;&#39;&#39;\n    :param sql:\n    :param args:\n    :return:返回结果，((),())形式\n    &#39;&#39;&#39;\n    conn, cursor&#x3D; get_conn()\n    cursor.execute(sql)\n    res &#x3D; cursor.fetchall() # 获取结果\n    close_conn(conn, cursor)\n    return res\n\ndef get_c1_data():\n    sql &#x3D; &quot;&quot;&quot;\n        select a.date,a.cumulative,a.current,a.Overseas,a.death,b.&#96;新增确诊&#96;,b.&#96;新增治愈&#96;,b.&#96;新增境外&#96;,b.&#96;新增死亡&#96; \n        from \n        (select date,cumulative,current,Overseas,death \n        from  &#96;history&#96; \n        order by date desc limit 1) a \n        inner join \n        (SELECT b.date 日期,(b.cumulative-a.cumulative) 新增确诊,\n            -(a.cumulative-a.current-b.cumulative+b.current) 新增治愈,\n            (b.Overseas-a.Overseas) 新增境外,\n            (b.death-a.death) 新增死亡 \n            FROM &#96;history&#96; a, &#96;history&#96; b \n            where a.date &#x3D; DATE_SUB(str_to_date(b.date,&#39;%Y-%m-%d&#39;),interval 1 day)\n            order by 日期 desc limit 1) b\n        where a.date &#x3D; b.&#96;日期&#96;; &quot;&quot;&quot;\n    res &#x3D; query(sql)\n    return res[0]\n\ndef get_c2_data():\n    sql &#x3D; &quot;&quot;&quot;\n    select \n    province,current\n    from &#96;details&#96; \n    order by date  desc limit 34;&quot;&quot;&quot;\n    res &#x3D; query(sql)\n    return res\n\ndef get_l1_data():\n    sql &#x3D; &quot;&quot;&quot;\n    select *\n    from \n    (select date,cumulative,current,Overseas,death \n        from  &#96;history&#96; \n        order by date desc limit 10) a\n\t\torder by a.date asc;&quot;&quot;&quot;\n    res &#x3D; query(sql)\n    return res\n\ndef get_l2_data():\n    sql &#x3D; &quot;&quot;&quot;\n    select *\n    from \n    (SELECT b.date &#96;日期&#96;,(b.cumulative-a.cumulative) 新增确诊,\n        -(a.cumulative-a.current-b.cumulative+b.current) 新增治愈,\n        (b.Overseas-a.Overseas) 新增境外,\n        (b.death-a.death) 新增死亡 \n        FROM &#96;history&#96; a, &#96;history&#96; b \n        where a.date &#x3D; DATE_SUB(str_to_date(b.date,&#39;%Y-%m-%d&#39;),interval 1 day)\n        group by b.date  order by b.date desc limit 10) c\n\t\torder by c.&#96;日期&#96; asc&quot;&quot;&quot;\n    res &#x3D; query(sql)\n    return res\n\ndef get_r1_data():\n    # union_all 两块相加\n    sql &#x3D;&quot;&quot;&quot;select \n    province,current \n    from  &#96;details&#96;\n    where date &#x3D; (select max(date) max_date\n    from &#96;details&#96;) \n    order by date,current  desc limit 5; &quot;&quot;&quot;\n    res &#x3D; query(sql)\n    return res\n\n# 词云图没有\ndef get_r2_data():\n    sql &#x3D; &quot;&quot;&quot;SELECT \n\tprovince as &#96;省份&#96;,current as &#96;现存确诊&#96;,cumulative as &#96;累计确诊&#96;,\n\tby_yesterday as  &#96;相比上日&#96; ,round(heal&#x2F;cumulative,4) as &#96;治愈占比&#96;,round(death&#x2F;cumulative,4) as &#96;死亡占比&#96; \n    FROM &#96;details&#96;\n    where date  &#x3D;(select max(date) from &#96;details&#96;) \n    order by current desc limit 7;&quot;&quot;&quot;\n    res &#x3D; query(sql)\n    return res\nif __name__&#x3D;&#x3D;&#39;__main__&#39;:\n    print(get_l2_data())\n    pass\n\nselenium数据抓取部分https:&#x2F;&#x2F;python-selenium-zh.readthedocs.io&#x2F;zh_CN&#x2F;latest&#x2F;\n\n\n\n关于flask：https://www.cnblogs.com/songboriceboy/category/1867414.htmlhttps://blog.csdn.net/u014793102/category_9285123.html?spm=1001.2014.3001.5482\n关于selenium：\nhttps://python-selenium-zh.readthedocs.io/zh_CN/latest/\n","slug":"python-flask疫情数据可视化","date":"2021-07-21T06:18:39.000Z","categories_index":"python","tags_index":"数据分析","author_index":"弦好想断"},{"id":"3b7fc023aaa69e49fca460e6ff5152b5","title":"python常用功能代码整理，持续更新","content":"部分参考，实测后有改动https://mp.weixin.qq.com/s/A0NYVPaNclMkKgie2swClw\n本地文件整理   将本地多个 CSV 文件整合成一个文件import pandas as pd\nimport os\n\ndf_list &#x3D; []\nfor i in os.listdir():\n    if &quot;csv&quot; in i:\n        day &#x3D; i.split(&#39;.&#39;)[0].split(&#39;_&#39;)[-1]\n        df &#x3D; pd.read_csv(i)\n        df[&#39;day&#39;] &#x3D; day\n        df_list.append(df)\ndf &#x3D; pd.concat(df_list, axis&#x3D;0)\ndf.to_csv(&quot;total.txt&quot;, index&#x3D;0)\n\n多线程代码import threading\nimport time\n\nexitFlag &#x3D; 0\n\nclass myThread (threading.Thread):\n    def __init__(self, threadID, name, delay):\n        threading.Thread.__init__(self)\n        self.threadID &#x3D; threadID\n        self.name &#x3D; name\n        self.delay &#x3D; delay\n    def run(self):\n        print (&quot;开始线程：&quot; + self.name)\n        print_time(self.name, self.delay, 5)\n        print (&quot;退出线程：&quot; + self.name)\n\ndef print_time(threadName, delay, counter):\n    while counter:\n        if exitFlag:\n            threadName.exit()\n        time.sleep(delay)\n        print (&quot;%s: %s&quot; % (threadName, time.ctime(time.time())))\n        counter -&#x3D; 1\n\n# 创建新线程\nthread1 &#x3D; myThread(1, &quot;Thread-1&quot;, 1)\nthread2 &#x3D; myThread(2, &quot;Thread-2&quot;, 2)\n\n# 开启新线程\nthread1.start()\nthread2.start()\nthread1.join()\nthread2.join()\nprint (&quot;退出主线程&quot;)\n\n异步编程代码  异步爬取网站import asyncio\nimport aiohttp\nimport aiofiles\n\nasync def get_html(session, url):\n    try:\n        async with session.get(url&#x3D;url, timeout&#x3D;8) as resp:\n            if not resp.status &#x2F;&#x2F; 100 &#x3D;&#x3D; 2:\n                print(resp.status)\n                print(&quot;爬取&quot;, url, &quot;出现错误&quot;)\n            else:\n                resp.encoding &#x3D; &#39;utf-8&#39;\n                text &#x3D; await resp.text()\n                return text\n    except Exception as e:\n        print(&quot;出现错误&quot;, e)\n        await get_html(session, url)\n        #使用异步请求之后，对应的文件保存也需要使用异步，即是一处异步，处处异步\nasync def download(title_list, content_list):\n    async with aiofiles.open(&#39;&#123;&#125;.txt&#39;.format(title_list[0]), &#39;a&#39;,\n                             encoding&#x3D;&#39;utf-8&#39;) as f:\n        await f.write(&#39;&#123;&#125;&#39;.format(str(content_list)))\n\nrequests 库调用import requests\n\n#发送 GET 请求\nheaders &#x3D; &#123;\n    &#39;user-agent&#39;: &#39;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;96.0.4664.110 Safari&#x2F;537.36&#39;,\n  &#39;cookie&#39;: &#39;some_cookie&#39;\n&#125;\nresponse &#x3D; requests.request(&quot;GET&quot;, url, headers&#x3D;headers)\n#发送 POST 请求\nimport requests\n\npayload&#x3D;&#123;&#125;\nfiles&#x3D;[]\nheaders &#x3D; &#123;\n    &#39;user-agent&#39;: &#39;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;96.0.4664.110 Safari&#x2F;537.36&#39;,\n  &#39;cookie&#39;: &#39;some_cookie&#39;\n&#125;\nresponse &#x3D; requests.request(&quot;POST&quot;, url, headers&#x3D;headers, data&#x3D;payload, files&#x3D;files)\n\n\n#保存数据到CSV\nimport os\ndef save_data(data, date):\n    if not os.path.exists(r&#39;2021_data_%s.csv&#39; % date):\n        with open(&quot;2021_data_%s.csv&quot; % date, &quot;a+&quot;, encoding&#x3D;&#39;utf-8&#39;) as f:\n            f.write(&quot;标题,热度,时间,url\\n&quot;)\n            for i in data:\n                title &#x3D; i[&quot;title&quot;]\n                extra &#x3D; i[&quot;extra&quot;]\n                time &#x3D; i[&#39;time&#39;]\n                url &#x3D; i[&quot;url&quot;]\n                row &#x3D; &#39;&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;&#39;.format(title,extra,time,url)\n                f.write(row)\n                f.write(&#39;\\n&#39;)\n    else:\n        with open(&quot;2021_data_%s.csv&quot; % date, &quot;a+&quot;, encoding&#x3D;&#39;utf-8&#39;) as f:\n            for i in data:\n                title &#x3D; i[&quot;title&quot;]\n                extra &#x3D; i[&quot;extra&quot;]\n                time &#x3D; i[&#39;time&#39;]\n                url &#x3D; i[&quot;url&quot;]\n                row &#x3D; &#39;&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;&#39;.format(title,extra,time,url)\n                f.write(row)\n                f.write(&#39;\\n&#39;)\n\nIP代理池搭建import requests # python基础爬虫库\nfrom lxml import etree # 可以将网页转换为Elements对象\nimport time # 防止爬取过快可以睡眠一秒\n\n# 第一步：构造主页url地址，发送请求获取响应\n# 第二步：解析数据，将数据分组\n# 第三步：将数组的数据提取出来\n# 第四步：检测代理IP的可用性\n# 第五步：保存到文件中\n# https:&#x2F;&#x2F;blog.csdn.net&#x2F;yuan2019035055&#x2F;article&#x2F;details&#x2F;121334216\n\nclass daili():\n\n    # 1.发送请求，获取响应\n    def send_request(self, page):\n        print(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;正在抓取第&#123;&#125;页&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;.format(page))\n        # 目标网页，添加headers参数\n        base_url &#x3D; &#39;https:&#x2F;&#x2F;www.kuaidaili.com&#x2F;free&#x2F;inha&#x2F;&#123;&#125;&#x2F;&#39;.format(page)\n        headers &#x3D; &#123;\n            &#39;User-Agent&#39;: &#39;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;95.0.4638.69 Safari&#x2F;537.36&#39;&#125;\n\n        # 发送请求：模拟浏览器发送请求，获取响应数据\n        response &#x3D; requests.get(base_url, headers&#x3D;headers)\n        data &#x3D; response.content.decode()\n        time.sleep(1)\n\n        return data\n\n    # 2.解析数据\n    def parse_data(self, data):\n\n        # 数据转换\n        html_data &#x3D; etree.HTML(data)\n        # 分组数据\n        parse_list &#x3D; html_data.xpath(&#39;&#x2F;&#x2F;table[@class&#x3D;&quot;table table-bordered table-striped&quot;]&#x2F;tbody&#x2F;tr&#39;)\n        return parse_list\n\n    # 4.检测代理IP\n    def check_ip(self, proxies_list):\n        headers &#x3D; &#123;\n            &#39;User-Agent&#39;: &#39;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;95.0.4638.69 Safari&#x2F;537.36&#39;&#125;\n\n        can_use &#x3D; []\n        for proxies in proxies_list:\n            try:\n                response &#x3D; requests.get(&#39;https:&#x2F;&#x2F;www.baidu.com&#x2F;&#39;, headers&#x3D;headers, proxies&#x3D;proxies, timeout&#x3D;0.1)\n                if response.status_code &#x3D;&#x3D; 200:\n                    can_use.append(proxies)\n            except Exception as e:\n                print(e)\n        return can_use\n\n    # 5.保存到文件\n    def save(self, can_use):\n\n        file &#x3D; open(&#39;..\\data\\IP.txt&#39;, &#39;w&#39;)\n        for i in range(len(can_use)):\n            s &#x3D; str(can_use[i]) + &#39;\\n&#39;\n            file.write(s)\n        file.close()\n\n    # 实现主要逻辑\n    def run(self):\n        proxies_list &#x3D; []\n        # 实现翻页，我这里只爬取了四页（可以修改5所在的数字）\n        for page in range(1, 3):\n            data &#x3D; self.send_request(page)\n            parse_list &#x3D; self.parse_data(data)\n            # 3.获取数据\n            for tr in parse_list:\n                proxies_dict &#x3D; &#123;&#125;\n                http_type &#x3D; tr.xpath(&#39;.&#x2F;td[4]&#x2F;text()&#39;)\n                ip_num &#x3D; tr.xpath(&#39;.&#x2F;td[1]&#x2F;text()&#39;)\n                port_num &#x3D; tr.xpath(&#39;.&#x2F;td[2]&#x2F;text()&#39;)\n\n                http_type &#x3D; &#39; &#39;.join(http_type)\n                ip_num &#x3D; &#39; &#39;.join(ip_num)\n                port_num &#x3D; &#39; &#39;.join(port_num)\n\n                proxies_dict[http_type] &#x3D; ip_num + &quot;:&quot; + port_num\n\n                proxies_list.append(proxies_dict)\n\n        print(&quot;获取到的代理IP数量：&quot;, len(proxies_list))\n\n        can_use &#x3D; self.check_ip(proxies_list)\n\n        print(&quot;能用的代理IP数量：&quot;, len(can_use))\n        print(&quot;能用的代理IP:&quot;, can_use)\n        self.save(can_use)\n\n\n\nif __name__ &#x3D;&#x3D; &quot;__main__&quot;:\n    dl &#x3D; daili()\n    dl.run()\n\n    # 从文件中随机取出一个IP去访问网址\n    import random\n    import requests\n    # 打开文件，换行读取\n    f&#x3D;open(&quot;..\\data\\IP.txt&quot;,&quot;r&quot;)\n    file &#x3D; f.readlines()\n\n    # 遍历并分别存入列表，方便随机选取IP\n    item &#x3D; []\n    for proxies in file:\n        proxies &#x3D; eval(proxies.replace(&#39;\\n&#39;,&#39;&#39;)) # 以换行符分割，转换为dict对象\n        item.append(proxies)\n\n    proxies &#x3D; random.choice(item)  # 随机选取一个IP\n\n    url &#x3D; &#39;https:&#x2F;&#x2F;www.baidu.com&#x2F;&#39;\n    headers &#x3D; &#123;&#39;User-Agent&#39;: &#39;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;95.0.4638.69 Safari&#x2F;537.36&#39;&#125;\n\n    response &#x3D; requests.get(url,headers&#x3D;headers,proxies&#x3D;proxies)\n    print(response.status_code) # 输出状态码 200，表示访问成功\n    \n\n\n\n生成一段时间区间内的日期import pandas as pd\nprint([str(i) for i in pd.date_range(&#39;2020-02-03&#39;,&#39;2020-03-05&#39;,freq&#x3D;&quot;D&quot;).strftime(&quot;%Y-%m-%d&quot;).tolist()])\n\n获取过去 N 天的日期import datetime\n\ndef get_nday_list(n):\n    before_n_days &#x3D; []\n    for i in range(1, n + 1)[::-1]:\n        before_n_days.append(str(datetime.date.today() - datetime.timedelta(days&#x3D;i)))\n    return before_n_days\n\na &#x3D; get_nday_list(30)\nprint(a)\n\n生成xmindimport xmind\n\nw &#x3D; xmind.load(&quot;test.xmind&quot;)\ns1 &#x3D; w.getPrimarySheet()  # 获取此工作表\ns1.setTitle(&quot;first sheet&quot;)  # 设置标题\na &#x3D; &#123;&quot;h1&quot;: &#39;Python 技术学习&#39;, &#39;h2&#39;: [&#39;Python基础&#39;, &#39;Python 爬虫&#39;],\n     &#39;h3&#39;: [[&#39;Python环境安装&#39;, &#39;Python基础语法&#39;, &#39;Python数据结构&#39;], [&#39;Python爬虫基础知识详解&#39;, &#39;Python爬虫相关模块详解&#39;]]&#125;\nr1 &#x3D; s1.getRootTopic()  # 获取此工作表的根主题\nr1.setTitle(a[&#39;h1&#39;])  # 设置标题\nc &#x3D; a[&#39;h2&#39;]\nc2 &#x3D; a[&#39;h3&#39;]\nfor i, val in enumerate(c):\n    print(i, val)\n    a &#x3D; &#39;b&#39; + str(i)\n    a &#x3D; r1.addSubTopic()\n    a.setTitle(val)  # 设置标题\n    for i2, val2 in enumerate(c2):\n        if i &#x3D;&#x3D; i2:\n            a2 &#x3D; &#39;b2&#39; + str(i)\n            a2 &#x3D; a.addSubTopic()\n            #        if isinstance(val, list):\n            for i3, val3 in enumerate(val2):\n                a3 &#x3D; &#39;b3&#39; + str(i3)\n                a3 &#x3D; a2.addSubTopic()\n                a3.setTitle(val3)\n\nxmind.save(w, &quot;Python_detail.xmind&quot;)\n【python】如何提取本机连接过的wifi密码（亲测好用import subprocess\n# 获取wifi列表\noutput &#x3D; subprocess.run([&#39;netsh&#39;,&#39;wlan&#39;,&#39;show&#39;,&#39;profiles&#39;],capture_output &#x3D; True).stdout.decode(&#39;gbk&#39;).split(&#39;\\n&#39;)\nwifis &#x3D; [line.split(&#39;:&#39;)[1][1:-1] for line in output if &quot;所有用户配置文件&quot; in line]\n\n#查看每个wifi对应的密码\nfor wifi in wifis:\n    results &#x3D; subprocess.run([&#39;netsh&#39;,&#39;wlan&#39;,&#39;show&#39;,&#39;profile&#39;,wifi,&#39;key&#x3D;clear&#39;],capture_output &#x3D; True).stdout.decode(&#39;gbk&#39;,errors &#x3D; &#39;ignore&#39;).split(&#39;\\n&#39;)\n    results &#x3D; [line.split(&#39;:&#39;)[1][1:-1] for line in results if &quot;关键内容&quot; in line]\n    try:\n        print(f&#39;wifi账号：&#123;wifi&#125;，密码:&#123;results[0]&#125;&#39;)\n    except IndexError:\n        print(f&#39;wifi账号：&#123;wifi&#125;，密码:提取失败！&#39;)\n\n\n","slug":"python常用功能代码整理，持续更新","date":"2022-06-08T08:01:27.000Z","categories_index":"python","tags_index":"python","author_index":"弦好想断"},{"id":"b183580f01b4c460a08090715fbc01f0","title":"python数据分析：xlwings操作excel","content":"xlwings是Python中操作Excel的一个第三方库，支持.xls读写，.xlsx读写，操作非常简单，功能也很强大xlwings与VBA的配合非常完美，你可以在python中调用VBA，也可以在VBA中使用python编程，这些通过xlwings都可以巧妙实现。先说装这个xlwings碰到个神坑：\n用pip install pywin32装完之后错误就来了\nDLL load failed while importing win32api: 找不到指定的程序。md搞死我了\n查不到，再查，再查，再查。。。\n解决方法：https://www.cnblogs.com/Swalllow/p/11711750.html找到文件pywin32_postinstall.py的路径，\n由于安装路径不同，可能位置不一样，可以在你安装python的文件夹搜索这个文件，\n一般在安装文件下的Scripts文件里，用cmd进入这个Scripts文件夹\n如cd/d D:\\install\\python3.8\\Scripts\n在路径下运行python pywin32_postinstall.py -install\n再检查一次是否成功\n芜湖~，居然好了\n学习xlwings看这里：\nhttps://www.kancloud.cn/gnefnuy/xlwings-docs/1127455https://www.cnblogs.com/Renyi-Fan/p/13244027.html\nimport pandas as pd\nimport xlwings as xw\n\n\n# 建立excel表连接\nwb &#x3D; xw.Book(&quot;out.xlsx&quot;)\n#     实例化工作表对象\nsht &#x3D; wb.sheets[&quot;源数据&quot;]\nsht\n\n\n&lt;Sheet [out.xlsx]源数据&gt;\n\n#     返回工作表绝对路径\nwb.fullname\n\n\n&#39;C:\\\\Users\\\\supermanzwg\\\\workspace\\\\3Data_Processing(自动化)\\\\out.xlsx&#39;\n\n#     返回工作簿的名字\n\nsht.name\n\n\n&#39;源数据&#39;\n\n#     在单元格中写入数据\nsht.range(&#39;A1&#39;).value &#x3D; &quot;xlwing牛逼啊&quot;\nsht\n\n\n&lt;Sheet [out.xlsx]源数据&gt;\n\n#     读取单元格内容\nsht.range(&#39;A1&#39;).value\n\n\n&#39;xlwing牛逼啊&#39;\n\n#     清除单元格内容和格式\nsht.range(&#39;A1&#39;).clear()\n\n\n#     获取单元格的列标\nsht.range(&#39;A1&#39;).column\n\n\n1\n\n#     获取单元格的行标\nsht.range(&#39;A1&#39;).row\n\n1\n\n#     获取单元格的行高\nsht.range(&#39;A1&#39;).row_height\n\n13.2\n\n#     获取单元格的列宽\nsht.range(&#39;A1&#39;).column_width\n\n8.47\n\n#     列宽自适应\nsht.range(&#39;A1:A99&#39;).columns.autofit()\nsht\n\n&lt;Sheet [out.xlsx]源数据&gt;\n\n#     行高自适应\nsht.range(&#39;A1:M1&#39;).rows.autofit()\n\n#     给单元格上背景色，传入RGB值\nsht.range(&#39;A1&#39;).color &#x3D; (34,139,34)\n\n#     获取单元格颜色，RGB值\nsht.range(&#39;A1&#39;).color\n\n(34, 139, 34)\n\n#     清除单元格颜色\nsht.range(&#39;A1&#39;).color &#x3D; None\n\n#     输入公式，相应单元格会出现计算结果\nsht.range(&#39;A1&#39;).formula&#x3D;&#39;&#x3D;SUM(H6:H7)&#39;\n\n#     获取单元格公式\nsht.range(&#39;A1&#39;).formula_array\n\n&#39;=SUM(H6:H7)&#39;\n\n#     在单元格中写入批量数据，只需要指定其实单元格位置即可\nsht.range(&#39;A2&#39;).value &#x3D; [[&#39;Foo 1&#39;, &#39;Foo 2&#39;, &#39;Foo 3&#39;], [10.0, 20.0, 30.0]]\n\n\n#     读取表中批量数据，使用expand()方法\nsht.range(&#39;A2&#39;).expand().value\n\n\n#     其实你也可以不指定工作表的地址，直接与电脑里的活动表格进行交互\n# 写入\nxw.Range(&quot;E1&quot;).value &#x3D; &quot;xlwings&quot;# 读取\nxw.Range(&quot;E1&quot;).value\n\n&#39;xlwings&#39;\n\nxw.range(&quot;E2&quot;).value &#x3D; &quot;xlwings&quot;\n\n---------------------------------------------------------------------------\n\nAttributeError                            Traceback (most recent call last)\n\nC:\\Users\\SUPERM~1\\AppData\\Local\\Temp/ipykernel_10040/191138757.py in &lt;module&gt;\n----&gt; 1 xw.range(&quot;E2&quot;).value = &quot;xlwings&quot;\n\nAttributeError: module &#39;xlwings&#39; has no attribute &#39;range&#39;\n\n# xlwings与numpy、pandas、matplotlib互动\n#     支持写入numpy array数据类型\n\nimport numpy as np\nnp_data &#x3D; np.array((1,2,3))\nsht.range(&#39;F1&#39;).value &#x3D; np_data\n\n#     支持将pandas DataFrame数据类型写入excel\n\nimport pandas as pd\ndf &#x3D; pd.DataFrame([[1,2], [3,4]], columns&#x3D;[&#39;a&#39;, &#39;b&#39;])\nsht.range(&#39;A5&#39;).value &#x3D; df\n\n#     将数据读取，输出类型为DataFrame\n\nsht.range(&#39;A5&#39;).options(pd.DataFrame,expand&#x3D;&#39;table&#39;).value\n\n#     将matplotlib图表写入到excel表格里\n\nimport matplotlib.pyplot as plt\n%matplotlib inline\nfig &#x3D; plt.figure()\nplt.plot([1, 2, 3, 4, 5])\nsht.pictures.add(fig, name&#x3D;&#39;MyPlot&#39;, update&#x3D;True)\n\n# xlwings与VBA互相调用\n\n\n&lt;Picture &#39;MyPlot&#39; in &lt;Sheet [out.xlsx]源数据&gt;&gt;\n\n","slug":"python数据分析：xlwings操作excel","date":"2022-01-16T11:16:09.000Z","categories_index":"python","tags_index":"数据分析","author_index":"弦好想断"},{"id":"68c9396da13a152d585d7816d6c82312","title":"sql排名函数","content":"\nrank()排名是不连续的，出现同名的排序序号会相同(比较常规的排序)，存在并列，且序号会跳跃\n适合求第一名，名次这类\n\n\nselect \nemployee_id\n,last_name\n,department_id\n,salary\n,rank() over(partition by department_id order by salary desc) \nfrom employees\n\nrow_number()排名是连续的,出现同名的序号仍然会连续，不存在并列和跳跃\n适合计算个数，位置，连续购买场景\n\n\nselect \nemployee_id \n,last_name \n,department_id \n,salary \n,row_number() over(partition by department_id order by salary desc) \nfrom employees \n\ndense_rank()排名是连续的，出现同名的序号会相同，存在并列，且序号不会跳跃\n（用的比较少的，单纯需要排名且存在并列也不跳跃）\n\n\nselect \nemployee_id \n,last_name \n,department_id \n,salary \n,dense_rank() over(partition by department_id order by salary desc) \nfrom employees \n– ntile()根据排序指定数量进行分区编号（分区编号排序）\nselect \nemployee_id \n,last_name \n,department_id \n,salary \n,ntile(3) over(partition by department_id order by salary desc) \nfrom employees ","slug":"sql排名函数","date":"2021-12-23T03:14:23.000Z","categories_index":"sql","tags_index":"数据分析","author_index":"弦好想断"},{"id":"1a3e4bd78f5e4ca42de4b5c02b9d4f86","title":"sql查询连续签到天数","content":"先建表\ncreate table user_attendence(\nuser_id bigint comment &#39;用户名&#39;, \ndate TIMESTAMP comment &#39;日期&#39; ,\nis_sign bigint comment &#39;是否登录，0为否，1为是&#39;);\n-- delete from user_attendence;\n接下来用python自己导入随机数据,500个用户、时间2021-1-1~2021-5-5。\nimport pymysql\nimport pandas as pd\nfrom sqlalchemy import create_engine\nimport numpy as np\ndf &#x3D; pd.DataFrame()\ndate &#x3D; pd.date_range(&#39;2021-1-1&#39;,&#39;2021-5-5&#39;).strftime(&#39;%Y-%m-%d&#39;)\ndf[&quot;user_id&quot;]&#x3D;[i for i in np.arange(1,500)]*len(date)\ndf[&#39;date&#39;] &#x3D; [i for i in date]*len(np.arange(1,500))\ndf[&quot;is_sign&quot;] &#x3D; [np.random.choice([0,1]) for i in range(len(df))]\ndf &#x3D; df.sort_values(by&#x3D;[&#39;user_id&#39;,&#39;date&#39;],na_position&#x3D;&#39;first&#39;)\n#写入数据库\ncon &#x3D; &#39;mysql+pymysql:&#x2F;&#x2F;root:3333@localhost:3306&#x2F;supermanzwg?charset&#x3D;utf8&#39;\n#如果出现字符串编码错误记得在Navicat运行alter table 表名 convert to character set utf8mb4;\ndf.to_sql(name&#x3D;&#39;user_attendence&#39;,con&#x3D;con,if_exists&#x3D;&#39;append&#39;,index &#x3D; False)\n#截至当前，每个用户已经连续签到的天数查出最后一次不登录的日期，与当前日期进行比较，二者差值为几就是连续登录几天\nselect max(date) from user_attendence;\nselect \nuser_id ,\nmax(date),\nDATEDIFF(&#39;2021-02-19&#39;,max(date)) as max_con_days\nfrom user_attendence \nwhere is_sign &#x3D; 0 \ngroup by user_id;\n#计算有史以来用户最大连续签到天数；对用户分组，按日期进行排序，排序序号为rank;如果日期与序号的差值为相等，按这个差值进行分组并计数，取最大值\nselect \nuser_id\n,max(&#96;次数&#96;)  &#96;最大连续登陆天数&#96;\nfrom \n    (select user_id\n    ,date\n    ,a.date-a.rn diff\n    ,count(*) &#96;次数&#96;\n    from \n        (select \n        user_id\n        ,date,\n        row_number() over(partition by user_id order by date asc) rn\n        from user_attendence  \n        where is_sign &#x3D; 1\n        ) a \n    group by user_id,diff\n    ) b \ngroup by user_id order by max(&#96;次数&#96;) desc;\n\n","slug":"sql查询连续签到天数","date":"2021-12-20T08:23:46.000Z","categories_index":"sql","tags_index":"数据分析","author_index":"弦好想断"},{"id":"a556aaed3b3be5cc651b39ff50e6148d","title":"mysql_tips","content":"\n四个在工作后才知道的SQL密技\nhttps://zhuanlan.zhihu.com/p/412878736\n\nmysql基础https://blog.csdn.net/weixin_45108087/article/details/102766281\n\nMYSQL中的COLLATE是什么？https://blog.csdn.net/weixin_34194317/article/details/92720517\n\nmysql中key 、primary key 、unique key 与index区别https://blog.csdn.net/nanaMasuda/article/details/52543177\n\nMySQL中REGEXP正则表达式https://blog.csdn.net/u011271894/article/details/79705869\n\nmysql中distinct后面两个字段: 同时作用了两个字段，也就是必须得这两个字段都相同的才会被排除\n\nMySql中把一个表的数据插入到另一个表中https://www.cnblogs.com/jiangxiaobo/p/7722691.html\n\nMysql 根据一个表数据更新另外一个表https://www.cnblogs.com/wu628/p/4948833.html\ninsert into table_2 (promotion_price,promotion) SELECT 字段1，字段2，...  FROM table_1 where table_1.id is not in (\nselect id from  table_2 );\nconcat以及group_concat的用法https://baijiahao.baidu.com/s?id=1595349117525189591&amp;wfr=spider&amp;for=pc\n\n字符串截取总结：left()、right()、substring()、substring_index()https://blog.csdn.net/wolinxuebin/article/details/7845917\n\nreplace的用法https://www.cnblogs.com/to-creat/p/6516375.html\n\nmysql中join的用法https://www.cnblogs.com/beili/p/9140019.html\n\nMySQL计算日期的函数DATE_SUB(d,INTERVAL expr type)https://blog.csdn.net/sinat_34979528/article/details/54571316\n\nMySQL DATE_ADD() 函数https://www.w3school.com.cn/sql/func_date_add.asp\n\nsql中interval用法总结https://blog.csdn.net/weixin_42586373/article/details/107467914\n\nSQL中的cast()函数https://www.jianshu.com/p/e8ed290426b6\n\nMySQL UNION 操作符https://www.runoob.com/mysql/mysql-union-operation.html\n\nROW_NUMBER() OVER()函数用法详解 （分组排序 例子多）https://blog.csdn.net/qq_25221835/article/details/82762416\n\nhive中regexp_extract的用法总结https://blog.csdn.net/jv_rookie/article/details/55211955\n\n\n","slug":"mysql-tips","date":"2021-12-13T08:35:58.000Z","categories_index":"sql","tags_index":"数据分析","author_index":"弦好想断"},{"id":"7df2c9f61f81e14813ba612502b886c1","title":"python办公自动化：操作excel","content":"#python 使用 openpyxl 操作 excel\n\nopenpyxl 最好用的 python 操作 excel 表格库，不接受反驳（想反驳自己去学其他的） \n\nopenpyxl 官网链接：https://openpyxl.readthedocs.io/en/stable/\n\nhttps://www.zhihu.com/column/c_1261255815367487488\n\nopenpyxl 只支持【.xlsx / .xlsm / .xltx / .xltm】格式的文件\n\n建议在jupyter-notebook里面操作\n打开 Excel 表格并获取表格名称；通过 sheet 名称获取表格from openpyxl import load_workbook \nworkbook &#x3D; load_workbook(filename &#x3D; &quot;test.xlsx&quot;) \nworkbook.sheetnames #打开 Excel 表格并获取表格名称\nsheet &#x3D; workbook[&quot;Sheet1&quot;] #通过 sheet 名称获取表格\nsheet.dimensions # 获取表格的尺寸大小(几行几列数据)\n获取表格内某个格子的数据workbook &#x3D; load_workbook(filename &#x3D; &quot;test.xlsx&quot;) \nsheet &#x3D; workbook.active #打开激活的表格\nprint(sheet) \ncell1 &#x3D; sheet[&quot;A1&quot;] #获取 A1 格子的数据\ncell2 &#x3D; sheet[&quot;C11&quot;] \ncell3 &#x3D; sheet.cell(row &#x3D; 1,column &#x3D; 1) #通过指定行列号获取格子数据\ncell4 &#x3D; sheet.cell(row &#x3D; 11,column &#x3D; 3)\nprint(cell1.value, cell1.row, cell1.column, cell1.coordinate) \n#获取格子中的值、行数、列数、坐标；\nsheet[&quot;A&quot;] --- 获取 A 列的数据\nsheet[&quot;A:C&quot;] --- 获取 A,B,C 三列的数据\nsheet[5] --- 只获取第 5 行的数据\n# 获取 A1:C2 区域的值\ncell &#x3D; sheet[&quot;A1:C2&quot;] \nprint(cell) \nfor i in cell: \n  for j in i: \n    print(j.value)\n.iter_rows()方式（类似pandas里面的iterrows）有.iter_rows()方式，肯定也会有.iter_cols()方式，只不过一个是按行读取，一个是按列读取。\nworkbook &#x3D; load_workbook(filename &#x3D; &quot;test.xlsx&quot;) \nsheet &#x3D; workbook.active \nprint(sheet) \n# 按行获取值\nfor i in sheet.iter_rows(min_row&#x3D;2, max_row&#x3D;5, min_col&#x3D;1, max_col&#x3D;2): #按行读取\n  for j in i: \n    print(j.value)\n# 按列获取值\nfor i in sheet.iter_cols(min_row&#x3D;2, max_row&#x3D;5, min_col&#x3D;1, max_col&#x3D;2): #按列读取\n  for j in i: \n    print(j.value)\nfor i in sheet.rows: #获取所有行\n  print(i)\n修改表格中的内容: 向某个格子中写入内容并保存workbook &#x3D; load_workbook(filename &#x3D; &quot;test.xlsx&quot;) \nsheet &#x3D; workbook.active \nprint(sheet)\nsheet[&quot;A1&quot;] &#x3D; &quot;哈喽&quot; \n# 这句代码也可以改为 cell &#x3D; sheet[&quot;A1&quot;] cell.value &#x3D; &quot;哈喽&quot; \nworkbook.save(filename &#x3D; &quot;哈喽.xlsx&quot;) \n&quot;&quot;&quot; \n注意：我们将“A1”单元格的数据改为了“哈喽”，并另存为了“哈喽.xlsx”文\n件。 如果我们保存的时候，不修改表名，相当于直接修改源文件；\n&quot;&quot;&quot;\n.append()方式：会在表格已有的数据后面，按行插入数据(很有用)；\nworkbook &#x3D; load_workbook(filename &#x3D; &quot;test.xlsx&quot;) \nsheet &#x3D; workbook.active\nprint(sheet) \ndata &#x3D; [ \n[&quot;唐僧&quot;,&quot;男&quot;,&quot;180cm&quot;], \n[&quot;孙悟空&quot;,&quot;男&quot;,&quot;188cm&quot;], \n[&quot;猪八戒&quot;,&quot;男&quot;,&quot;175cm&quot;], \n[&quot;沙僧&quot;,&quot;男&quot;,&quot;176cm&quot;], \n] \nfor row in data: \n  sheet.append(row) \nworkbook.save(filename &#x3D; &quot;test.xlsx&quot;)\n使用 excel 函数公式(很有用)import openpyxl\nfrom openpyxl.utils import FORMULAE \nprint(FORMULAE)#python 支持写哪些“excel 函数公式”\n# 这是我们在 excel 中输入的公式\n&#x3D;IF(RIGHT(C2,2)&#x3D;&quot;cm&quot;,C2,SUBSTITUTE(C2,&quot;m&quot;,&quot;&quot;)*100&amp;&quot;cm&quot;) \n# 那么，在 python 中怎么插入 excel 公式呢？\nworkbook &#x3D; load_workbook(filename &#x3D; &quot;test.xlsx&quot;) \nsheet &#x3D; workbook.active \nprint(sheet) \nsheet[&quot;D1&quot;] &#x3D; &quot;标准身高&quot; \nfor i in range(2,16): \n  sheet[&quot;D&#123;&#125;&quot;.format(i)] &#x3D; \n  &#39;&#x3D;IF(RIGHT(C&#123;&#125;,2)&#x3D;&quot;cm&quot;,C&#123;&#125;,SUBSTITUTE(C&#123;&#125;,&quot;m&quot;,&quot;&quot;)*100&amp;&quot;cm&quot;)&#39;.format(i,i,i) \nworkbook.save(filename &#x3D; &quot;test.xlsx&quot;)\n.insert_cols()和.insert_rows()：插入空行和空列\n.insert_cols(idx=数字编号, amount=要插入的列数)，插入的位置是在 idx 列数的左侧插入；\n\n.insert_rows(idx=数字编号, amount=要插入的行数)，插入的行数是在 idx 行数的下方插入；\nworkbook &#x3D; load_workbook(filename &#x3D; &quot;test.xlsx&quot;) \nsheet &#x3D; workbook.active \nprint(sheet) \nsheet.insert_cols(idx&#x3D;4,amount&#x3D;2) #从第4列开始插入2列\nsheet.insert_rows(idx&#x3D;5,amount&#x3D;4) #第5行开始插入2行\nworkbook.save(filename &#x3D; &quot;test.xlsx&quot;)\n\n.delete_rows()和.delete_cols()：删除行和列\n.delete_rows(idx=数字编号, amount=要删除的行数)\n.delete_cols(idx=数字编号, amount=要删除的列数)workbook &#x3D; load_workbook(filename &#x3D; &quot;test.xlsx&quot;) \nsheet &#x3D; workbook.active print(sheet) \n# 删除第一列，第一行\nsheet.delete_cols(idx&#x3D;1) \nsheet.delete_rows(idx&#x3D;1) \nworkbook.save(filename &#x3D; &quot;test.xlsx&quot;)\n.move_range()：移动格子\n.move_range(“数据区域”,rows=,cols=)：row正整数表示向下、负整数表示向上移动；cols正整数表示向右、负整数表示向左移动。\n\nsheet.move_range(&quot;C1:D4&quot;,rows&#x3D;2,cols&#x3D;-1)# 向左移动两列，向下移动两行\n.create_sheet()：创建新的 sheet 表格\n.create_sheet(“新的 sheet 名”)：创建一个新的 sheet 表；workbook &#x3D; load_workbook(filename &#x3D; &quot;test.xlsx&quot;) \nsheet &#x3D; workbook.active \nprint(sheet) \nworkbook.create_sheet(&quot;我是一个新的 sheet&quot;) \nprint(workbook.sheetnames) \nworkbook.save(filename &#x3D; &quot;test.xlsx&quot;)\n\n.remove()：删除某个 sheet 表\n.remove(“sheet 名”)：删除某个 sheet 表；workbook &#x3D; load_workbook(filename &#x3D; &quot;test.xlsx&quot;) \nsheet &#x3D; workbook.active \nprint(workbook.sheetnames) \n# 这个相当于激活的这个 sheet 表，激活状态下，才可以操作；\nsheet &#x3D; workbook[&#39;我是一个新的 sheet&#39;] \nprint(sheet) \nworkbook.remove(sheet) \nprint(workbook.sheetnames) \nworkbook.save(filename &#x3D; &quot;test.xlsx&quot;)\n\n.copy_worksheet()：复制一个 sheet 表到另外一张 excel 表\n这个操作的实质，就是复制某个 excel 表中的 sheet 表，然后将文件存储到另外一张excel 表中workbook &#x3D; load_workbook(filename &#x3D; &quot;a.xlsx&quot;) \nsheet &#x3D; workbook.active \nprint(&quot;a.xlsx 中有这几个 sheet 表&quot;,workbook.sheetnames) \nsheet &#x3D; workbook[&#39;姓名&#39;] \nworkbook.copy_worksheet(sheet) \nworkbook.save(filename &#x3D; &quot;test.xlsx&quot;)\n\nsheet.title：修改 sheet 表的名称workbook &#x3D; load_workbook(filename &#x3D; &quot;a.xlsx&quot;) \nsheet &#x3D; workbook.active \nprint(sheet) \nsheet.title &#x3D; &quot;我是修改后的 sheet 名&quot; \nprint(sheet)\n\n创建新的 excel 表格文件from openpyxl import Workbook \nworkbook &#x3D; Workbook() \nsheet &#x3D; workbook.active \nsheet.title &#x3D; &quot;表格 1&quot; \nworkbook.save(filename &#x3D; &quot;新建的 excel 表格&quot;)\n\nsheet.freeze_panes：冻结窗口\n.freeze_panes = “单元格”workbook &#x3D; load_workbook(filename &#x3D; &quot;花园.xlsx&quot;) \nsheet &#x3D; workbook.active \nprint(sheet) \nsheet.freeze_panes &#x3D; &quot;C3&quot; \nworkbook.save(filename &#x3D; &quot;花园.xlsx&quot;) \n&quot;&quot;&quot; \n冻结窗口以后，你可以打开源文件，进行检验；\n&quot;&quot;&quot;\n\nsheet.auto_filter.ref：给表格添加“筛选器”\n.auto_filter.ref = sheet.dimension 给所有字段添加筛选器；\n.auto_filter.ref = “A1” 给 A1 这个格子添加“筛选器”，就是给第一列添加“筛选器”；workbook &#x3D; load_workbook(filename &#x3D; &quot;花园.xlsx&quot;) \nsheet &#x3D; workbook.active \nprint(sheet) \nsheet.auto_filter.ref &#x3D; sheet[&quot;A1&quot;] \nworkbook.save(filename &#x3D; &quot;花园.xlsx&quot;)\n\n批量调整字体和样式1、修改字体样式\nFont(name=字体名称,size=字体大小,bold=是否加粗,italic=是否斜体,color=字体颜色)from openpyxl.styles import Font \nfrom openpyxl import load_workbook \nworkbook &#x3D; load_workbook(filename&#x3D;&quot;花园.xlsx&quot;) \nsheet &#x3D; workbook.active \ncell &#x3D; sheet[&quot;A1&quot;] \nfont &#x3D; Font(name&#x3D;&quot;微软雅黑&quot;,size&#x3D;20,bold&#x3D;True,italic&#x3D;True,color&#x3D;&quot;FF0000&quot;) \ncell.font &#x3D; font\nworkbook.save(filename &#x3D; &quot;花园.xlsx&quot;) \n&quot;&quot;&quot; \n这个 color 是 RGB 的 16 进制表示，自己下去百度学习；\n&quot;&quot;&quot;\n\n2、获取表格中格子的字体样式from openpyxl.styles import Font \nfrom openpyxl import load_workbook \nworkbook &#x3D; load_workbook(filename&#x3D;&quot;花园.xlsx&quot;) \nsheet &#x3D; workbook.active \ncell &#x3D; sheet[&quot;A2&quot;] \nfont &#x3D; cell.font \nprint(font.name, font.size, font.bold, font.italic, font.color)\n\n3、设置对齐样式\nAlignment(horizontal=水平对齐模式,vertical=垂直对齐模式,text_rotation=旋转角度,wrap_text=是否自动换行)\n\n水平对齐：‘distributed’，‘justify’，‘center’，‘leftfill’， ‘centerContinuous’，‘right，‘general’；\n\n垂直对齐：‘bottom’，‘distributed’，‘justify’，‘center’，‘top’；\nfrom openpyxl.styles import Alignment \nfrom openpyxl import load_workbook \nworkbook &#x3D; load_workbook(filename&#x3D;&quot;花园.xlsx&quot;) \nsheet &#x3D; workbook.active \ncell &#x3D; sheet[&quot;A1&quot;]\nalignment &#x3D; Alignment(horizontal&#x3D;&quot;center&quot;,vertical&#x3D;&quot;center&quot;,text_rotation&#x3D;45,wrap_text&#x3D;True) \ncell.alignment &#x3D; alignment \nworkbook.save(filename &#x3D; &quot;花园.xlsx&quot;)\n4、设置边框样式\nSide(style=边线样式，color=边线颜色)\n\nBorder(left=左边线样式，right=右边线样式，top=上边线样式，bottom=下边线样式)\n\nstyle 参数的种类： ‘double, ‘mediumDashDotDot’, ‘slantDashDot’, ‘dashDotDot’,’dotted’,’hair’,‘mediumDashed, ‘dashed’, ‘dashDot’, ‘thin’, ‘mediumDashDot’,’medium’, ‘thick’\nfrom openpyxl.styles import Side,Border \nfrom openpyxl import load_workbook \nworkbook &#x3D; load_workbook(filename&#x3D;&quot;花园.xlsx&quot;) \nsheet &#x3D; workbook.active \ncell &#x3D; sheet[&quot;D6&quot;]\nside1 &#x3D; Side(style&#x3D;&quot;thin&quot;,color&#x3D;&quot;FF0000&quot;) \nside2 &#x3D; Side(style&#x3D;&quot;thick&quot;,color&#x3D;&quot;FFFF0000&quot;) \nborder &#x3D; Border(left&#x3D;side1,right&#x3D;side1,top&#x3D;side2,bottom&#x3D;side2) \ncell.border &#x3D; border \nworkbook.save(filename &#x3D; &quot;花园.xlsx&quot;)\n\n5、设置填充样式\nPatternFill(fill_type=填充样式，fgColor=填充颜色）\n\nGradientFill(stop=(渐变颜色 1，渐变颜色 2……))\nfrom openpyxl.styles import PatternFill,GradientFill \nfrom openpyxl import load_workbook \nworkbook &#x3D; load_workbook(filename&#x3D;&quot;花园.xlsx&quot;) \nsheet &#x3D; workbook.active \ncell_b9 &#x3D; sheet[&quot;B9&quot;] \npattern_fill &#x3D; PatternFill(fill_type&#x3D;&quot;solid&quot;,fgColor&#x3D;&quot;99ccff&quot;) \ncell_b9.fill &#x3D; pattern_fill \ncell_b10 &#x3D; sheet[&quot;B10&quot;]\ngradient_fill &#x3D; GradientFill(stop&#x3D;(&quot;FFFFFF&quot;,&quot;99ccff&quot;,&quot;000000&quot;)) \ncell_b10.fill &#x3D; gradient_fill \nworkbook.save(filename &#x3D; &quot;花园.xlsx&quot;)\n6、设置行高和列宽\n.row_dimensions[行编号].height = 行高\n\n.column_dimensions[列编号].width = 列宽\nworkbook &#x3D; load_workbook(filename&#x3D;&quot;花园.xlsx&quot;) \nsheet &#x3D; workbook.active \n# 设置第 1 行的高度\nsheet.row_dimensions[1].height &#x3D; 50 #将整个表的行高设置为 50\n# 设置 B 列的宽度\nsheet.column_dimensions[&quot;B&quot;].width &#x3D; 20 #列宽设置为 30；\nworkbook.save(filename &#x3D; &quot;花园.xlsx&quot;)\n\n7、合并单元格\n.merge_cells(待合并的格子编号)\n.merge_cells(start_row=起始行号，start_column=起始列号，end_row=结束行号，end_column=结束列号)workbook &#x3D; load_workbook(filename&#x3D;&quot;花园.xlsx&quot;)\nsheet &#x3D; workbook.active sheet.merge_cells(&quot;C1:D2&quot;) \nsheet.merge_cells(start_row&#x3D;7,start_column&#x3D;1,end_row&#x3D;8,end_column&#x3D;3) \nworkbook.save(filename &#x3D; &quot;花园.xlsx&quot;)\n当然，也有“取消合并单元格”，用法一致。\n.unmerge_cells(待合并的格子编号)\n.unmerge_cells(start_row=起始行号，start_column=起始列号，end_row=结束行号，end_column=结束列号)\n\n","slug":"python办公自动化：操作excel","date":"2021-12-08T14:28:43.000Z","categories_index":"python","tags_index":"自动化","author_index":"弦好想断"},{"id":"8a288770ed82450aa993ccbeacfd0367","title":"python中requests使用中文乱码的解决方案","content":"\n 中文乱码处理import requests\n\nurl &#x3D; &quot;http:&#x2F;&#x2F;www.baidu.com&quot;\nr &#x3D; requests.get(url)\n# 自动选择合适的编码方式\nr.encoding &#x3D; r.apparent_encoding\nprint(r.text)\n中文乱码显示正常了！！\n\n有时候，我们还会遇到通过这个操作后无法解决的情况，比如新浪首页的表现：出现这种情况，据说是使用gzip将网页压缩了，必须先对其解码，使用r.content会自动解码：\nimport requests\n\nurl &#x3D; &quot;http:&#x2F;&#x2F;www.sina.com.cn&#x2F;&quot;\nr &#x3D; requests.get(url)\n# 指定编码解码方式\nhtml &#x3D; r.content.decode(&#39;UTF-8&#39;)\n# r.encoding &#x3D; &#39;utf-8&#39;\n其实吧，处理的方式有很多，大家注意一点，那就是看请求的html数据中最前面对的charset设置的是啥！！\n\n html实体编码解析\nIn [1]: s &#x3D; &#39;目前玩的挺好的，就&amp;hellip;&amp;hellip;&lt;br&gt;给四星是因为为什么不是同一个服的就不能进社团😬😬😬😬😬😬😬😬😬😬😬😬😬😬😬😬😬😬😬&#39;\n#可以看到，有个&#39;&amp;hellip;&#39;，这玩意是html实体表示省略号&#39;...&#39;，因此需要进行处理！\nIn [2]: import html\n\nIn [3]: html.unescape(s)\nOut[3]: &#39;目前玩的挺好的，就……&lt;br&gt;给四星是因为为什么不是同一个服的就不能进社团😬😬😬😬😬😬😬😬😬😬😬😬😬😬😬😬😬😬😬&#39;\n也是一种情况吧~\n\n\nhttps://www.cnblogs.com/xieqiankun/p/lxmlencoding.html\n显然这应该是编码的问题，在使用:\netree.HTML(r)\n处理源文件的时候，由于没有指定编码，所以它使用了一个默认编码，从而导致和UTF-8冲突，产生乱码。\n\n经过查阅lxml.etree.HTML的文档，我发现etree.HTML有一个参数是parser,这个参数不是必须的，因此省略以后它就会自动使用一个默认的parser。既然如此，那我手动指定一个：\ncontentTree &#x3D; etree.HTML(r, parser&#x3D;etree.HTMLParser(encoding&#x3D;&#39;utf-8&#39;))\n这里我指定了etree.HTMLParser来作为一个parser,同时，etree.HTMLParser可以接受编码作为参数。于是我指定为UTF-8。\n\nimport requests\nfrom lxml import etree\nimport sys\nreload(sys)\nsys.setdefaultencoding(&quot;utf-8&quot;)\n\nr &#x3D; requests.get(url&#x3D;&#39;http:&#x2F;&#x2F;sports.sina.cn&#x2F;nba&#x2F;rockets&#x2F;2015-10-07&#x2F;detail-ifximrxn8235561.d.html?vt&#x3D;4&amp;pos&#x3D;10&#39;)# 最基本的GET请求\nr.encoding &#x3D; &#39;utf-8&#39;\nr &#x3D; r.content\nprint r","slug":"requests乱码问题解决","date":"2021-12-02T15:30:02.000Z","categories_index":"python","tags_index":"数据分析","author_index":"弦好想断"},{"id":"3cd7e57c6f854790d628f23694417fc5","title":"python办公自动化：pdf和word","content":"python 使用 PyPDF2 和 pdfplumber 操作pdf\nPyPDF2 官网：https://pythonhosted.org/PyPDF2/\nPyPDF2 可以更好的读取、写入、分割、合并 PDF 文件；\npdfplumber 官网：https://github.com/jsvine/pdfplumber\npdfplumber 可以更好地读取 PDF 文件内容和提取 PDF 中的表格；\n查找某个包 anaconda search -t conda pdfplumber下载某个包 anaconda show package\n\npython 提取 PDF 文字内容1）利用 pdfplumber 提取文字import PyPDF2 \nimport pdfplumber \nwith pdfplumber.open(&quot;test.pdf&quot;) as p: \npage &#x3D; p.pages[2] \nprint(page.extract_text())#打印第3页所有文字\n2）利用 pdfplumber 提取表格并写入 excel\nextract_table()：如果一页有一个表格；\nextract_tables()：如果一页有多个表格；import PyPDF2 \nimport pdfplumber \nfrom openpyxl import Workbook \nwith pdfplumber.open(&quot;test.pdf&quot;) as p: \npage &#x3D; p.pages[4] \ntable &#x3D; page.extract_table() \nprint(table) \nworkbook &#x3D; Workbook()\nsheet &#x3D; workbook.active \nfor row in table: \n  if not &quot;&quot;.join([str(i) for i in row]) &#x3D;&#x3D; &quot;&quot;:\n  #将列表中每个元素都连接成一个字符串，如果还是一个空字符串那么肯定就是空行。\n    sheet.append(row)\n  #sheet.append(row) #直接append这里提取出来的表格有很多空行\nworkbook.save(filename &#x3D; &quot;新pdf.xlsx&quot;)\n提取表格这也是一种方式：https://github.com/camelot-dev/camelot\n\n3、PDF 合并及页面的排序和旋转1）分割及合并 pdf① 合并 pdf首先，我们有如下几个文件，可以发现这里共有三个 PDF 文件需要我们合并。同时可以发现他们的文件名都是有规律的(如果文件名，没有先后顺序，我们合并起来就没有意义了。)\nfrom PyPDF2 import PdfFileReader, PdfFileWriter \npdf_writer &#x3D; PdfFileWriter() \nfor i in range(1,len(os.listdir(r&quot;G:\\concat_pdf&quot;))+1):\n  print(i*50+1,(i+1)*50) \n  pdf_reader &#x3D; PdfFileReader(&quot;G:\\concat_pdf\\&#123;&#125;-&#123;&#125;.pdf&quot;.format(i*50+1,(i+1)*50))  \n  #这里是指文件名的格式为51-100，101-150、151-200\n  for page in range(pdf_reader.getNumPages()):\n    pdf_writer.addPage(pdf_reader.getPage(page)) \nwith open(&quot;G:\\concat_pdf\\merge.pdf&quot;, &quot;wb&quot;) as out: \n  pdf_writer.write(out)\n② 拆分 pdf这里有一个“时间序列.pdf”的文件，共 3 页，我们将其每一页存为一个 PDF 文件。\nfrom PyPDF2 import PdfFileReader, PdfFileWriter \npdf_reader &#x3D; PdfFileReader(r&quot;G:\\concat_pdf\\时间序列.pdf&quot;) \nfor page in range(pdf_reader.getNumPages()): \n  pdf_writer &#x3D; PdfFileWriter() \n  pdf_writer.addPage(pdf_reader.getPage(page)) \n  with open(f&quot;G:\\concat_pdf\\\\&#123;page&#125;.pdf&quot;, &quot;wb&quot;) as out: \n    pdf_writer.write(out)\n2）旋转及排序 pdf① 旋转 pdf\n\n.rotateClockwise(90 的倍数)：顺时针旋转 90 度\n.rotateCounterClockwise(90 的倍数)：逆时针旋转 90 度from PyPDF2 import PdfFileReader, PdfFileWriter\npdf_reader &#x3D; PdfFileReader(r&quot;G:\\concat_pdf\\时间序列.pdf&quot;) \npdf_writer &#x3D; PdfFileWriter() \nfor page in range(pdf_reader.getNumPages()): \n  if page % 2 &#x3D;&#x3D; 0: \n    rotation_page &#x3D; pdf_reader.getPage(page).rotateCounterClockwise(90) \n  else: \n    rotation_page &#x3D; pdf_reader.getPage(page).rotateClockwise(90) \n  pdf_writer.addPage(rotation_page) \n  with open(&quot;G:\\concat_pdf\\旋转.pdf&quot;, &quot;wb&quot;) as out: \n    pdf_writer.write(out)\n&quot;&quot;&quot; \n上述代码中，我们循环遍历了这个 pdf，对于偶数页我们逆时针旋转 90°，对于奇数页我\n们顺时针旋转 90°； 注意：旋转的角度只能是 90 的倍数；\n&quot;&quot;&quot;\n② 排序 pdfPDF 文件需要倒序排列，应该怎么做呢？\n\nfrom PyPDF2 import PdfFileReader, PdfFileWriter \npdf_reader &#x3D; PdfFileReader(r&quot;G:\\concat_pdf\\时间序列.pdf&quot;) \npdf_writer &#x3D; PdfFileWriter() \nfor page in range(pdf_reader.getNumPages()-1, -1, -1): \n#这里用到range，很巧妙\n  pdf_writer.addPage(pdf_reader.getPage(page)) \n  with open(&quot;G:\\concat_pdf\\倒序.pdf&quot;, &quot;wb&quot;) as out:\n    pdf_writer.write(out)\n4、pdf 批量加水印及加密、解密1）批量加水印from PyPDF2 import PdfFileReader, PdfFileWriter \nfrom copy import copy \nwater &#x3D; PdfFileReader(r&quot;G:\\concat_pdf\\水印.pdf&quot;) \nwater_page &#x3D; water.getPage(0) \npdf_reader &#x3D; PdfFileReader(r&quot;G:\\concat_pdf\\aa.pdf&quot;) \npdf_writer &#x3D; PdfFileWriter() \nfor page in range(pdf_reader.getNumPages()): \n  my_page &#x3D; pdf_reader.getPage(page) \n  new_page &#x3D; copy(water_page) \n  new_page.mergePage(my_page) \n  pdf_writer.addPage(new_page) \n  with open(&quot;G:\\concat_pdf\\\\添加水印后的 aa.pdf&quot;, &quot;wb&quot;) as out: \n    pdf_writer.write(out) \n&quot;&quot;&quot; \n这里有一点需要注意：进行 pdf 合并的时候，我们希望“水印”在下面,\n文字在上面，因此 是“水印”.mergePage(“图片页”)\n&quot;&quot;&quot;\n2）批量加密、解密\n这里的“解密”，是在知道 pdf 的密码下，去打开 pdf，而不是暴力破解；① 加密 pdf\nfrom PyPDF2 import PdfFileReader, PdfFileWriter \npdf_reader &#x3D; PdfFileReader(r&quot;G:\\concat_pdf\\test.pdf&quot;) \npdf_writer &#x3D; PdfFileWriter() \nfor page in range(pdf_reader.getNumPages()): \npdf_writer.addPage(pdf_reader.getPage(page)) \n# 添加密码\npdf_writer.encrypt(&quot;a123456&quot;)\nwith open(&quot;G:\\concat_pdf\\\\test.pdf&quot;, &quot;wb&quot;) as out: \npdf_writer.write(out)\n② 解密 pdf 并保存为未加密的 pdf\nfrom PyPDF2 import PdfFileReader, PdfFileWriter \npdf_reader &#x3D; PdfFileReader(r&quot;G:\\concat_pdf\\test.pdf&quot;) \n# 解密\npdf pdf_reader.decrypt(&quot;a123456&quot;) \npdf_writer &#x3D; PdfFileWriter() \nfor page in range(pdf_reader.getNumPages()): \n  pdf_writer.addPage(pdf_reader.getPage(page))\n  with open(&quot;G:\\concat_pdf\\未加密.pdf&quot;, &quot;wb&quot;) as out: \n    pdf_writer.write(out)\npython 使用 python-docx 操作 word1、python-docx 库介绍\n该模块儿可以创建、修改 Word（.docx）文件；\n\n此模块儿不属于 python 标准库，需要单独安装；\n\npython-docx 使用官网： https://python-docx.readthedocs.io/en/latest/；\n\n我们在安装此模块儿使用的是 pip install python-docx，但是在导入的时候是 importdocx； \n2、Python 读取 Word 文档内容\n注意：每进行一个操作，必须保存一下，否则等于白做；1）word 文档结构介绍\n\n\n2）python-docx 提取文字和文字块儿① python-docx 提取文字有一个这样的 docx 文件，提取其中的文字\nfrom docx import Document \ndoc &#x3D; Document(r&quot;G:\\concat_word\\test1.docx&quot;) \nprint(doc.paragraphs) \nfor paragraph in doc.paragraphs: \n  print(paragraph.text)\n② python-docx 提取文字块儿\nfrom docx import Document \ndoc &#x3D; Document(r&quot;G:\\concat_word\\test1.docx&quot;) \nprint(doc.paragraphs) \nfor i range(len((doc.paragraphs)):\n#这里按段落进行循环\n  paragraph &#x3D; doc.paragraphs[i] \n  runs &#x3D; paragraph.runs \n  print(runs) \n  for run in paragraph.runs: \n    print(run.text)\n3）利用 Python 向 Word 文档写入内容\nfrom docx import Document \ndoc &#x3D; Document(r&quot;G:\\concat_word\\test1.docx&quot;) \n# print(doc.add_heading(&quot;一级标题&quot;, level&#x3D;1)) 添加一级标题的时候出错，还没有解决！\nparagraph1 &#x3D; doc.add_paragraph(&quot;这是一个段落&quot;) \nparagraph2 &#x3D; doc.add_paragraph(&quot;这是第二个段落&quot;) \ndoc.save(r&quot;G:\\concat_word\\test1.docx&quot;) \n&quot;&quot;&quot; \n添加段落的时候，赋值给一个变量，方便我们后面进行格式调整；\n&quot;&quot;&quot;\n\n读取word文档中的表格内容import docx\n\nfn &#x3D; r&#39;D:\\长恨歌.docx&#39;\ndoc &#x3D; docx.Document(fn)\n\n# 按段落读取全部数据\nfor paragraph in doc.paragraphs:\n    print(paragraph.text)\n\n# 按表格读取全部数据\nfor table in doc.tables:\n    for row in table.rows:\n        for cell in row.cells:\n            print(cell.text)\n\ntable_num &#x3D; len(doc.tables)\n# 获取文档的表格个数\nprint(table_num)\n\ntable_0 &#x3D; doc.tables[0]\n# 选取第一个表\ntable_rows &#x3D; len(table_0.rows)\n# 获取第一个表的行数\nprint(table_rows)\n\ntab &#x3D; doc.tables[0].rows[0].cells[0]\n# 获取第一张表第一行第一列数据\nprint(tab.text)\n\npar &#x3D; doc.paragraphs[2]\n# 读取第三段数据\nprint(par.text)\n批量提取word中表格内容import docx\nimport pandas as pd\nfrom docx import Document #导入库\npath &#x3D; &quot;word2.docx&quot; #文件路径\ndocument &#x3D; Document(path) #读入文件\ntables &#x3D; document.tables #获取文件中的表格集\ntable &#x3D; tables[0]#获取文件中的第一个表格\n\nfor table in tables:\n    columns &#x3D; [table.cell(0,c).text for c in range(len(table.columns))]#获取表头 \n#     print(columns)\n    values &#x3D; []\n    for i in range(1,len(table.rows)):#从表格第二行开始循环读取表格数据\n        result &#x3D; [table.cell(i,c).text for c in range(len(table.columns))]# 自动获取每一行的数据\n        #cell(i,0)表示第(i+1)行第1列数据，以此类推\n#         print(result)\n        values.append(result)\n    print(values)\n    print(columns)\n    print(pd.DataFrame(data &#x3D; values,columns&#x3D;columns))\n在操作word这块感觉并不怎么实用，等遇到问题了再加，也可以参考https://juejin.cn/post/6868073137263607821\n\n","slug":"python办公自动化：pdf和word","date":"2021-08-26T06:16:31.000Z","categories_index":"python","tags_index":"自动化","author_index":"弦好想断"},{"id":"ce3f6facdcd7d14d49266cce6ca90c5e","title":"sql数据分析：自动化报表，多场景持续更新","content":"建表CREATE TABLE &#96;cd_20210414&#96; (\n  &#96;id&#96; int(11) NOT NULL AUTO_INCREMENT,\n  &#96;platform&#96; varchar(10) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT &#39;&#39; COMMENT &#39;平台&#39;,\n  &#96;platform_id&#96; varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT &#39;0&#39; COMMENT &#39;平台id 即storeid&#39;,\n  &#96;product_id&#96; varchar(255) CHARACTER SET utf8mb4 DEFAULT &#39;0&#39; COMMENT &#39;商品id&#39;,\n  &#96;barcode&#96; varchar(50) CHARACTER SET utf8mb4 DEFAULT &#39;0&#39; COMMENT &#39;商品upc编码&#39;,\t\n  &#96;sort_id&#96; int(11) DEFAULT &#39;0&#39; COMMENT &#39;商品排序&#39;,\n  &#96;title&#96; varchar(255) COLLATE utf8mb4_general_ci DEFAULT &#39;&#39; COMMENT &#39;商品名称&#39;,\n  &#96;promotion_price&#96; float(10,2)  DEFAULT null COMMENT &#39;促销价&#39;,\n  &#96;full_price&#96;  float(10,2)  DEFAULT null COMMENT &#39;商品原价&#39;,\n  &#96;product_month_sale&#96; varchar(10) DEFAULT null COMMENT &#39;月销&#39;,\n  &#96;promotion&#96; varchar(255)  CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci COMMENT &#39;促销活动&#39;,\n  &#96;image_url&#96; text CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci,\n  &#96;catname1&#96; varchar(50) CHARACTER SET utf8mb4 DEFAULT &#39; &#39;,\n&#96;brand&#96; varchar(10) COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT &#39;品牌&#39;,\n  &#96;time&#96; datetime DEFAULT CURRENT_TIMESTAMP,\n  PRIMARY KEY (&#96;id&#96;),\n  KEY &#96;a&#96; (&#96;platform&#96;,&#96;platform_id&#96;)\n) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8mb4 COLLATE&#x3D;utf8mb4_general_ci;\n新增标签列，加索引alter table cd_20210414 add COLUMN crawler_id VARCHAR(30);\nalter table cd_20210414 add COLUMN detail_full_price float(12,2);\nalter table cd_20210414 add index a(sku);\nalter table cd_20210414 add index b(platform,platform_id);\n查询当月日期及对应上月日期mysql\n#当月日期\nselect DATE_ADD(DATE_SUB(CURDATE(),INTERVAL 1 DAY),interval -day(DATE_SUB(CURDATE(),INTERVAL 1 DAY))+1 day),\nDATE_SUB(CURDATE(),INTERVAL 1 DAY);\n#对应上月日期\nselect DATE_SUB(DATE_ADD(DATE_SUB(CURDATE(),INTERVAL 1 DAY),interval -day(DATE_SUB(CURDATE(),INTERVAL 1 DAY))+1 day),INTERVAL 1 MONTH),\nDATE_SUB(DATE_SUB(CURDATE(),INTERVAL 1 DAY),INTERVAL 1 MONTH);\n\nhive\n#昨天\nselect date_format(date_sub(current_date(),1), &#39;yyyyMMdd&#39;);\n#当月月初\nselect concat(from_unixtime(unix_timestamp(), &#39;yyyyMM&#39;),&#39;01&#39;);\n#上月同期\nselect date_format(add_months(from_unixtime(unix_timestamp(), &#39;yyyy-MM-dd&#39;),-1),&#39;yyyyMMdd&#39;);\n#昨天环比上月同期\nselect date_format(date_sub(add_months(from_unixtime(unix_timestamp(), &#39;yyyy-MM-dd&#39;),-1),1),&#39;yyyyMMdd&#39;);\n#上月月初\nselect concat(date_format(add_months(from_unixtime(unix_timestamp(), &#39;yyyy-MM-dd&#39;),-1),&#39;yyyyMM&#39;),&#39;01&#39;);\n\n每个部门薪水最高的员工(包含部门名称)\n员工表和部门表进行连接，对部门id进行组内分组根据薪资降序排序，这里使用rank()并列也算\n筛选排序序号为1的部门，并查询员工薪资\n\nselect * \nfrom \n    (SELECT \n    employee_id\n    ,first_name\n    ,e.department_id\n    ,department_name\n    ,salary \n    ,rank() over(partition by department_id order by salary desc) as salary_rank \n    FROM &#96;employees&#96; e \n    inner join \n    &#96;departments&#96; d \n    on e.department_id &#x3D; d.department_id\n    ) a \nwhere a.salary_rank&#x3D;1;\n众数、平均数、中位数-- 求员工工资的众数\n\nSELECT salary,count(1) AS cnt\nFROM employees\nGROUP BY salary\nHAVING count(*) &gt;&#x3D; ALL(SELECT COUNT(*) FROM employees GROUP BY salary)\n\n-- 求员工工资的平均数\nselect AVG(salary) from employees\n\nselect sum(salary)&#x2F;count(0) as avg_salary \nfrom employees \n\n-- 求员工工资的中位数\n-- 中位数定义：将数从小到大排列，若总数为奇数，取中间位置的数值。若总数为偶数，取中间位置两个数的平均值\n\nselect avg(emp_salary)\nfrom\n(#排位次\nselect salary,\n row_number() over(order by salary) as rn,\ncount(*) over() as n\nfrom employees\n) t \nwhere rn in (floor(n&#x2F;2)+1,if(mod(n,2) &#x3D; 0,floor(n&#x2F;2),floor(n&#x2F;2)+1))\n\n上、下四分位数\n全部玩家人数的中位数、上下四分位数\n再根据人数总量细拆 排序好的玩家在线时长表\n\nselect round(count(distinct user_id)&#x2F;4) as 下四分位数,\nround(count(distinct user_id)&#x2F;2) as 中位数,\nround(count(distinct user_id)&#x2F;4*3) as 上四分位数\nfrom tap_fun_test;\n下四分位数：207234 中位数：414467 上四分位数：621701\nSELECT min(avg_online_minutes) 最小值,\n(select avg_online_minutes from tap_fun_test ORDER BY avg_online_minutes LIMIT 207233,1) as 下四分位数,\n(select avg_online_minutes from tap_fun_test ORDER BY avg_online_minutes LIMIT 414466,1) as 中位数,\n(select avg_online_minutes from tap_fun_test ORDER BY avg_online_minutes LIMIT 621700,1) as 上四分位数,\nmax( avg_online_minutes) 最大值\nFROM &#96;tap_fun_test&#96;\t\n最小值0.0,下四分位数:0.5,中位数:1.666667，上四分位数：5，最大值：1605.833333\n\n截至当前，每个用户已经连续签到的天数\n查出最后一次不登录的日期（即未登录时间的最大值）\n与当前日期进行比较，二者差值为几就是连续登录几天\n\nselect \nuser_id ,\nmax(date),\nDATEDIFF(&#39;2021-02-19&#39;,max(date)) as max_con_days \nfrom user_attendence \nwhere is_sign &#x3D; 0 \ngroup by user_id;\n计算有史以来用户最大连续签到天数；\n对用户分组，按日期进行row_number()over()排序，排序序号为rank;（一个用户一天只能签到一次）\n如果日期与序号的差值为相等，按这个差值进行分组并计数，取最大值\n\nselect \nuser_id \n,max(次数) &#96;最大连续登录天数&#96;\nfrom \n    (select user_id \n    ,subdate(a.&#96;date&#96;,a.rn) diff \n    ,count(*) 次数\n    from \n        (select \n        user_id \n        ,date,\n        row_number() over(partition by user_id order by date asc) rn\n        from user_attendence  \n        where is_sign &#x3D; 1\n        ) a \n    group by user_id,diff\n    ) b \ngroup by user_id;\n用户最大连续购买天数及次数最里面子查询先对日期进行聚合，将购买次数求和，然后类比连续签到\nselect \nuser_id \n,max(count_days) &#96;天数&#96;\n,sum(sum_user_counts) &#96;次数&#96;\nfrom \n    (select user_id \n    ,subdate(a.&#96;date&#96;,a.rn) diff \n    ,count(*) count_days\n\t,sum(user_counts) sum_user_counts\n    from \n        (select \n        user_id \n        ,&#96;date&#96;\n        ,row_number() over(partition by user_id order by &#96;date&#96; asc) rn\n\t\t,user_counts\n        from (\n\t\t\t\tselect user_id\n\t\t\t\t,DATE_FORMAT(pur_dt,&quot;%Y-%m-%d&quot;) &#96;date&#96;\n\t\t\t\t,count(&#96;month&#96;) user_counts \n\t\t\t\tfrom cd_now \n\t\t\t\tgroup by user_id,DATE_FORMAT(pur_dt,&quot;%Y-%m-%d&quot;)\n\t\t\t\t) m \n        ) a \n    group by user_id,diff\n    ) b \ngroup by user_id;\n\n某一天以及近七天新增用户数\n指定当前日期为1998-02-10，使用date_sub确定前七天日期\n使用if判定用户是否当日注册，DISTINCT进行去重\n\nset @date_day &#x3D; &quot;1998-02-10&quot;;\n\nselect \ncount(DISTINCT if(DATE_FORMAT(pur_dt,&quot;%Y-%m-%d&quot;)&#x3D;@date_day,user_id,null)) as new_id\n,count(DISTINCT user_id) as user_7\n,count(DISTINCT user_id)&#x2F;7 as avg7_id\nfrom \ncd_now \nwhere \nDATE_FORMAT(pur_dt,&quot;%Y-%m-%d&quot;) between DATE_SUB(@date_day,INTERVAL 7 day) and @date_day\n支付金额在前 20%的用户-- 问题：求支付金额在前 20%的用户\nselect \na.user_name \n,a.sum_amount \nfrom \n(select \nuser_name \n,sum(pay_amount) sum_amount \n,ntile(5) over(order by sum(pay_amount) desc) sum_amount_rank \n-- ,sum(pay_amount) over(order by user_name) cumsum\n-- ,round(sum(pay_amount) over(order by user_name)&#x2F;sum(pay_amount) over(),4) cumsum_rate\nfrom user_sales_table \ngroup by user_name ) a \nwhere a.sum_amount_rank &#x3D; 1 \n每月最受欢迎的前三名select \n*\nfrom \n\t(select \n\ta.品牌\n\t,a.mon\n\t,a.num\n\t,row_number()over(PARTITION by a.mon order by a.num desc) as num_rank\t\n\tfrom \n\t\t(SELECT \n\t\t*\n\t\t,date_format(日期,&quot;%Y-%m-01&quot;) mon\n\t\t,count(orser_id) num\n\t\tFROM &#96;alcohol&#96;\n\t\tgroup by \n\t\tdate_format(日期,&quot;%Y-%m-01&quot;) ,品牌) a\n\t) b \nwhere b.num_rank&lt;4 \norder by b.mon asc \n用户留存\n用户第一次购买时间和最后一次购买时间，根据user_id进行连接，计算购买时间间隔\n使用case when 进行判定\n\nselect \n(case when t3.day_value&#x3D;1 then &quot;次日留存&quot;\nwhen t3.day_value &#x3D; 3 then &quot;三日留存&quot;\nwhen t3.day_value &#x3D; 7 then &quot;七日留存&quot;\nelse &quot;其他&quot;\nend\n) as type\n,count(t3.user_id) &quot;用户个数&quot;\nfrom \n\t(select \n\tt1.user_id\n\t,t1.first_time\n\t,t2.last_time\n\t,datediff(t2.last_time,t1.first_time) day_value\n\tfrom\n\t\t(select \n\t\tuser_id\n\t\t,date(min(pur_dt)) first_time\n\t\tfrom cd_now \n\t\tgroup by \n\t\tuser_id) t1\n\t\tleft join \n\t\t(select \n\t\tuser_id\n\t\t,date(max(pur_dt)) last_time\n\t\tfrom cd_now\n\t\tgroup by \n\t\tuser_id\n\t\t) t2\n\ton t1.user_id&#x3D;t2.user_id\n\t) t3\ngroup by \n(case when t3.day_value&#x3D;1 then &quot;次日留存&quot;\nwhen t3.day_value &#x3D; 3 then &quot;三日留存&quot;\nwhen t3.day_value &#x3D; 7 then &quot;七日留存&quot;\nelse &quot;其他&quot;\nend\n) \n产品留存一共三个字段：下单日期，产品名称，用户id；\n前7天的购买用户作为新客，后24天无购买的为流失；后24天有购买为复购：购买相同产品的为留存，购买其他的为替换；\n先查total全量数据temp1，然后前7天购买和后24天购买数据，接着依次查询新客、复购、留存。\nwith temp1 as (\n\tSELECT \n\tpt\n\t,spec_name\n\t,user_id\n\tFROM &#96;order_item&#96; \n\twhere pt between &#39;20211001&#39; and &#39;20211031&#39; \n),\ntemp07 as (\n\tselect \n\tpt\n\t,spec_name\n\t,user_id\n\tfrom temp1\n\twhere pt between &#39;20211001&#39; and &#39;20211007&#39;\n),\ntemp24 as (\n\tselect \n\tpt\n\t,spec_name\n\t,user_id\n\tfrom temp1\n\twhere pt between &#39;20211008&#39; and &#39;20211031&#39;\n),\ntemp_xinke as (\n\tselect \n\tspec_name\n\t,count(distinct user_id) &#96;user_xinke&#96;\n\tfrom temp07\n\tgroup by spec_name\n),\ntemp_fugou as (\n\tselect \n\ttemp07.spec_name \n\t,count(distinct temp07.user_id) &#96;user_fugou&#96;\n\tfrom temp07 \n\tinner join temp24\n\ton temp07.user_id&#x3D;temp24.user_id \n\tgroup by temp07.spec_name\n),\ntemp_liucun as (\n\tselect \n\ttemp07.spec_name \n\t,count(distinct temp07.user_id) &#96;user_liucun&#96;\n\tfrom temp07 \n\tinner join temp24\n\ton temp07.user_id&#x3D;temp24.user_id and temp07.spec_name&#x3D;temp24.spec_name \n\tgroup by temp07.spec_name\n),\ntemp_total as (\n\tselect \n\ttemp_xinke.spec_name &#96;产品名称&#96;\n\t,temp_xinke.&#96;user_xinke&#96; &#96;新客人数&#96;\n\t,temp_fugou.&#96;user_fugou&#96; &#96;复购人数&#96;\n\t,temp_liucun.&#96;user_liucun&#96; &#96;留存人数&#96;\n\t,temp_xinke.&#96;user_xinke&#96;-temp_fugou.&#96;user_fugou&#96; &#96;流失人数&#96;\n\t,temp_fugou.&#96;user_fugou&#96;-temp_liucun.&#96;user_liucun&#96; &#96;替换人数&#96;\n\tfrom temp_xinke \n\tinner join temp_fugou on temp_xinke.spec_name&#x3D; temp_fugou.spec_name\n\tinner join temp_liucun on temp_xinke.spec_name &#x3D; temp_liucun.spec_name\n) select * from temp_total;\n\n\n\n新老客&amp;复购with temp1 as ( # 1、找出每个用户第一次下单的时间和年月\nselect user_id,min(pur_dt),date_format(min(pur_dt),&#39;%Y-%m&#39;) &#96;年月&#96;\nfrom cd_now \ngroup by user_id \n),\n temp2 as(# 2、找出每月的新客户数目 \nselect user_id,&#96;年月&#96;,count(user_id) as &#96;新客户数&#96; \nfrom \n temp1 \ngroup by &#96;年月&#96; \n ),\n temp3 as( # 3.1、找出当月有复购的新客户数目，第一步找出用户在第一次下单的那个月的购买次数\nselect n.user_id,count(n.order_id) as &#96;次数&#96;,&#96;年月&#96; \nfrom cd_now n \n inner join temp1 \non n.user_id &#x3D; temp1.user_id and temp1.&#96;年月&#96; &#x3D; date_format(pur_dt,&quot;%Y-%m&quot;)\ngroup by temp1.user_id\n ),\n temp4 as ( # 3.2、找出当月有复购的新客户数目,第二步是将有复购的新客筛选出来（购买次数&gt;&#x3D;2）\nselect &#96;年月&#96;,temp3.user_id,count(temp3.user_id) as &#96;有复购的新客户数目&#96;\nfrom temp3 \nwhere &#96;次数&#96;&gt;&#x3D;2\ngroup by temp3.&#96;年月&#96;\n ),\n temp5 as ( # 计算复购率\nselect temp2.&#96;年月&#96;,temp2.&#96;新客户数&#96;,ifnull(temp4.&#96;有复购的新客户数目&#96;,0) &#96;老客户数&#96;,\n ifnull(temp4.&#96;有复购的新客户数目&#96;&#x2F;temp2.&#96;新客户数&#96;,0) &#96;复购率&#96;\n from temp2\n left join temp4\non temp2.&#96;年月&#96; &#x3D; temp4.&#96;年月&#96;\n ) select * from temp5\nrfm模型-- 用户id,下单次数,最近下单时间,顾客实付,下单间隔,实付客单,rfm类型,\nselect \na.user_id\n,a.&#96;下单次数&#96;\n,a.&#96;最近下单时间&#96;\n,a.&#96;顾客实付&#96;\n,a.&#96;下单间隔&#96;\n,a.&#96;实付客单&#96;\n,case \nwhen a.&#96;下单间隔&#96; &gt; 45 and a.&#96;下单次数&#96; &lt;&#x3D; 1 and a.&#96;实付客单&#96; &lt;&#x3D;50 then &#39;111&#39; \nwhen a.&#96;下单间隔&#96; &gt; 45 and a.&#96;下单次数&#96; &lt;&#x3D; 1 and a.&#96;实付客单&#96; &gt;50 then &#39;112&#39; \nwhen a.&#96;下单间隔&#96; &gt; 45 and a.&#96;下单次数&#96; &gt; 1 and a.&#96;实付客单&#96; &lt;&#x3D;50 then &#39;121&#39; \nwhen a.&#96;下单间隔&#96; &lt;&#x3D; 45 and a.&#96;下单次数&#96; &lt;&#x3D; 1 and a.&#96;实付客单&#96; &lt;&#x3D;50 then &#39;211&#39; \nwhen a.&#96;下单间隔&#96; &lt;&#x3D; 45 and a.&#96;下单次数&#96; &gt; 1 and a.&#96;实付客单&#96; &lt;&#x3D;50 then &#39;221&#39; \nwhen a.&#96;下单间隔&#96; &lt;&#x3D; 45 and a.&#96;下单次数&#96; &lt;&#x3D; 1 and a.&#96;实付客单&#96; &gt; 50 then &#39;212&#39; \nwhen a.&#96;下单间隔&#96; &lt;&#x3D; 45 and a.&#96;下单次数&#96; &gt; 1 and a.&#96;实付客单&#96; &gt; 50 then &#39;222&#39; \nwhen a.&#96;下单间隔&#96; &gt; 45 and a.&#96;下单次数&#96; &gt; 1 and a.&#96;实付客单&#96; &gt; 50 then &#39;122&#39; \nend as &#39;rfm_type&#39;\nfrom \n(select \nuser_id \n,count(pur_dt) &#96;下单次数&#96;\n,date_format(max(pur_dt),&quot;%Y-%m-%d&quot;) &#96;最近下单时间&#96;\n,sum(pur_amount) &#96;顾客实付&#96;\n,datediff(&quot;1998-03-31&quot;,date_format(max(pur_dt),&quot;%Y-%m-%d&quot;)) &#96;下单间隔&#96;\n,avg(pur_amount) as &#96;实付客单&#96;\nfrom supermanzwg.cd_now \nwhere date_format(month,&quot;%Y-%m-%d&quot;) between &quot;1998-01-01&quot; and &quot;1998-03-01&quot;\ngroup by \nuser_id ) a ;\n\n用户行为\n有订单事务表、收藏事务表,要求：请用一句SQL取出所有用户对商品的行为特征，特征分为已购买、\n\n购买未收藏、收藏未购买、收藏且购买\n# 数据准备\ncreate table redbk_orders(\n &#96;id&#96; int(5),\n &#96;user_id&#96; varchar(10),\n &#96;item_id&#96; int(5),\n &#96;par_time&#96; varchar(30),\n &#96;item_num&#96; int(5)\n);\ninsert into redbk_orders values(1,&#39;001&#39;,&#39;201&#39;,&#39;2018-08-31 00:00:01&#39;,1);\ninsert into redbk_orders values(2,&#39;002&#39;,&#39;203&#39;,&#39;2018-09-02 12:00:02&#39;,2);\ninsert into redbk_orders values(3,&#39;003&#39;,&#39;203&#39;,&#39;2018-09-01 00:00:01&#39;,1);\ninsert into redbk_orders values(4,&#39;003&#39;,&#39;203&#39;,&#39;2018-09-04 09:10:30&#39;,1);\ncreate table redbk_favorites(\n &#96;id&#96; int(5),\n &#96;user_id&#96; varchar(10),\n &#96;item_id&#96; INT(5),\n &#96;fav_time&#96; varchar(30)\n);\ninsert into redbk_favorites values(1,&#39;001&#39;,201,&#39;2018-08-31 00:00:01&#39;);\ninsert into redbk_favorites values(2,&#39;002&#39;,202,&#39;2018-09-02 12:00:02&#39;);\ninsert into redbk_favorites values(3,&#39;003&#39;,204,&#39;2018-09-01 00:00:01&#39;);\nselect \no.user_id \n,o.item_id \n,1 as &quot;已购买&quot; \n,case when f.item_id is null then 1 else 0 end as &quot;购买未收藏&quot;\n,0 as &quot;收藏未购买&quot; \n,case when f.item_id is not null then 1 else 0 end as &quot;收藏且购买&quot;\nfrom myemployees.redbk_orders o \nleft join myemployees.redbk_favorites f \non o.user_id &#x3D; f.user_id and o.item_id &#x3D; f.item_id \nwhere o.user_id is not null \nunion \nselect \no.user_id \n,o.item_id \n,case when o.item_id is not null then 1 else 0 end as &quot;已购买&quot; \n,0 as &quot;购买未收藏&quot;\n,case when o.item_id is null then 1 else 0 end as &quot;收藏未购买&quot; \n,case when o.item_id is not null then 1 else 0 end as &quot;收藏且购买&quot;\nfrom myemployees.redbk_favorites f \nleft join myemployees.redbk_orders o \non o.user_id &#x3D; f.user_id and o.item_id &#x3D; f.item_id\nwhere o.user_id is not null;\n某购物APP最近上线了一个新功能，用户签到后可以跳转到大转盘抽奖，抽奖获得的奖金可以抵消购物的费用，以此来培养用户使用app的习惯。\n\n现有一张用户行为表user_log，主要字段如下，记录了用户在app上的所有行为日志，即何人user_id在何时event_time进行了什么操作event_id。\n\n\n贡献度-累计求和\n计算各个用户的消费金额综合\n对用户消费金额进行累加，并计算累计占比，就是贡献度select \nt.*\nfrom\n\t(select \n\tuser_id \n\t,round(amount,2) amount\n\t,round(sum(amount)over(order by amount desc) ,2) cum_amount\n\t,round(sum(amount)over(order by amount desc)&#x2F;(select sum(pur_amount) from cd_now),4) as cum_rate\n\tfrom \n\t\t(select \n\t\tuser_id \n\t\t,sum(pur_amount) amount\n\t\tfrom \n\t\tcd_now \n\t\twhere pur_amount &gt;0\n\t\tgroup by \n\t\tuser_id ) user_table\n\t) t\nwhere t.cum_rate&lt;0.8\n\n电商类\n商品活动流水表，表名为event，字段：goods_id， time；\n\n求参加活动次数最多的商品的最近一次参加活动的时间\n\n\n数据准备：\n#创建 event 表\nCREATE TABLE &#96;event&#96; (\n &#96;goods_id&#96; varchar(255),\n &#96;time&#96; varchar(255)\n );\n#插入数据\nINSERT INTO &#96;event&#96; VALUES (&#39;可口可乐&#39;, &#39;2021-02-22&#39;);\nINSERT INTO &#96;event&#96; VALUES (&#39;雪碧&#39;, &#39;2021-03-01&#39;);\nINSERT INTO &#96;event&#96; VALUES (&#39;可口可乐&#39;, &#39;2021-03-04&#39;);\nINSERT INTO &#96;event&#96; VALUES (&#39;东鹏特饮&#39;, &#39;2021-03-06&#39;);\nINSERT INTO &#96;event&#96; VALUES (&#39;雪碧&#39;, &#39;2021-03-07&#39;);\nINSERT INTO &#96;event&#96; VALUES (&#39;红牛&#39;, &#39;2021-03-07&#39;);\nINSERT INTO &#96;event&#96; VALUES (&#39;东鹏特饮&#39;, &#39;2021-03-08&#39;);\nINSERT INTO &#96;event&#96; VALUES (&#39;雪碧&#39;, &#39;2021-03-08&#39;);\n\n-- 求参加活动次数最多的商品的最近一次参加活动的时间\n-- 统计每种商品参加活动的次数，以及最近一次参与活动的时间\nselect \n*\nfrom \n(select \ngoods_id\n,count(*) goods_num\n,max(time) max_time\nfrom event \ngroup by goods_id) a \norder by goods_num desc limit 1\n\n\n新老客 trans和profile\n\n-- 请计算每一类客户在2019年每月产生的销售(即购买金额大于0，及发生购买的人数(客户类型分为:新客，老客；新客:2019年产生第一次购买；老客:2019年之前已经购买过)\n-- 先分清新老客,在分类统计\nselect \nmonth(purchase_date) &#96;月份&#96;\n,customer_type  \n,sum(Quantity*Unit_price) &#96;金额&#96;\n,count(*)\nfrom \n(select \nt.*\n,case when year(p.FIRST_PUR_DATE)&#x3D;2019 then &#39;新客&#39; else &#39;老客&#39; end as &#96;customer_type&#96;\nfrom &#96;trans&#96; t \nleft join &#96;profile&#96; p\non t.Customer_ID &#x3D; p.Customer_ID\nwhere year(purchase_date)&#x3D;2019) a\ngroup by month(purchase_date),customer_type;\n\n-- 现要给2019年新客发送A、B小样，线上新客发放A小样，线下新客发放B小样，请编写程序抽取相应的名单\n-- 字段 COUNTERID : offline 线下，online 线上\nselect \n*\n,case when COUNTER_ID like &#39;online%&#39; then &#39;A&#39; else &#39;B&#39; end as &#39;demo_type&#39;\nfrom \n(select \nt.*\n,case when year(p.FIRST_PUR_DATE)&#x3D;2019 then &#39;新客&#39; else &#39;老客&#39; end as &#96;customer_type&#96;\nfrom &#96;trans&#96; t \nleft join &#96;profile&#96; p\non t.Customer_ID &#x3D; p.Customer_ID\nwhere year(purchase_date)&#x3D;2019) a\nwhere &#96;customer_type&#96;&#x3D;&#39;新客&#39;;\n\n相邻座位互换create TABLE \n&#96;Seat&#96; (\n\t&#96;id&#96; VARCHAR(255),\n\t&#96;employee&#96; VARCHAR(255)\n);\ninsert INTO &#96;Seat&#96; VALUES (&#39;1&#39;, &#39;Jack&#39;);\nINSERT INTO &#96;Seat&#96; VALUES (&#39;2&#39;, &#39;Scott&#39;);\nINSERT INTO &#96;Seat&#96; VALUES (&#39;3&#39;, &#39;Emery&#39;);\nINSERT INTO &#96;Seat&#96; VALUES (&#39;4&#39;, &#39;Green&#39;);\nINSERT INTO &#96;Seat&#96; VALUES (&#39;5&#39;, &#39;Linda&#39;);\nINSERT INTO &#96;Seat&#96; VALUES (&#39;6&#39;, &#39;Jane&#39;);\n\n#查询每两个相邻的座位互换（可以看作是两两相邻奇数和偶数呼唤，奇数下移，偶数上移）\nselect \n(case \nwhen mod(id,2)!&#x3D;0 and id!&#x3D;a.counts then id+1 \nwhen mod(id,2)!&#x3D;0 and id&#x3D;a.counts then id \nelse id-1 end) as id \n,employee\nfrom \n&#96;Seat&#96;,(select count(*) counts from &#96;Seat&#96;) a\norder by id;\n\n","slug":"sql数据分析：自动化报表，多场景更新","date":"2021-08-06T15:19:59.000Z","categories_index":"sql","tags_index":"数据分析","author_index":"弦好想断"},{"id":"f671959f062d49d2d4345cd4aa269a83","title":"python连接mysql:读取、写入、更新、删除","content":"1、连接读取数据第一种：用pymysql连接#安装pymysql\nconda install pymysql\n#或者\npip install pymysql\nimport pymysql\n#创建数据库连接，依次是主机名，用户名，密码，要打开的数据库，端口号和编码类型\ndef get_conn():\n    conn &#x3D; pymysql.connect(\n        host&#x3D;&quot;****&quot;,\n        user&#x3D;&quot;****&quot;,\n        password&#x3D;&quot;****&quot;,\n        db&#x3D;&quot;****&quot;,\n        charset&#x3D;&quot;utf8&quot;,\n        port&#x3D;3306,\n    )\n    # 创建游标：\n    cursor &#x3D; conn.cursor()\n    return conn, cursor\ndef close_conn(conn, cursor):\n    if cursor:\n        cursor.close()\n    if conn:\n        conn.close()\ndef query(sql, *args):\n    &#39;&#39;&#39;\n    :param sql:\n    :param args:\n    :return:返回结果，提取数据，返回的data是一个二维元组，((),())形式；\n    &#39;&#39;&#39;\n    conn, cursor&#x3D; get_conn()\n    cursor.execute(sql)\n    res &#x3D; cursor.fetchall() # 获取结果\n    close_conn(conn, cursor)\n    return res\n#返回的是所有行在对应列的值\n\n# connect.commit()\n#如果对数据进行了增删改查的话，执行该语句，相当于把对数据库的操作提交上去，否则修改不会生效\nclose_conn(conn, cursor)#当然要有关闭游标和数据库连接的习惯\n\n\nfetchone与fetchall的理解；举个例子:cursor是我们连接数据库的实例fetchone()的使用:返回值是单个的元组,也就是一行记录,如果没有结果,那就会返回null\n\ncursor.execute(f&quot;select username,password,nickname from user where id&#x3D;&#123;input&#125;&quot;)\nresult&#x3D;cursor.fetchone();  \n此时我们可以通过result[0],result[1],result[2]得到username,password,nickname\nfetchall()的使用:返回值是多个元组,即返回多个行记录,如果没有结果,返回的是()\ncursor.execute(select * from user)\nresult&#x3D;cursor.fetchall();此时select得到的可能是多行记录,那么我们通过fetchall得到的就是多行记录,是一个二维元组\n((username1,password1,nickname1),(username2,password2,nickname2),(username3,password3,nickname))\n第二种：pandas内置的read_sql  需要安装sqlalchemy,但是可以DataFrame的形式读出来，方便多了\nconda install sqlalchemy\n#或者\npip install sqlalchemy\nimport pandas as pd\nfrom sqlalchemy import create_engine\ndef reader_sql(query,db&#x3D;&#39;myemployees&#39;):\n    sql &#x3D; query\n    engine &#x3D; create_engine(f&#39;mysql+pymysql:&#x2F;&#x2F;root:&#123;pwd&#125;@localhost:3306&#x2F;&#123;db&#125;?charset&#x3D;utf8&#39;)\n    #格式一点不能错，依次是用户名，密码（###），主机名，端口号，要连接的数据库，指定编码\n    df &#x3D; pd.read_sql(sql,engine)\n    return df\ndf_departments &#x3D; reader_sql(&#39;select  * from departments&#39;)#这里输出的是一个dataframe\n2、写入数据第一种：to_sql写入result.to_sql(name&#x3D;&#39;newtable&#39;,con&#x3D;engine,if_exists&#x3D;&#39;append&#39;,index&#x3D;False)\n#这里的index如果为True的话也会报错，数据库中没有索引列（建表的时候没有预留索引列的位置）\n#默认参数是fail，如果这张表本来存在的话，操作就会fail失败掉\n#不建议这种直接建表操作，这样的表中字段类型会有变化，不符合原先数据要求\n#建议在workbench中先create table并把所有字段的类型定义好，在使用to_sql进行写入\n\n新建表设置好字段类型或者用cursor.execute执行建表语句后，就可以用to_sql写入了\n\nresult.to_sql(name&#x3D;&#39;new_table2&#39;,con&#x3D;engine,if_exists&#x3D;&#39;append&#39;,index&#x3D;False)\n#这里注意新建表的时候一定要把各个字段的类型搞准确，编码搞清楚不然没意识到出个错，很难受\n#如果重复执行这行代码的话，会导致插入的数据成倍数增加，因为你传入的append参数，会在原数据上接着添加\n\ndel result[&#39;department_name&#39;]#删掉一列后再进行写入\nresult.to_sql(name&#x3D;&#39;new_table2&#39;,con&#x3D;engine,if_exists&#x3D;&#39;append&#39;,index&#x3D;False)\n#如果建表时在NN列未勾选上的话，不会报错，会发现原本的值数量多了一倍，且新增的数据中的department_name列均为空值\n#但如果建表时在NN列勾选上的话，表示该字段不允许为空值，就会报错\n#还有如果写入的数据字段多了，与建表时给定的字段数量不符也会报错\n\n将excel中分sheet写入数据库\n\nimport pymysql\nimport pandas as pd\nfrom sqlalchemy import create_engine\nimport xlrd\nfile &#x3D; r&#39;C:\\Users\\sofia.xlsx&#39;\n#分sheet写入数据库\n# 然后调用df.to_sql()函数将dataframe数据写入：\n\n&quot;&quot;&quot; 打开excel表格&quot;&quot;&quot;\nworkbook &#x3D; xlrd.open_workbook(file)\nsheet_names &#x3D; workbook.sheet_names()\nfor i in sheet_names :\n    data &#x3D; pd.read_excel(file,sheet_name &#x3D; i,index &#x3D; False,encoding&#x3D;&#39;utf-8&#39;)\n    data.to_sql(i,con&#x3D;engine,if_exists&#x3D;&#39;replace&#39;,index&#x3D;False)\n\n\npd.read_sql()介绍\n\npandas.read_sql(sql, con, index_col&#x3D;None, coerce_float&#x3D;True, params&#x3D;None, parse_dates&#x3D;None, columns&#x3D;None, chunksize&#x3D;None)\n各参数意义：\nsql:SQL命令字符串\ncon：连接sql数据库的engine，一般可以用SQLalchemy或者pymysql之类的包建立\nindex_col: 选择某一列作为index\ncoerce_float:非常有用，将数字形式的字符串直接以float型读入\nparse_dates:将某一列日期型字符串转换为datetime型数据，与pd.to_datetime函数功能类似。可以直接提供需要转换的列名以默认的日期形式转换，也可以用字典的格式提供列名和转换的日期格式，比如&#123;column_name: format string&#125;（format string：&quot;%Y:%m:%H:%M:%S&quot;）。\ncolumns:要选取的列。一般没啥用，因为在sql命令里面一般就指定要选择的列了\nchunksize：如果提供了一个整数值，那么就会返回一个generator，每次输出的行数就是提供的值的大小。\n##read_sql本质上是read_sql_table、read_sql_query的统一方式。\n三者都return返回DataFrame。\nread_sql_table\nRead SQL database table into a DataFrame.\nread_sql_query\nRead SQL query into a DataFrame.\nto_sql主要有以下几个参数：\n\n  name: 输出的表名\n  con: 与read_sql中相同\n  if_exits： 三个模式：fail，若表存在，则不输出；replace：若表存在，覆盖原来表里的数据；append：若表存在，将数据写到原表的后面。默认为fail\n  index：是否将df的index单独写到一列中\n  index_label:指定列作为df的index输出，此时index为True\n  chunksize： 同read_sql\ndtype: 指定列的输出到数据库中的数据类型。字典形式储存：{column_name: sql_dtype}。常见的数据类型有sqlalchemy.types.INTEGER(), sqlalchemy.types.NVARCHAR(),sqlalchemy.Datetime()等，具体数据类型可以参考这里  还是以写到mysql数据库为例：df.to_sql(name&#x3D;&#39;table&#39;, \n          con&#x3D;con, \n          if_exists&#x3D;&#39;append&#39;, \n          index&#x3D;False,\n          dtype&#x3D;&#123;&#39;col1&#39;:sqlalchemy.types.INTEGER(),\n                 &#39;col2&#39;:sqlalchemy.types.NVARCHAR(length&#x3D;255),\n                 &#39;col_time&#39;:sqlalchemy.DateTime(),\n                 &#39;col_bool&#39;:sqlalchemy.types.Boolean\n          &#125;)\n*注：**如果不提供dtype,to_sql会自动根据df列的dtype选择默认的数据类型输出，比如字符型会以sqlalchemy.types.TEXT类型输出，相比NVARCHAR，TEXT类型的数据所占的空间更大，所以一般会指定输出为NVARCHAR；而如果df的列的类型为np.int64时，将会导致无法识别并转换成INTEGER型，需要事先转换成int类型（用map，apply函数可以方便的转换）。https://www.cnblogs.com/arkenstone/p/6271923.html\n\n第二种：cursor.execute()直接写入#插入方法无需改动，传入一个动态变化的字典\nconnect &#x3D; pymysql.connect(host&#x3D;&#39;&#39;,user&#x3D;&#39;&#39;,db &#x3D; &#39;&#39;,password&#x3D;&#39;&#39;,port&#x3D;3306,charset&#x3D;&#39;utf8&#39;)\ncursor&#x3D;connect.cursor()\ndata &#x3D; &#123;&quot;id&quot;:&#39;100&#39;,&#39;name&#39;:&#39;Bob&#39;&#125;\ntable&#x3D; &#39;stuinfo&#39;\nkeys &#x3D; &#39;, &#39;.join(data.keys())\nvalues &#x3D; &#39;, &#39;.join([&#39;%s&#39;]*len(data))\nsql &#x3D; f&quot;insert into &#123;table&#125;(&#123;keys&#125;) values(&#123;values&#125;)&quot;\ntry:\n    cursor.execute(sql,tuple(data.values()))\n    connect.commit()\n    cursor.execute(&#39;select * from &#123;table&#125;&#39;.format(table&#x3D;table))\n    print(&#39;执行成功&#39;,cursor.fetchall())\nexcept:\n    print(&quot;插入失败，数据回滚&quot;)\n    connect.rollback()\n更新数据#更新，把Bon的age更新为28\nsql &#x3D; &quot;update stuinfo set id&#x3D;%s where name &#x3D; %s&quot;\ncursor.execute(sql,(&quot;28&quot;,&#39;Bob&#39;))\nconnect.commit()\ncursor.execute(&#39;select * from stuinfo&#39;)\nprint(&quot;Successful:&quot;,cursor.fetchall())\n删除数据#删除数据\nsql &#x3D; &quot;delete from stuinfo where id &gt;&#x3D;10&quot;\ncursor.execute(sql)\nconnect.commit()\ncursor.execute(&quot;select * from stuinfo&quot;)\nprint(cursor.fetchall())","slug":"python数据分析：连接mysql，读取、写入、更新、删除","date":"2021-07-04T05:16:15.000Z","categories_index":"python","tags_index":"数据分析","author_index":"弦好想断"},{"id":"c5a3632aecdc3f50f32639748c6ea233","title":"python数据可视化：pyecharts v1版本","content":"Echarts是一个由百度开源的数据可视化，结合巧妙的交互性，精巧的图表设计；而 Python 是一门富有表达力的语言，很适合用于数据处理。分析遇上数据可视化时，pyecharts诞生了。个人觉得可视化最好用的，不接受反驳，毕竟用echarts的都那么多；官方文档\n\n自己挑了一些碰到的坑记了一下，分享一些自己学习过程中发现的资源，其他看文档就够了\n\n基础柱状图from pyecharts import options as opts\nfrom pyecharts.charts import Bar\nfrom pyecharts.faker import Faker\nc &#x3D; (\n    Bar()\n    .add_xaxis(Faker.choose())\n    .add_yaxis(&quot;商家A&quot;, Faker.values())#gap&#x3D;&quot;0%&quot;；category_gap&#x3D;&quot;80%&quot;；stack&#x3D;&quot;stack1&quot;\n    .add_yaxis(&quot;商家B&quot;, Faker.values())#gap&#x3D;&quot;0%&quot;；is_selected&#x3D;False；stack&#x3D;&quot;stack1&quot;；label_opts&#x3D;opts.LabelOpts(is_show&#x3D;False)\n    .set_global_opts(title_opts&#x3D;opts.TitleOpts(title&#x3D;&quot;Bar-基本示例&quot;, subtitle&#x3D;&quot;我是副标题&quot;))\n                     # datazoom_opts&#x3D;[opts.DataZoomOpts(), opts.DataZoomOpts(type_&#x3D;&quot;inside&quot;)],#时间轴显示并可同通过鼠标滑动\n    .set_series_opts(\n        label_opts&#x3D;opts.LabelOpts(is_show&#x3D;False),\n        markpoint_opts&#x3D;opts.MarkPointOpts(\n            data&#x3D;[\n                opts.MarkPointItem(type_&#x3D;&quot;max&quot;, name&#x3D;&quot;最大值&quot;),\n                opts.MarkPointItem(type_&#x3D;&quot;min&quot;, name&#x3D;&quot;最小值&quot;),\n#                 opts.MarkPointItem(type_&#x3D;&quot;average&quot;, name&#x3D;&quot;平均值&quot;),\n            ]\n        ),\n        markline_opts&#x3D; opts.MarkLineOpts(data &#x3D; [opts.MarkLineItem(type_ &#x3D; &quot;average&quot;,name &#x3D; &quot;平均值&quot;)])\n    )\n    .render_notebook()\n)\nc\n\n\n只能通过滑动水平轴缩放x轴：只传入datazoom_opts=[opts.DataZoomOpts()]；省略掉 opts.DataZoomOpts(), 删除水平轴，就只能通过鼠标拖动；\n\n显示水平轴的比例（默认）：opts.DataZoomOpts(range_start=20,range_end=80)\n\n取消柱子上方数据显示：label_opts=opts.LabelOpts(is_show=False)\n\n添加y轴水平轴：datazoom_opts=opts.DataZoomOpts(orient=”vertical”)，可缩放大小；\n\n柱间距离：加入参数gap=”0%”(两个add_yaxis里面都要传)；加入参数category_gap=”80%”，表示单系柱间距离；\n\n默认取消显示某 Series：加入参数is_selected=False，默认取消显示某 Series\n\n堆叠数据：传入stack=”stack1”，希望哪几个指标堆叠就传那几个add_yaxis中；\n\n显示ToolBox：在set_global_opts()中传入        toolbox_opts=opts.ToolboxOpts(), brush_opts=opts.BrushOpts(),；\n\nXY轴名称：在set_globel_opts()中加入 yaxis_opts=opts.AxisOpts(name=”我是 Y  轴”),xaxis_opts=opts.AxisOpts(name=”我是 X 轴”),  ；\n\nY轴数据单位：在set_globel_opts()中加入 yaxis_opts=opts.AxisOpts(axislabel_opts=opts.LabelOpts(formatter=”{value} /月”)),  ；\n\n加入标记线\n    .set_series_opts(\n        label_opts&#x3D;opts.LabelOpts(is_show&#x3D;False),\n        markline_opts&#x3D;opts.MarkLineOpts(\n            data&#x3D;[opts.MarkLineItem(y&#x3D;50, name&#x3D;&quot;yAxis&#x3D;50&quot;)]\n        ),\n    )\n#set_global_opts()后加入set_series_opts，加入标记线，这里是y&#x3D;50；\n标记线的维度（当然可以是横轴）\n.set_series_opts(\n\tmarkline_opts&#x3D;opts.MarkLineOpts(\n                data&#x3D;[opts.MarkLineItem(type_&#x3D;&quot;average&quot;,value_dim&#x3D;&quot;x&quot;, name&#x3D;&quot;xAxis&quot;),\n                     opts.MarkLineItem(type_&#x3D;&quot;average&quot;,value_dim&#x3D;&quot;y&quot;, name&#x3D;&quot;xAxis&quot;)\n                     ]\n加入标记值\n#set_series_opts中加入，表示传入标记，最大、最小、平均值。\n        markpoint_opts&#x3D;opts.MarkPointOpts(\n            data&#x3D;[\n                opts.MarkPointItem(type_&#x3D;&quot;max&quot;, name&#x3D;&quot;最大值&quot;),\n                opts.MarkPointItem(type_&#x3D;&quot;min&quot;, name&#x3D;&quot;最小值&quot;),\n                opts.MarkPointItem(type_&#x3D;&quot;average&quot;, name&#x3D;&quot;平均值&quot;),\n            ]\nxy轴互换\n#设置完add_yaxis后接着\n    .reversal_axis()#xy轴互换\n    .set_series_opts(label_opts&#x3D;opts.LabelOpts(position&#x3D;&quot;right&quot;))#显示数据在柱子右边\nx轴名字标签过长，旋转角度\n在set_global_opts（）中传入\nxaxis_opts&#x3D;opts.AxisOpts(axislabel_opts&#x3D;opts.LabelOpts(rotate&#x3D;-15)),\n连接空数据 \nimport pyecharts.options as opts\nfrom pyecharts.charts import Line\nfrom pyecharts.faker import Faker\n\ny &#x3D; Faker.values()\ny[3], y[5] &#x3D; None, None\nc &#x3D; (\n    Line()\n    .add_xaxis(Faker.choose())\n    .add_yaxis(&quot;商家A&quot;, y, is_connect_nones&#x3D;True)\n    .set_global_opts(title_opts&#x3D;opts.TitleOpts(title&#x3D;&quot;Line-连接空数据&quot;))\n    .render(&quot;line_connect_null.html&quot;)\n)\n自定义标记点\nimport pyecharts.options as opts\nfrom pyecharts.charts import Line\nfrom pyecharts.faker import Faker\n\nx, y &#x3D; Faker.choose(), Faker.values()\nc &#x3D; (\n    Line()\n    .add_xaxis(x)\n    .add_yaxis(\n        &quot;商家A&quot;,\n        y,\n        markpoint_opts&#x3D;opts.MarkPointOpts(\n            data&#x3D;[opts.MarkPointItem(name&#x3D;&quot;自定义标记点&quot;, coord&#x3D;[x[2], y[2]], value&#x3D;y[2])]\n        ),\n    )\n    .set_global_opts(title_opts&#x3D;opts.TitleOpts(title&#x3D;&quot;Line-MarkPoint（自定义）&quot;))\n    .render(&quot;line_markpoint_custom.html&quot;)\n)\n作条形图时由于有时候座标轴文字过长，缩放后导致无法完全显示，此时则需要调整座标轴与图像的边距。调整边距是采用grid（）方法。在图形设置完成后，使用grid设置座标轴与图像边界的距离。\nreport_day_line &#x3D; Grid()\nreport_day_line.add(report_day_line1,opts.GridOpts(pos_left&#x3D;&quot;10%&quot;,pos_top &#x3D;&quot;10%&quot;), is_control_axis_index&#x3D;True)\nreport_day_line.render_notebook()\n指定chart_id时要将写好的图形定义成函数，这样子可以复用后面的page中图片位置，方便更改\n\njscode的妙用 https://zhuanlan.zhihu.com/p/133533187\ntooltip_opts&#x3D;opts.TooltipOpts(\n                formatter&#x3D;JsCode(\n                &quot;function (params) &#123;return params.value[2] + &#39; ：复购率：&#39; +(Number(params.value[0])* 100).toFixed(2) + &#39;%&#39;+&#39;，销售额：&#39;+ params.value[1];&#125;&quot;\n                )\n#                 trigger&#x3D;&quot;axis&quot;, axis_pointer_type&#x3D;&quot;cross&quot;\n            ),\npyecharts画时间排序图\n\nfrom pyecharts import options as opts\nfrom pyecharts.charts import Bar,Timeline\nfrom pyecharts.faker import Faker\nimport random\nimport pandas as pd\nimport numpy as np\n\n# 受这篇文章启发https:&#x2F;&#x2F;blog.csdn.net&#x2F;weixin_42512684&#x2F;article&#x2F;details&#x2F;108176613\ndata &#x3D; np.array([random.randint(30,150) for i in range(52*7) ]).reshape(52,7)\ndf &#x3D; pd.DataFrame(data,index&#x3D;[i for i in range(1969,2021)],columns &#x3D; random.sample(attr, len(attr)))\ndf\n\ndf_sorted &#x3D; [r[:].sort_values() for i,r in df.iterrows()]\ndf_sorted[0].values\nt1  &#x3D; Timeline()# 创建 Timeline对象\n\nfor j in range(1969,2021):\n    bar &#x3D; (\n    Bar()\n    .add_xaxis([str(i) for i in df_sorted[j-1969].index])\n    .add_yaxis(&#39;Data&#39;,[int(i) for i in df_sorted[j-1969].values]\n               ,label_opts &#x3D; opts.LabelOpts(position &#x3D; &#39;right&#39;),\n             )\n    .set_series_opts(label_opts &#x3D; opts.LabelOpts(is_show &#x3D; True,position &#x3D; &#39;right&#39;))\n    .reversal_axis()\n    .set_global_opts(title_opts &#x3D; opts.TitleOpts(&quot;&#123;&#125;&quot;.format(j),\n                                                 pos_left &#x3D; &#39;50%&#39;,\n\n                                                ),\n                    legend_opts &#x3D; opts.LegendOpts(pos_right &#x3D; &#39;10%&#39;))\n\n    )\n\n    t1.add(bar,&#39;&#123;&#125;年&#39;.format(j))\n    \nt1.add_schema(\nsymbol &#x3D; &#39;arrow&#39;,# 设置标记时间；\n    #orient &#x3D; &#39;vertical&#39;,\n     symbol_size &#x3D; 2,# 标记大小;\n    play_interval &#x3D; 1000,# 播放时间间隔；\n    control_position &#x3D; &#39;right&#39;,# 控制位置;\nlinestyle_opts &#x3D; opts.LineStyleOpts(width &#x3D; 5,\n                                   type_ &#x3D; &#39;dashed&#39;,\n                                   color &#x3D; &#39;rgb(255,0,0,0.5)&#39;),\n    label_opts &#x3D; opts.LabelOpts(color &#x3D; &#39;rgb(0,0,255,0.5)&#39;,\n                                    font_size &#x3D; 15,\n                                    font_style &#x3D; &#39;italic&#39;,\n                                    font_weight &#x3D; &#39;bold&#39;,\n                                     font_family &#x3D;&#39;Time New Roman&#39;,\n\n                                position &#x3D; &#39;left&#39;,\n                                interval &#x3D; 20,\n                                    )\n)\nt1.render_notebook()\n\npyecharts画地理图-geo,mapdef my_geo(city, city_value):\n    c &#x3D; (\n        Geo(init_opts&#x3D;opts.InitOpts(theme&#x3D;ThemeType.DARK,chart_id&#x3D;1))\n            .add_schema(maptype&#x3D;&quot;china&quot;)\n            .add(&quot;geo&quot;, [list(z) for z in zip(city, city_value)])\n            .set_series_opts(label_opts&#x3D;opts.LabelOpts(is_show&#x3D;False))\n            .set_global_opts(\n            visualmap_opts&#x3D;opts.VisualMapOpts(), title_opts&#x3D;opts.TitleOpts(title&#x3D;&quot;用户城市分布&quot;)\n        )  # .render(&quot;geo_base.html&quot;)\n    )\n    return c\nis_piecewise参数：在 set_global_opts()中的visualmap_opts=opts.VisualMapOpts(is_piecewise=True),表示分段显示；\ndef my_map(province, num):\n    c &#x3D; (\n        Map(init_opts&#x3D;opts.InitOpts(theme&#x3D;ThemeType.DARK,chart_id&#x3D;2))\n            .add(&quot;map&quot;, [list(z) for z in zip(province, num)], &quot;china&quot;)\n            .set_series_opts(label_opts&#x3D;opts.LabelOpts(is_show&#x3D;False))\n            .set_global_opts(visualmap_opts&#x3D;opts.VisualMapOpts(), title_opts&#x3D;opts.TitleOpts(title&#x3D;&quot;用户省份分布&quot;))\n    )  # .render(&quot;map_base.html&quot;)\n    return c\npyecharts画内层嵌套饼图c &#x3D; (\n    Pie()\n    .add(&quot;&quot;, [list(z) for z in zip(Faker.choose(), Faker.values())])#center&#x3D;[&quot;35%&quot;, &quot;50%&quot;],\n    .set_global_opts(title_opts&#x3D;opts.TitleOpts(title&#x3D;&quot;Pie-基本示例&quot;))#legend_opts&#x3D;opts.LegendOpts(pos_left&#x3D;&quot;15%&quot;),\n    .set_series_opts(label_opts&#x3D;opts.LabelOpts(formatter&#x3D;&quot;&#123;b&#125;: &#123;c&#125;&quot;))\n#     .render(&quot;pie_base.html&quot;)\n)\nc.render_notebook()\n\n内嵌饼图nested_piesinner_x_data &#x3D; [&quot;直达&quot;, &quot;营销广告&quot;, &quot;搜索引擎&quot;]\ninner_y_data &#x3D; [335, 679, 1548]\ninner_data_pair &#x3D; [list(z) for z in zip(inner_x_data, inner_y_data)]\n\nouter_x_data &#x3D; [&quot;直达&quot;, &quot;营销广告&quot;, &quot;搜索引擎&quot;, &quot;邮件营销&quot;, &quot;联盟广告&quot;, &quot;视频广告&quot;, &quot;百度&quot;, &quot;谷歌&quot;]\nouter_y_data &#x3D; [335, 310, 234, 135, 1048, 251, 147, 102]\nouter_data_pair &#x3D; [list(z) for z in zip(outer_x_data, outer_y_data)]\n(\n    Pie(init_opts&#x3D;opts.InitOpts())#theme&#x3D;ThemeType.DARK 指定主题为黑色\n    .add(\n        series_name&#x3D;&quot;访问来源&quot;,\n        data_pair&#x3D;inner_data_pair,#指定数据源\n        radius&#x3D;[0, &quot;30%&quot;],#半径 \n        label_opts&#x3D;opts.LabelOpts(position&#x3D;&quot;inner&quot;),#图形位置\n    )\n    .add(\n        series_name&#x3D;&quot;访问来源&quot;,\n        radius&#x3D;[&quot;40%&quot;, &quot;55%&quot;],\n        data_pair&#x3D;outer_data_pair,\n        label_opts&#x3D;opts.LabelOpts(\n            position&#x3D;&quot;outside&quot;,\n            formatter&#x3D;&quot;&#123;a|&#123;a&#125;&#125;&#123;abg|&#125;\\n&#123;hr|&#125;\\n &#123;b|&#123;b&#125;: &#125;&#123;c&#125; &#123;per|&#123;d&#125;%&#125;  &quot;,#&quot;&#123;a&#125; &lt;br&#x2F;&gt;&#123;b&#125;: &#123;c&#125; (&#123;d&#125;%)&quot; 文本样式\n            background_color&#x3D;&quot;#eee&quot;,  #背景颜色\n            border_color&#x3D;&quot;#aaa&quot;,  #边框颜色\n            border_width&#x3D;1,   #边框宽度\n            border_radius&#x3D;4,  #边界半径\n            rich&#x3D;&#123;\n                &quot;a&quot;: &#123;&quot;color&quot;: &quot;#999&quot;, &quot;lineHeight&quot;: 22, &quot;align&quot;: &quot;center&quot;&#125;,\n                &quot;abg&quot;: &#123;\n                    &quot;backgroundColor&quot;: &quot;#e3e3e3&quot;,\n                    &quot;width&quot;: &quot;100%&quot;,\n                    &quot;align&quot;: &quot;right&quot;,\n                    &quot;height&quot;: 22,\n                    &quot;borderRadius&quot;: [4, 4, 0, 0],\n                &#125;,\n                &quot;hr&quot;: &#123;\n                    &quot;borderColor&quot;: &quot;#aaa&quot;,\n                    &quot;width&quot;: &quot;100%&quot;,\n                    &quot;borderWidth&quot;: 0.5,\n                    &quot;height&quot;: 0,\n                &#125;,\n                &quot;b&quot;: &#123;&quot;fontSize&quot;: 16, &quot;lineHeight&quot;: 33&#125;,#,&quot;color&quot;:&quot;#999&quot;\n#                 &quot;c&quot;:&#123;&quot;color&quot;:&quot;#999&quot;&#125;,\n                &quot;per&quot;: &#123;\n                    &quot;color&quot;: &quot;#eee&quot;,\n                    &quot;backgroundColor&quot;: &quot;#334455&quot;,\n                    &quot;padding&quot;: [2, 4],\n                    &quot;borderRadius&quot;: 2,\n                &#125;,\n            &#125;,\n        ),\n    )\n    .set_global_opts(legend_opts&#x3D;opts.LegendOpts(pos_left&#x3D;&quot;left&quot;, orient&#x3D;&quot;vertical&quot;,textstyle_opts&#x3D;&#123;&quot;color&quot;:&quot;#999&quot;&#125;))#设置图例字体为白色\n    .set_series_opts(\n        tooltip_opts&#x3D;opts.TooltipOpts(\n            trigger&#x3D;&quot;item&quot;, formatter&#x3D;&quot;&#123;a&#125; &lt;br&#x2F;&gt;&#123;b&#125;: &#123;c&#125; (&#123;d&#125;%)&quot;    # &#39;item&#39;: 数据项图形触发，主要在散点图，饼图等无类目轴的图表中使用。\n        )\n    )\n#     .render(&quot;nested_pies.html&quot;)\n).render_notebook()\n\n那个formatter配置项可以在这里了解：{a}（系列名称），{b}（数据项名称），{c}（数值）, {d}（百分比）https://echarts.apache.org/zh/option.html#grid.tooltip.formatter\npyecharts中page的使用类似BI大屏展示page &#x3D; Page(layout&#x3D; Page.DraggablePageLayout, page_title&#x3D; &quot;大屏展示&quot;)\n# page &#x3D; Page()\npage.add(\n    bar_datazoom_slider(),\n    line_markpoint(),\n    pie_rosetype(),\n    grid_mutil_yaxis(),\n    liquid_data_precision(),\n    table_base(),\n)\npage.render(&quot;temp.html&quot;)\n然后自己点那开个temp.html文件进行拖拽，缩放，布局称自己想要的样子，最后点击save_config按钮，下载那个chart_config.json文件。\n不带标题，修改配置文件为百分比\n修改json配置文件，改成百分比主要是为了页面自适应屏幕大小。\ndf &#x3D; pd.read_json(&quot;chart_config.json&quot;)\ndf[&quot;width&quot;] &#x3D; df.width.apply(lambda x: x[:-2])\ndf[&quot;height&quot;] &#x3D; df.height.apply(lambda x: x[:-2])\ndf[&quot;top&quot;] &#x3D; df.top.apply(lambda x: x[:-2])\ndf[&quot;left&quot;] &#x3D; df.left.apply(lambda x: x[:-2])\n# df.astype(&#123;&#39;width&#39;:&#39;float&#39;,&#39;height&#39;:&#39;float&#39;,&#39;top&#39;:&#39;float&#39;,&#39;height&#39;:&#39;float&#39;&#125;).dtypes\ndf[&quot;width&quot;]&#x3D; df.width.apply(lambda x: str(round(float(x)&#x2F;1256*100,4))+&quot;%&quot;)#这里1256、640是你自己电脑屏幕的px值\ndf[&quot;height&quot;] &#x3D; df.height.apply(lambda x: str(round(float(x)&#x2F;640*100*11&#x2F;12,4))+&quot;%&quot;)#如果出现右侧滑块，可适当进行缩放，这里按11&#x2F;12的比例缩放\ndf[&quot;top&quot;] &#x3D; df.top.apply(lambda x: str(round(float(x)&#x2F;640*100*11&#x2F;12,4))+&quot;%&quot;)\ndf[&quot;left&quot;] &#x3D; df.left.apply(lambda x: str(round(float(x)&#x2F;1256*100,4))+&quot;%&quot;)\ndf.to_json(&quot;chart_config2.json&quot;,orient &#x3D; &quot;records&quot;)\n修改好json数据之后，再运行这行代码\n#第一个字段是前面拖拽的html文件名，cfg_file就是你刚save的json文件名，dest是你要生成的文件名\npage.save_resize_html( &#39;temp.html&#39;, cfg_file&#x3D; &#39;chart_config2.json&#39;,dest&#x3D; &#39;设置好位置后的BI看板.html&#39;)\n加上标题，可自定义html\n\n这样弄完有点问题就是背景页面可能和图片背景有违和感，你可以使用BeautifulSoup再修改下页面背景颜色啥的,相关网课链接https://www.bilibili.com/video/BV1KT4y1c7pb?p=22\nfrom bs4 import BeautifulSoup\nimport os\n\n#这里要先读取那个json文件\n\nwith open(os.path.join(os.path.abspath(&quot;.&quot;), &quot;设置好位置后的BI看板.html&quot;), &#39;r+&#39;, encoding&#x3D;&quot;utf8&quot;) as html:\n    html_bf &#x3D; BeautifulSoup(html, &quot;lxml&quot;)\n    divs &#x3D; html_bf.find_all(&quot;div&quot;)\n    #读取config_json文件，循环写入到HTML\n    for i in range(len(df_config)):\n        width &#x3D; df_config.loc[i,&#39;width&#39;]\n        height &#x3D; df_config.loc[i,&#39;height&#39;]\n        top &#x3D; df_config.loc[i,&#39;top&#39;]\n        left &#x3D; df_config.loc[i,&#39;left&#39;]\n        divs[i+1][&quot;style&quot;] &#x3D; f&quot;width:&#123;width&#125;;height:&#123;height&#125;;position:absolute;top:&#123;top&#125;;left:&#123;left&#125;;&quot;\n        \n    body &#x3D; html_bf.find(&quot;body&quot;)\n    body[&quot;style&quot;]&#x3D;&quot;background-color:#333333;&quot;\n#     div_title &#x3D; &quot;&lt;div align&#x3D;\\&quot;center\\&quot; style&#x3D;\\&quot;width:100%;\\&quot;&gt;\\n&lt;span style&#x3D;\\&quot;font-size:30px;font face&#x3D;\\&#39;微软雅黑\\&#39;;color :#FFFFFF\\&quot;&gt;&lt;b&gt;CD_NOW数据看板&lt;&#x2F;b&gt;&lt;&#x2F;div&gt;&quot;  # 修改页面背景色、追加标题\n#     body.insert(0, BeautifulSoup(div_title, &quot;lxml&quot;).div)\n    html_new &#x3D; str(html_bf)\n    html.seek(0, 0)\n    html.truncate()\n    html.write(html_new)\n    html.close()\n当然也可以把那个json文件里面的值传到对应的样式代码中在HTML页面中进行布局，需要注意的是画图时指定好每个图表的chart_id,便于通过字符串格式进行指定对应图表位置。\n注意点：（来自https://www.jianshu.com/p/47e8f056e5cf）1.由于图片的布局是根据chart_config.json中图片id的对应关系进行布局，因此每张图片均需要指定其id；如：Bar(init_opts=opts.InitOpts(chart_id=1))2.在本次操作工程中，发现Table类中不包含init_opts参数，可以通过修改源码，在D:\\Anaconda3\\Lib\\site-packages\\pyecharts\\component\\table指定char_id,具体修改的代码如下：\nclass Table(ChartMixin):\n    def __init__(self, page_title: str &#x3D; CurrentConfig.PAGE_TITLE, js_host: str &#x3D; &quot;&quot;,chart_id&#x3D;None):\n        self.page_title &#x3D; page_title\n        self.js_host &#x3D; js_host or CurrentConfig.ONLINE_HOST\n        self.js_dependencies: OrderedSet &#x3D; OrderedSet()\n        self.js_functions: OrderedSet &#x3D; OrderedSet()\n        self.title_opts: ComponentTitleOpts &#x3D; ComponentTitleOpts()\n        self.html_content: str &#x3D; &quot;&quot;\n        self._component_type: str &#x3D; &quot;table&quot;\n        if chart_id:\n            self.chart_id: str &#x3D; chart_id\n        else:\n            self.chart_id: str &#x3D; uuid.uuid4().hex\nhttps://www.bilibili.com/video/BV1KT4y1c7pb 网课里有学习资源自己去看\n","slug":"python数据可视化：pyecharts-v1版本","date":"2021-06-05T02:29:26.000Z","categories_index":"python","tags_index":"数据分析","author_index":"弦好想断"},{"id":"8ca00045c38562501faacb57ba3b1700","title":"python数据采集：selenium爬虫、自动化","content":"中文文档https:&#x2F;&#x2F;python-selenium-zh.readthedocs.io&#x2F;zh_CN&#x2F;latest&#x2F;\n装包：pip install selenium下载chrome：https://www.google.cn/chrome/下驱动：https://chromedriver.storage.googleapis.com/index.html  注意浏览器驱动 必须要和浏览器版本匹配这是个zip包，下载下来之后，解压里面的程序文件 chromedriver.exe 到scripts路径下跑一下看看感觉来了没有\nfrom selenium import webdriver\nfrom selenium.webdriver.common.by import By\nfrom selenium.webdriver.common.keys import Keys\nfrom selenium.webdriver.support import expected_conditions as EC\nfrom selenium.webdriver.support.wait import WebDriverWait\n\nbrowser &#x3D; webdriver.Chrome()\ntry:\n    browser.get(&#39;https:&#x2F;&#x2F;www.baidu.com&#39;)\n    input &#x3D; browser.find_element_by_id(&#39;kw&#39;)\n    input.send_keys(&#39;Python&#39;)\n    input.send_keys(Keys.ENTER)\n    wait &#x3D; WebDriverWait(browser, 10)\n    wait.until(EC.presence_of_element_located((By.ID, &#39;content_left&#39;)))\n    print(browser.current_url)\n    print(browser.get_cookies())\n    print(browser.page_source)\nfinally:hexo\n    browser.close()\n不可能一下就会的，慢慢来\nhttps:&#x2F;&#x2F;blog.csdn.net&#x2F;weixin_54733110&#x2F;article&#x2F;details&#x2F;119027005  python万字博文教你玩嗨selenium库\nhttps:&#x2F;&#x2F;mp.weixin.qq.com&#x2F;s?__biz&#x3D;MzI0OTc0MzAwNA&#x3D;&#x3D;&amp;mid&#x3D;2247487680&amp;idx&#x3D;1&amp;sn&#x3D;e40947f382116ff59761f250ee45dce3  模拟登录淘宝\nhttps:&#x2F;&#x2F;www.pianshen.com&#x2F;article&#x2F;345981989&#x2F;  判断元素16种方法expected_conditions\nhttps:&#x2F;&#x2F;github.com&#x2F;Python3WebSpider&#x2F;Python3WebSpider&#x2F;blob&#x2F;master&#x2F;7.1-Selenium%E7%9A%84%E4%BD%BF%E7%94%A8.md\nhttp:&#x2F;&#x2F;www.byhy.net&#x2F;tut&#x2F;auto&#x2F;selenium&#x2F;01&#x2F;这个作者写的很好\nhttps:&#x2F;&#x2F;www.bilibili.com&#x2F;video&#x2F;av64421994&#x2F;?p&#x3D;1简直是保姆级教学，\n希望你学会了不要乱搞\n\n","slug":"python数据采集：selenium爬虫、自动化","date":"2021-05-05T02:34:57.000Z","categories_index":"python","tags_index":"自动化","author_index":"弦好想断"},{"id":"3836a474642d761a6e5b64bf08fc9275","title":"python办公自动化：邮件发送","content":"\n邮件批量发送调用smtp.exmail.qq.com批量自动发送邮件注意文件路径，逗号分隔符，csv中不要有多余回车和空格import os\nimport sys\nimport csv\nimport smtplib\nimport pandas as pd\nimport numpy as np\nfrom email.mime.base import MIMEBase\nfrom email.mime.image import MIMEImage\nfrom email.utils import formataddr\nfrom email import encoders\nimport time,datetime\nimport smtplib\nimport email.mime.multipart\nimport email.mime.text\nfrom email.mime.text import MIMEText\nfrom email.mime.multipart import MIMEMultipart\nfrom email.mime.application import MIMEApplication\nfrom email.header import Header\n\ndef get_current_date():\n    &quot;&quot;&quot;获取当前时间&quot;&quot;&quot;\n    return str(time.strftime(&#39;%Y%m%d&#39;))\n\ndef getAddrBook(addrBook):\n    &#39;&#39;&#39;\n        @作用：根据输入的CSV文件，形成相应的通讯录字典\n        @返回：字典类型，name为人名，value为对应的邮件地址\n    &#39;&#39;&#39;\n    with open(addrBook,&#39;r&#39;,encoding&#x3D;&#39;UTF-8&#39;) as addrFile:\n        #将文件名和邮件接收人邮箱地址分行存放在csv文件中，用逗号分隔\n        reader &#x3D; csv.reader(addrFile)\n        name &#x3D; []\n        value &#x3D; []\n        for row in reader:\n            name.append(row[0])\n            value.append(row[1])\n    addrs &#x3D; dict(zip(name, value))\n    return addrs\n\ndef send_email(inputpath,smtpHost,port,sendAddr,password,recipientAddrs, subject, content,attachfilename):\n    &quot;&quot;&quot;定义并配置好发邮件的函数&quot;&quot;&quot;\n    msg &#x3D; email.mime.multipart.MIMEMultipart()\n    msg[&#39;from&#39;] &#x3D;sendAddr #发件人\n    msg[&#39;to&#39;] &#x3D;recipientAddrs #接收人\n    # msg[&#39;cc&#39;] &#x3D;cc_name #抄送人名称\n    msg[&#39;subject&#39;] &#x3D;subject #主题\n    content&#x3D;content\n    txt &#x3D; email.mime.text.MIMEText(content, &#39;plain&#39;, &#39;UTF-8&#39;)\n    msg.attach(txt)\n    print(&quot;准备添加附件...&quot;)\n    inputfile&#x3D;inputpath+attachfilename #文件路径\n    part &#x3D; MIMEText(open(inputfile,&#39;rb&#39;).read(),&#39;base64&#39;, &#39;utf-8&#39;)\n    part[&quot;Content-Type&quot;] &#x3D; &#39;application&#x2F;octet-stream&#39;\n    part.add_header(&#39;Content-Disposition&#39;, &#39;attachment&#39;, filename&#x3D;Header(attachfilename,&#39;utf-8&#39;).encode())\n    msg.attach(part)\n    smtp &#x3D; smtplib.SMTP_SSL(smtpHost, port)\n    smtp.login(sendAddr, password)\n    smtp.sendmail(sendAddr, recipientAddrs.split(&#39;,&#39;), str(msg))   #+cc_name.split(&#39;,&#39;)\n    #print(&quot;发送成功！&quot;)\n    smtp.quit()\n\nif __name__&#x3D;&#x3D;&#39;__main__&#39;:\n    #这里需要定义send_email函数中传入的所有变量\n    inputpath &#x3D; &quot;r&#39;D:&#x2F;&quot; #数据存放的文件路径（这里是绝对路径）\n    smtpHost &#x3D; &#39;smtp.exmail.qq.com&#39;  # 默认服务器地址及端口\n    port&#x3D;465\n    sendAddr &#x3D;&quot;&quot;    #自己也就是发件人的邮箱账号\n    password &#x3D; &quot;&quot;   #自己的邮箱密码\n    subject&#x3D;&quot; &quot;+current_date  #主题+当前日期\n    content&#x3D;&#39;&#39;&#39;附件为测试文件&#39;&#39;&#39;+current_date# 正文内容+当前日期\n\n    addrBook&#x3D;r&#39;D:\\邮箱联系人表单.csv&#39;  #联系人表单文件路径\n    addrs&#x3D;getAddrBook(addrBook)\n    for i in addrs:\n        attachfilename&#x3D;i+&#39;.xlsx&#39; #将要发送的文件添加为附件\n        recipientAddrs&#x3D;addrs[i] #接收人的邮箱地址\n        result &#x3D; os.path.exists(inputpath+i+&#39;.xlsx&#39;) #判断当前目录是否存在该文件\n        if result:\n            #存在就执行邮件\n            send_email(inputpath,smtpHost,port,sendAddr,password,recipientAddrs,\n            subject,content,attachfilename)\n            print ((&#39;发给 %s 的邮件执行成功&#39;) %(recipientAddrs))\n\n\n这里也看到有使用126邮箱的smtp服务器：’smtp.126.com’https://blog.csdn.net/weixin_42350212/article/details/118751583Python smtp发送邮件怎么设置抄送人https://www.cnblogs.com/shiyixirui/p/14692146.html\n","slug":"python办公自动化：邮件发送","date":"2021-04-05T02:24:12.000Z","categories_index":"python","tags_index":"自动化","author_index":"弦好想断"},{"id":"3d3f9536d1b98ac2adb8f0a4ceb774df","title":"python办公自动化：文件和目录操作","content":"import os\n创建目录结构\nos.makedirs 可以递归的创建目录结构，比如os.makedirs(&#39;tmp&#x2F;python&#x2F;fileop&#39;,exist_ok&#x3D;True)\n在当前工作目录下面创建 tmp目录，在tmp目录下面再创建 python目录，在Python目录下面再创建fileop目录；exist_ok=True 指定了，如果某个要创建的目录已经存在，也不报错\n\n删除文件或目录os.remove 可以删除一个文件，比如\nos.remove(&#39;sdf.py&#39;)\nshutil.rmtree() 可以递归的删除某个目录所有的子目录和子文件 比如\nimport shutil\nshutil.rmtree(&#39;tmp&#39;, ignore_errors&#x3D;True)\n注意：参数 ignore_errors=True 保证如果目录不为空，不会抛出异常。\n拷贝文件shutil 模块里面有很多 目录文件操作的函数拷贝文件，可以使用shutil模块的copyfile函数。\nfrom shutil import copyfile\n# 拷贝 d:&#x2F;tools&#x2F;first.py 到 e:&#x2F;first.py\ncopyfile(&#39;d:&#x2F;tools&#x2F;first.py&#39;, &#39;e:&#x2F;first.py&#39;)\n注意，如果拷贝前，e:/first.py 已经存在，则会被拷贝覆盖，所以使用该函数一定要小心。###拷贝目录如果我们要拷贝一个目录里面所有的内容（包括子目录和文件、子目录里面的子目录和文件，等等）到另外一个目录中，可以使用 shutil的copytree函数。\nfrom shutil import copytree\n# 拷贝 d:&#x2F;tools&#x2F;aaa 目录中所有的内容 到 e:&#x2F;bbb 中\ncopytree(&#39;d:&#x2F;tools&#x2F;aaa&#39;, &#39;e:&#x2F;new&#x2F;bbb&#39;)\n注意拷贝前， 目标目录必须 不存在 ，否则会报错。\n上面的代码执行前面，如果 e:/new/bbb 已经存在，执行到copytree时，就会报错\n上面的代码执行前面，如果 e:/new 这个目录都不存在，执行到copytree时，就会 创建 e:/new 目录，再创建 e:/new/bbb 目录，再拷贝 d:/tools/aaa 目录中所有的内容 到 e:/new/bbb 中。\n上面的代码执行前面，如果 e:/new 这个目录存在，但是 e:/new/bbb 不存在，执行到copytree时，就只会 创建 e:/new/bbb ，再拷贝 d:/tools/aaa 目录中所有的内容 到 e:/new/bbb 中。###修改文件名、目录名要修改文件名、目录名，可以使用os模块的rename函数。\n# 修改目录名 d:&#x2F;tools&#x2F;aaa 为 d:&#x2F;tools&#x2F;bbb\nos.rename(&#39;d:&#x2F;tools&#x2F;aaa&#39;,&#39;d:&#x2F;tools&#x2F;bbb&#39;)\n\n# 修改文件名 d:&#x2F;tools&#x2F;first.py 为 d:&#x2F;tools&#x2F;second.py\nos.rename(&#39;d:&#x2F;tools&#x2F;first.py&#39;,&#39;d:&#x2F;tools&#x2F;second.py&#39;)\n\n对文件路径名的操作对于文件名的操作，比如 获取文件名称，文件所在目录，文件路径的拼接等，都可以使用 os.path 模块。\n通常我们喜欢使用格式化字符串的方法来做文件路径的拼接，但是如果你的程序需要在Linux、Windows等多个平台运行，它们的路径的分隔符是不同的，Windows上是 \\ , 而 Linux上是 /。\n这时，我们应该使用 os.path 模块。 它能够自动处理类似 Data/data.csv 和 Data\\data.csv 这样的文件路径差异。\npath &#x3D; &#39;&#x2F;Users&#x2F;beazley&#x2F;Data&#x2F;data.csv&#39;\n# 获取路径中的文件名部分\nos.path.basename(path)\n&#39;data.csv&#39;\n# 获取路径中的目录部分\nos.path.dirname(path)\n&#39;&#x2F;Users&#x2F;beazley&#x2F;Data&#39;\n# 文件路径的拼接\nos.path.join(&#39;tmp&#39;, &#39;data&#39;, os.path.basename(path))\n&#39;tmp&#x2F;data&#x2F;data.csv&#39;\n判断文件、目录是否存在os.path.exists(&#39;d:&#x2F;systems&#x2F;cmd.exe&#39;)\nos.path.exists(&#39;d:&#x2F;systems&#39;)\nexists方法返回值为True表示 存在，否则表示不存在。如果你要判断指定路径是否是文件，可以这样os.path.isfile(‘d:/systems/cmd.exe’)# 返回值为True 表示是文件如果你要判断指定路径是否是目录，可以这样os.path.isdir(‘d:/systems’)#返回值为True 表示是目录\n###文件大小和修改日期\n\n返回文件大小os.path.getsize(‘file1’)3669\n\n返回文件的最后修改日期，是秒时间参考下一章 日期和时间 里面的内容os.path.getmtime(‘file1’)1272478234.0\n\n可以把秒时间 转化为日期时间import timetime.ctime(os.path.getmtime(‘/etc/passwd’))‘Wed Apr 28 13:10:34 2010’\n\n\n###当前工作目录当前工作目录的路径：wd = os.getcwd()改变当前工作目录到另外的路径：os.chdir(path)参数就是 新的当前工作目录 路径地址。\n###递归的遍历目录下面所有的文件获取某个目录中所有的 文件， 包括子目录里面的文件。 可以使用 os库中的walk方法比如我们要得到某个目录下面所有的子目录 和所有的文件，存放在两个列表中 os.walk(top[, topdown=True[, onerror=None[, followlinks=False]]])    top ：是你所要遍历的目录的地址, 返回的是一个三元组 (dirpath, dirnames, filenames)    topdown ：可选，True则优先遍历 top 文件夹，与top 文件夹中每一个子目录；否则优先遍历 top 的子目录(默认为开启)。    onerror ：可选，需要一个 callable 对象，当 walk 需要异常时，会调用    followlinks ：可选，如果为 True，则会遍历目录下的快捷方式(linux 下是软连接 symbolic link )实际所指的目录(默认关闭)，如果为 False，则优先遍历 top 的子目录；\n\n得到某个目录下所有文件的全路径import os\n# 目标目录\ntargetDir &#x3D; r&#39;d:\\tmp\\util\\dist\\check&#39;\nfor (dirpath, dirnames, filenames) in os.walk(targetDir):\n    for fn in filenames:\n        # 把 dirpath 和 每个文件名拼接起来 就是全路径\n        fpath &#x3D; os.path.join(dirpath, fn)\n# dirpath 代表当前遍历到的目录名\n# dirnames 是列表对象，存放当前dirpath中的所有子目录名\n# filenames 是列表对象，存放当前dirpath中的所有文件名\n得到目录中所有的文件和子目录名listdir返回的是该目录下面所有的文件和子目录。# 目标目录\ntargetDir &#x3D; r&#39;d:\\tmp\\util\\dist\\check&#39;\nfiles &#x3D;  os.listdir(targetDir)\nprint(files)\n如果只需要获取目录中所有的文件，或者只需要子目录import os\nfrom os.path import isfile, join,isdir\n# 目标目录\ntargetDir &#x3D; r&#39;d:\\tmp\\util\\dist\\check&#39;\n# 所有的文件\nprint([f for f in os.listdir(targetDir) if isfile(join(targetDir, f))])\n# 所有的目录\nprint([f for f in os.listdir(targetDir) if isdir(join(targetDir, f))])\n###得到目录中指定扩展名的文件和子目录可以使用glob库import glob\nexes &#x3D; glob.glob(r&#39;d:\\tmp\\*.txt&#39;)\nprint(exes)\nhttp://www.byhy.net/tut/py/extra/file_dir\n\n","slug":"python办公自动化：文件和目录操作","date":"2021-03-06T15:07:45.000Z","categories_index":"python","tags_index":"自动化","author_index":"弦好想断"},{"id":"917af4fce65ef9c1196ef8527f6229c9","title":"python关联分析（apriori算法）","content":"若两个或多个变量的取值之间存在某种规律性，就称为关联。关联规则是寻找在同一个事件中出现的不同项的相关性，比如在一次购买活动中所买不同商品的相关性。例如：“在购买计算机的顾客中，有30％的人也同时购买了打印机”。\n\n一个样本称为一个“事务”每个事务由多个属性来确定，这里的属性称为“项”多个项组成的集合称为“项集”####由k个项构成的集合{牛奶}、{啤酒}都是1-项集；{牛奶，果冻}是2-项集；{啤酒，面包，牛奶}是3-项集####X==&gt;Y含义：X和Y是项集X称为规则前项（antecedent）Y称为规则后项（consequent）####支持度（support）：一个项集或者规则在所有事务中出现的频率，σ(X):表示项集X的支持度计数项集X的支持度：s(X)=σ(X)/N规则X==&gt;Y表示物品集X对物品集Y的支持度，也就是物品集X和物品集Y同时出现的概率某天共有100个顾客到商场购买物品，其中有30个顾客同时购买了啤酒和尿布，那么上述的关联规则的支持度就是30％####置信度（confidence）：确定Y在包含X的事务中出现的频繁程度。c(X → Y) = σ(X∪Y)/σ(X)p（Y│X）＝p（XY）/p(X)。置信度反应了关联规则的可信度—购买了项目集X中的商品的顾客同时也购买了Y中商品的可能性有多大购买薯片的顾客中有50％的人购买了可乐,则置信度为50％\n\n####(X , Y)==&gt;Z :支持度:交易中包含{X 、 Y 、 Z}的可能性置信度:包含{X 、 Y}的交易中也包含Z的条件概率####设最小支持度为50%, 最小可信度为 50%, 则可得到 :A==&gt;C (50%, 66.6%)C==&gt;A (50%, 100%)\n若关联规则X-&gt;Y的支持度和置信度分别大于或等于用户指定的最小支持率minsupport和最小置信度minconfidence，则称关联规则X-&gt;Y为强关联规则，否则称关联规则X-&gt;Y为弱关联规则。\n####提升度（lift）：物品集A的出现对物品集B的出现概率发生了多大的变化lift（A==&gt;B）=confidence（A==&gt;B）/support(B)=p(B|A)/p(B)现在有** 1000 ** 个消费者，有** 500** 人购买了茶叶，其中有** 450人同时** 购买了咖啡，另** 50人** 没有。由于** confidence(茶叶=&gt;咖啡)=450/500=90%** ，由此可能会认为喜欢喝茶的人往往喜欢喝咖啡。但如果另外没有购买茶叶的** 500人** ，其中同样有** 450人** 购买了咖啡，同样是很高的** 置信度90%** ,由此，得到不爱喝茶的也爱喝咖啡。这样看来，其实是否购买咖啡，与有没有购买茶叶并没有关联，两者是相互独立的，其** 提升度90%/[(450+450)/1000]=1** 。由此可见，lift正是弥补了confidence的这一缺陷，if lift=1,X与Y独立，X对Y出现的可能性没有提升作用，其值越大(lift&gt;1),则表明X对Y的提升程度越大，也表明关联性越强。####Leverage 与 Conviction的作用和lift类似，都是值越大代表越关联Leverage : P(A,B)-P(A)P(B)Conviction:P(A)P(!B)/P(A,!B）####所有指标的计算公式：\n接下来获取电影数据集中个电影类型之间的关联关系：anaconda安装mlxtend包\nconda install -c conda-forge mlxtend\nimport pandas as pd\nfrom mlxtend.frequent_patterns import apriori\nfrom mlxtend.frequent_patterns import association_rules\nmovie_genres &#x3D; pd.DataFrame(data,columns&#x3D;[&#39;original_title&#39;,&#39;genres&#39;])\nmovies_ohe &#x3D; movie_genres.drop(&#39;genres&#39;,1).join(movie_genres.genres.str.get_dummies())\nmovies_ohe.shape#(10866, 21)\nmovies_ohe.set_index([&#39;original_title&#39;],inplace&#x3D;True)\nfrequent_itemsets_movies &#x3D; apriori(movies_ohe,use_colnames&#x3D;True, min_support&#x3D;0.025)\nresult &#x3D; [i for i in frequent_itemsets_movies.itemsets if len(i)&gt;1]\nlen(result)#37\nrules_movies &#x3D;  association_rules(frequent_itemsets_movies, metric&#x3D;&#39;lift&#39;, min_threshold&#x3D;1.25)\nrules_movies[(rules_movies.lift&gt;4)].sort_values(by&#x3D;[&#39;lift&#39;], ascending&#x3D;False)\n\n也挺符合常理哈。\n","slug":"python关联分析（apriori算法）","date":"2021-02-28T14:05:20.000Z","categories_index":"python","tags_index":"数据分析","author_index":"弦好想断"},{"id":"d3beaa185b8db8984fb4d7e370d2c9a0","title":"我们这样的人，谈爱都太奢侈","content":"爱是人类的本能，可是成年人的世界里，所谓的真心，更多的换来的却是失落与沮丧，渐渐的他们学会了伪装与克制，变得沉默且凉薄。前几天和朋友闲聊，突然听到现如今找女朋友就像找大熊猫一样，哈哈哈，还是大学的时候投资好啊，现在估计早都不担心了。\n房子带来的安稳，汽车带来的便捷，手机平板带来的时尚，不早不晚的都让九零后赶上了，他们也许是物质体验最丰富的一代人，但同时也会是对物质需求最挑剔的一代人。同学不满领导安排毅然辞去了干了不满五个月的工作；朋友上次分手后，突然告诉我决定今年国庆结婚，和一个认识半年左右的女孩；从小一起长大的兄弟在犹豫该不该留在大城市发展，毕竟对于房价有时候也会低声苦笑。\n雷军先生说过：“现在的物质已经很丰富了，现在的年轻人面对的可能更多的是精神上的痛苦”。人口比例失衡带来的红利，就像是资本家看上的蓝海市场，在物质与精神的两相施压下，猫猫狗狗都成了家居必备物种。谁能想到许多年后的今天人类会隔着彩色的屏幕去感受人情冷暖，体验世态炎凉。物欲横流的世界，浮躁成了这个时代最真实的写照。我们都想要牵了手就能结婚的爱情，却活在了一个上了床都不一定有结果的年代。那个男人他终究还是没有活成你希望的样子，可是你知道吗，在他会鼓起勇气和你表达之前，真的是会考虑现在和未来的呀。为了能配得上你，都还在沉住气不停的坚持呢。\n有时候会有一种奇怪的感受，如果说读书时代遇到问题所面对的失落，是为了锻炼克服困难的能力，从而学习到更好的思维方式；参加高考上大学遭遇就业压力所承受的焦虑，是要鞭策自己为了过上更好的生活实现所谓的个人理想而努力。但当你真正走上社会的那一霎那，发现一切都不像你想象得那么有条有理，你可能还是会需要蛰伏很长一段时间。你拼尽全力的想要去缩短需要奋斗的距离，却还是会难以扛住资本家构造蓝图时行业给出的亲民价。我们这样的人，谈爱都太奢侈。\n就写到这吧，闲来几笔，一个人还是要心无所恃，随遇而安。\n","slug":"我们这样的人，谈爱都太奢侈","date":"2020-09-24T03:17:06.000Z","categories_index":"随笔","tags_index":"成长，旧时光","author_index":"弦好想断"},{"id":"c7aee1b1cd00f742e926b01d61d89c81","title":"python-学生信息管理系统（学的是思维）","content":"学生管理系统应具备的功能\n添加学生及成绩信息\n将学生信息保存到文件中\n修改和删除学生信息\n查询学生信息\n根据学生成绩进行排序\n统计学生的总分\n\n\n主程序import os\nfilename &#x3D; &#39;student.txt&#39;\ndef main():\n    while True:\n        menum()\n        choice &#x3D; int(input(&quot;请选择:&quot;))\n        if choice in [0,1,2,3,4,5,6,7]:\n            if choice&#x3D;&#x3D;0:\n                answer &#x3D; input(&quot;您确定要退出系统吗?y&#x2F;n&quot;)\n                if answer &#x3D;&#x3D; &#39;y&#39; or answer &#x3D;&#x3D; &#39;Y&#39;:\n                    print(&quot;谢谢您的使用！&quot;)\n                    break #退出系统\n                else:\n                    continue\n            elif choice&#x3D;&#x3D;1:\n                insert()\n            elif choice&#x3D;&#x3D;2:\n                search()\n            elif choice&#x3D;&#x3D;3:\n                delete()\n            elif choice&#x3D;&#x3D;4:\n                modify()\n            elif choice &#x3D;&#x3D;5:\n                sort()\n            elif choice &#x3D;&#x3D;6:\n                total()\n            elif choice&#x3D;&#x3D;7:\n                show()\ndef menum():\n    print(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;学生信息管理系统&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;)\n    print(&quot;----------------------------------功能菜单-----------------------------------&quot;)\n    print(&quot;\\t\\t\\t\\t\\t\\t1.录入学生信息&quot;)\n    print(&quot;\\t\\t\\t\\t\\t\\t2.查找学生信息&quot;)\n    print(&quot;\\t\\t\\t\\t\\t\\t3.删除学生信息&quot;)\n    print(&quot;\\t\\t\\t\\t\\t\\t4.修改学生信息&quot;)\n    print(&quot;\\t\\t\\t\\t\\t\\t5.排序&quot;)\n    print(&quot;\\t\\t\\t\\t\\t\\t6.统计学生总人数&quot;)\n    print(&quot;\\t\\t\\t\\t\\t\\t7.显示所有学生信息&quot;)\n    print(&quot;\\t\\t\\t\\t\\t\\t0.退出&quot;)\n    print(&quot;----------------------------------------------------------------------------&quot;)\n保存数据def save(lst):\n    try:\n        stu_txt &#x3D; open(filename,&#39;a&#39;,encoding&#x3D;&#39;utf-8&#39;)#以追加的模式进行打开\n    except:\n        stu_txt &#x3D; open(filename,&#39;w&#39;,encoding &#x3D; &#39;utf-8&#39;)\n    for item in lst:\n        stu_txt.write(str(item)+&#39;\\n&#39;)\n    stu_txt.close()\n插入数据\ndef insert():\n    student_list &#x3D; []\n    while True:\n        id &#x3D; input(&#39;请输入ID(如1001):&#39;)\n        if not id:\n            break\n        name &#x3D; input(&quot;请输入姓名:&quot;)\n        if not name:\n            break\n        try:\n            english_score &#x3D; int(input(&quot;请输入英语成绩:&quot;))\n            python_score&#x3D; int(input(&quot;请输入Python成绩:&quot;))\n            java_score &#x3D; int(input(&quot;请输入Java成绩:&quot;))\n        except:\n            print(&quot;输入无效，不是整数类型，请重新输入...&quot;)\n            continue\n        #将录入的学生信息保存到字典中\n        student &#x3D; &#123;&#39;id&#39;:id,&#39;name&#39;:name,&#39;english&#39;:english_score,&#39;python&#39;:python_score,&#39;java&#39;:java_score&#125;\n        #将学生信息添加到列表中\n        student_list.append(student)\n        answer &#x3D; input(&quot;是否将继续添加？y&#x2F;n\\n&quot;)\n        if answer&#x3D;&#x3D;&#39;y&#39;:\n            continue\n        else:\n            break\n    #调用save()函数\n    save(student_list)\n    print(&quot;学生信息录入完毕！！！&quot;)\n查询数据def search():\n    student_query &#x3D; []\n    while True:\n        id &#x3D; &#39;&#39;\n        name &#x3D; &#39;&#39;\n        if os.path.exists(filename):\n            mode &#x3D; input(&quot;按ID查找请输入1，按姓名查找请输入2&quot;)\n            if mode &#x3D;&#x3D;&#39;1&#39;:\n                id &#x3D; input(&quot;请输入学生ID&quot;)\n            elif mode &#x3D;&#x3D;&#39;2&#39;:\n                name &#x3D; input(&quot;请输入学生姓名&quot;)\n            else:\n                print(&quot;您的输入有误，请重新输入&quot;)\n                search()\n            with open(filename,&#39;r&#39;,encoding&#x3D;&#39;utf-8&#39;) as rfile:\n                student &#x3D; rfile.readlines()\n                for item in student:\n                    d &#x3D; dict(eval(item))\n                    if id!&#x3D;&#39;&#39;:\n                        if d[&#39;id&#39;] &#x3D;&#x3D; id:\n                            student_query.append(d)\n                    if name!&#x3D;&#39;&#39;:\n                        if d[&#39;name&#39;] &#x3D;&#x3D;name:\n                            student_query.append(d)\n            #显示查询结果\n            show_student(student_query)\n            #清空列表\n            student_query.clear()\n            answer &#x3D; input(&quot;是否继续查询y&#x2F;n\\n&quot;)\n            if answer&#x3D;&#x3D;&#39;y&#39; or answer&#x3D;&#x3D;&#39;Y&#39;:\n                continue\n            else:\n                break\n        else:\n            print(&quot;暂未保存学生信息&quot;)\n            return\n\ndef show_student(lst):\n    if len(lst) &#x3D;&#x3D;0:\n        print(&quot;没有查询到学生信息，无数据显示！！！&quot;)\n        return\n    #定义标题显示格式\n    format_title &#x3D; &#39;&#123;:^6&#125;\\t&#123;:^12&#125;\\t&#123;:^8&#125;\\t&#123;:^10&#125;\\t&#123;:^10&#125;\\t&#123;:^8&#125;&#39;\n    print(format_title.format(&#39;ID&#39;,&#39;姓名&#39;,&#39;英语成绩&#39;,&#39;Python成绩&#39;,&#39;Java成绩&#39;,&#39;总成绩&#39;))\n    #定义内容显示格式\n    format_data &#x3D; &#39;&#123;:^6&#125;\\t&#123;:^12&#125;\\t&#123;:^8&#125;\\t&#123;:^10&#125;\\t&#123;:^10&#125;\\t&#123;:^8&#125;&#39;\n    for item in lst:\n        print(format_data.format(item.get(&#39;id&#39;),\n                                item.get(&#39;name&#39;),\n                                  item.get(&#39;english&#39;),\n                                  item.get(&#39;python&#39;),\n                                  item.get(&#39;java&#39;),\n                                 int(item.get(&#39;english&#39;))+int(item.get(&#39;python&#39;))+int(item.get(&#39;java&#39;))\n                                 ))\n删除数据def delete():\n    while True:\n        student_id &#x3D; input(&quot;请输入要删除的学生的ID：&quot;)\n        if student_id !&#x3D;&#39;&#39;:\n            if os.path.exists(filename):\n                with open(filename,&#39;r&#39;,encoding&#x3D;&#39;utf-8&#39;) as file:\n                    student_old &#x3D; file.readlines()#逐行读取，按行生成一个列表\n            else:\n                student_old &#x3D;[]\n            flag &#x3D; False#标记是否删除\n            if student_old:#判断原有文件内容是否为空，如果有内容就打开并写入东西\n                with open(filename,&#39;w&#39;,encoding&#x3D;&#39;utf-8&#39;) as wfile:\n                    d&#x3D;&#123;&#125;\n                    for item in student_old:\n                        d &#x3D; dict(eval(item))#将字符串转换为字典\n                        if d[&#39;id&#39;]!&#x3D;student_id:\n                            wfile.write(str(d)+&quot;\\n&quot;)\n                        else:\n                            flag&#x3D;True#定义这个标志，同时也没有将变量进行写入，即为删除\n                    if flag:\n                        print(f&quot;id为&#123;student_id&#125;的学生信息已经被删除。&quot;)\n                    else:\n                        print(f&quot;没有找到ID为&#123;student_id&#125;的学生信息。&quot;)\n            else:\n                print(&quot;无学生信息。&quot;)\n                break\n            show()#删完之后要重新显示学生信息\n            answer &#x3D; input(&quot;是否继续删除？y&#x2F;n\\n&quot;)\n            if answer&#x3D;&#x3D;&#39;y&#39; or answer &#x3D;&#x3D; &quot;Y&quot;:\n                continue\n            else:\n                break\n更新数据def modify():\n    show()\n    if os.path.exists(filename):\n        with open(filename,&#39;r&#39;,encoding&#x3D;&#39;utf-8&#39;) as rfile:\n            student_old &#x3D; rfile.readlines()\n    else:\n        return\n    student_id &#x3D; input(&quot;请输入要修改的学员的ID：&quot;)\n    with open(filename,&#39;w&#39;,encoding&#x3D;&#39;utf-8&#39;) as wfile:\n        for item in student_old:\n            d &#x3D; dict(eval(item))\n            if d[&#39;id&#39;]&#x3D;&#x3D;student_id:#找到要修改的相关id\n                print(&quot;找到学生信息，可以修改他的相关信息了！&quot;)\n                while True:\n                    try:\n                        d[&#39;name&#39;]&#x3D;input(&quot;请输入姓名：&quot;)\n                        d[&#39;english&#39;] &#x3D;input(&quot;请输入英语成绩：&quot;)\n                        d[&#39;python&#39;] &#x3D; input(&quot;请输入Python成绩：&quot;)\n                        d[&#39;Java&#39;] &#x3D; input(&quot;请输入Java成绩：&quot;)\n                    except:\n                        print(&quot;您的输入有误，请重新输入！！！&quot;)\n                    wfile.write(str(d)+&quot;\\n&quot;)\n                    print(&quot;修改成功&quot;)\n\n            else:\n                wfile.write(str(d)+&quot;\\n&quot;)\n        answer &#x3D; input(&quot;是否继续修改其他学校信息？y&#x2F;n\\n&quot;)\n        if answer&#x3D;&#x3D;&#39;y&#39; or answer &#x3D;&#x3D;&#39;Y&#39;:\n            modify()\n数据排序def sort():\n    if os.path.exists(filename):\n        with open(filename, &#39;r&#39;, encoding&#x3D;&#39;utf-8&#39;) as rfile:\n            student &#x3D; rfile.readlines()\n        student_new &#x3D; []\n        for item in student:\n            d &#x3D; dict(eval(item))\n            student_new.append(d)\n    else:\n        return\n    asc_or_desc &#x3D; input(&quot;请选择(0.升序 1.降序)&quot;)\n    if asc_or_desc&#x3D;&#x3D;&#39;0&#39;:\n        asc_or_desc_bool &#x3D; False\n        pass\n    elif asc_or_desc&#x3D;&#x3D;&#39;1&#39;:\n        asc_or_desc_bool &#x3D; True\n        pass\n    else:\n        print(&quot;您的输入有误，请重新输入！&quot;)\n        sort()\n    mode &#x3D; input(&quot;请选择排序方式(1.按英语成绩排序 2.按Python成绩排序 3.按Java程序排序 0.按总成绩排序)&quot;)\n    if mode&#x3D;&#x3D;&#39;1&#39;:\n        student_new.sort(key&#x3D;lambda x:x[&#39;english&#39;],reverse&#x3D;asc_or_desc_bool)\n    elif mode&#x3D;&#x3D;&#39;2&#39;:\n        student_new.sort(key&#x3D;lambda x:x[&#39;python&#39;],reverse&#x3D;asc_or_desc_bool)\n    elif mode&#x3D;&#x3D;3:\n        student_new.sort(key&#x3D;lambda x:x[&#39;java&#39;],reverse&#x3D;asc_or_desc_bool)\n    elif mode&#x3D;&#x3D;&#39;0&#39;:\n        student_new.sort(key&#x3D;lambda x:x[&#39;english&#39;]+x[&#39;python&#39;]+x[&#39;java&#39;],reverse&#x3D;asc_or_desc_bool)\n    else:\n        print(&quot;你的输入有误，请重新输入&quot;)\n        sort()\n    show_student(student_new)\n显示数据def total():\n    if os.path.exists(filename):\n        with open(filename,&#39;r&#39;,encoding&#x3D;&#39;utf-8&#39;) as rfile:\n            students &#x3D; rfile.readlines()\n            if students:\n                print(f&quot;一共有&#123;len(students)&#125;名学生&quot;)\n            else:\n                print(&quot;还没有录入学生信息&quot;)\n    else:\n        print(&quot;暂未存学生相关信息&quot;)\ndef show():\n    student_ls &#x3D; []\n    if os.path.exists(filename):\n        with open(filename,&#39;r&#39;,encoding&#x3D;&#39;utf-8&#39;) as rfile:\n            students &#x3D; rfile.readlines()\n            for item in students:\n                student_ls.append(eval(item))\n            if student_ls:\n                show_student(student_ls)\n            else:\n                print(&quot;还没有保存学生信息&quot;)\n    else:\n        print(&quot;没有发现相应数据文件&quot;)\n\n\nif __name__ &#x3D;&#x3D;&#39;__main__&#39;:\n    main()\n写在结尾\n打包成exe需要在终端激活环境后运行 pip install PyIntaller下载好之后再执行 pyinstaller -F D:\\Studentsys\\stusystem.py  \n\n-F后面是完整路径以及文件名https://www.bilibili.com/video/BV1wD4y1o7AS?p=135&amp;spm_id_from=pageDriver娟姐yyds! \n","slug":"python-学生信息管理系统（学的是思维）","date":"2020-09-16T10:35:07.000Z","categories_index":"python","tags_index":"数据分析","author_index":"弦好想断"},{"id":"35324116e18b1ad18922119ba78fc7f6","title":"python酒类数据分析","content":"\n一、数据概述‘id’,’name’,’price’,’sales’,’ad_word’,’buy_act’,’vote_count’,’url’,’date’,’brand’分别为销售数据的商品ID，商品名称，单价，销量，广告词，促销活动，链接，日期，品牌。以及自构属性‘amount’：销售额，‘month’：月份，‘price_level’：价格区间。\n二、提出问题1、行业大盘近期（2018/2/27）表现？各价位段表现？总体表现，各价位表现，哪个价位的产品最火，各厂家表现？近期各行业的广告词、促销活动怎么样2、行业大盘总体态势怎样？销量与评论数、单价的关系？时间序列下的行业产品走势？3、如何评价泸州老窖品牌？(可从多角度，规模增长趋势、产品结构等)产品规模、增长趋势、友商竞争、行业水平？\n三、行业大盘近周期（2018/2/27）表现？各价位段表现？行业大盘2018/2/27总体表现\n2018/2/27行业的总销售量为5.663030e+05，总评价数为1.255655e+06，总销售额达1.842307e+08。平均单价价格为417元，平均销售642份，平均销售额达209115.4元单价中位数199，说明少数高价位的酒提高了总体均值销量中位数为148，说明少数及销量高的天数提升了平均交易量销售额中位数低于总体均值相差巨大，可能存在爆发交易的情况。一天中出现的最高交易量是21685份订单，最高交易额是65011630元，最高单价的白酒为6588元，最高评论数为67514条，最低为0条。各价位表现\n在行业大盘最近一个周期内，可以看到销量最好和评论数最高的均是是100-200价位的白酒。在价位50以下白酒销量和评论数出现大反差，在销量差距悬殊的情况下，该类白酒的评论数超过200-500价位白酒的评论数，但是销量偏低说明该类白酒在市场中有较高流行度的同时可能也存在较多的槽点。中等价位（100-500）是市场的主要潮流所在，由中价位向低价位过度的产品（50-100）同样能稳住市场，获得较高的销量与人气。3000以上的销量与评论数极低，符合当今社会人们财富资源分配或生活消费水平的差距，高消费人群只占极少数。\n\n1000-3000价位席卷市场，高单价情况下即时在低销量时也能远超越其他价位销售额。\n\n基本呈现单价越高，评论数越少。人们总是低价商品的要求过于执着？\n\n由于其1000-3000单价基数大，导致金额最大\n各厂家表现\n最近一周期五粮液销量最高达到10万瓶以上，远领先于其他厂家。\n\n五粮液产品市场评论数最高，应该是广告宣传或者产品质量做得好。\n\n茅台近期销售总额位于行业最高水平，销售额近7500万。五粮液可能由于产品单价偏低，销售总额位居第三，接近2000万。\n最近一个周期广告、促销活动怎么做的？\n广告词一以‘天猫配送’，‘正品保证’等为主要标语，‘东方习酒’，‘猫超自营’，‘地道北京味’也是主要宣传方向。\n\n促销活动主要以‘满一1或2送任意一件赠品，赠完为止’作为主要促销活动。\n四、行业大盘总体态势怎样？销量与单价、评论数的关系\n评论数量变化与销量基本呈线性变化。评论数代表市场反应，市场热度越高，销量越高。\n\n单价与销量基本成反比例变化。单价越高，销量越低，单价越低，销量越高。###时间序列下的行业产品走势\n200-500价位段的商品销量呈上升趋势，0-50和50-100的商品在2017年11月上升后出现持续下降，100-200的商品在上升后保持平稳，基本站稳市场。500-3000区间内商品在同年12月后出现小范围增长，因其单价基数较大，可能引起销售额大幅增长。\n\n除0-50和3000以上产品外，其他商品都在2017年11月后出现销售额显著增长，推测可能是双十一以及其他促销活动，但是对0-50和3000以上的商品销售状态基本无影响。1000-3000区间商品在2017年12月过后出现直线式增长，100-500区间产品作为市场主力也出现增长趋势。\n\n3000月以上的酒类在11月出现价格大额下跌，其他区间商品单价均走势平稳。\n五、泸州老窖自身增长的趋势，产品结构，行业水平泸州老窖产品规模\n泸州老窖品牌主打50-500价位产品覆盖市场，其中3000+超高价酒类占比与0-50低价品类占比最低，均低于500-3000档位，说明泸州老窖在市场的品牌形象与战略目标是做好中高端酒类产品。\n\n在2017年12月产品规模突然增大，应该是与行业竞争或市场需求相关。 \n\n销量在十一月份出现大幅增长，持续到次年一月份出现显著下降。\n\n总销售额与销量表现相似，也是在十一月份出现大幅增长，持续到次年一月份出现显著下降。\n\n0-50区间产品在十一月后大幅增长，后持续衰弱。50-500区间商品同期均出现显著增长，后缓慢下降趋于稳定。\n\n200-500与1000-3000区间商品由于其单价基数较大，在同年十一月销量保证的前提下，出现大幅增长。\n\n3000+产品在2017年7月-9月出现波动后趋于平稳。\n\n17年9月可能出现了一些问题，除500-1000区间外，都出现了先增后降的趋势。\n那种广告词、促销标语出现的最多\n该品牌主打广告关键词： ‘’限时直降‘’，‘甄选好货’，‘厂家直供’。\n\n主打的促销标语为 ‘’送任意一件赠品，赠完即止‘’。\n选择牛栏山作为泸州老窖竞争对手\n牛栏山品牌在产品布局上和泸州老窖都是主打50-500价位段商品布局，但是牛栏山在0-50上的产品数多于500-1000价位的产品数量。且没有3000元以上产品上市，可见牛栏山品牌试图留住中端价位产品客户，拉拢低价位产品客户的战略方针。\n\n与泸州老窖相似均在十二月出现了较大幅度的增长。\n\n泸州老窖只在200-300和超1000元以上的产品销量小范围领先友商，但由于单价基数较大，可能会有意想不到的效果哦\n\n泸州老窖销售额仅在200-500和1000元以上三个价位段领先友商，在50-200价位，销售额较大程度低于友商。\n\n除了200-500和1000以上价位的产品，泸州老窖品牌产品收到的市场评论与反馈均低于友商，可见友商的宣传力度或产品口碑在市场中占有较高热度 。\n\n\n可以看到两个品牌的销售额主要来源产品类别有明显差异。\n泸州老窖在行业的水平如何\n\n泸州老窖位于行业的上游水平，产品规模完善，各价位商品数量布局体现了明确的行业目标：要做中高端酒类产品的佼佼者。且不放弃低价位的0-50系列产品，全面覆盖市场，在给定的时间数据中，各区间段产品除0-50与3000+以外，其他商品的销量与销售额均呈持续缓慢上升趋势。可以看到该企业处于一个蓬勃向上，逐步冲向高端的行业发展状态。\n六、分析结论1、近期行业呈现蓬勃向上的发展状态，0-50价位产品的销量与评论数出现较大市场反差，100-200价位段的商品销量最火，位于市场销量及销售额榜首的是茅台品牌，五粮液以市场获评数最高位居榜首。行业广告词以‘天猫配送’，‘正品保证’等作为主要标语，以‘满1或2件送任意一件赠品，赠完为止’作为主要促销活动。2、行业总体发展十分成熟，各品牌产品竞争力都十分明显，销量与评论基本呈正相关线性关系，与单价成反比例关系，100-500区间产品销量作为市场主流，1000元以上产品可能在销售额上反超其他高销量产品，双十一对市场的刺激反响极为强烈。3、泸州老窖主打中高端酒类产品，全价位品类布局全面，综合实力处于全行业上游水平。销量受双十一影响显著，导致200-500与1000-3000区间商品销售额大幅增长。该品牌主打广告关键词： ‘’限时直降‘’，‘甄选好货’，‘厂家直供’。主要促销活动为 ‘’送任意一件赠品，赠完即止‘’。其总体销售额主要来源于100-3000价位产品，相比牛栏山不相上下，在中高价位品类优势明显，0-100价位段还有较大进步空间。\n七、python代码导入包，设定字体和画图风格import pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\n%matplotlib inline\nimport seaborn as sns\nfrom wordcloud import WordCloud\nplt.rcParams[&#39;font.sans-serif&#39;] &#x3D; [&#39;SimHei&#39;]#显示中文\nplt.style.use(&#39;ggplot&#39;)\n导入并清洗数据#导入数据\npath &#x3D; &#39;D:&#x2F;python_data_file&#x2F;Alcohol.xlsx&#39;\ndef load_alcohol_data(path):\n    df &#x3D; pd.read_excel(path)\n    df.columns &#x3D; [&#39;id&#39;,&#39;name&#39;,&#39;price&#39;,&#39;sales&#39;,&#39;ad_word&#39;,&#39;buy_act&#39;,&#39;vote_count&#39;,&#39;url&#39;,&#39;date&#39;,&#39;brand&#39;]\n    df &#x3D; df[df.price.notnull()]\n    df[&#39;amount&#39;] &#x3D; df[&#39;sales&#39;]*df[&#39;price&#39;]\n    df[&#39;month&#39;] &#x3D; df.date.values.astype(&#39;datetime64[M]&#39;)#日期时间序列转化为月份时间序列\n    return df\ndf &#x3D; load_alcohol_data(path)\n#对酒类单价分层\ndef price_level(data):\n    a&#x3D;[]\n    for i in data.price:\n        if i &lt;50:\n            a.append(&#39;0-50&#39;)\n        elif i &lt;100:\n            a.append(&#39;50-100&#39;)\n        elif i &lt;200:\n            a.append(&#39;100-200&#39;)\n        elif i&lt;500:\n            a.append(&#39;200-500&#39;)\n        elif i &lt;1000:\n            a.append(&#39;500-1000&#39;)\n        elif i&lt;3000:\n            a.append(&#39;1000-3000&#39;)\n        else:\n            a.append(&#39;3000+&#39;)\n    data[&#39;price_level&#39;] &#x3D; a\n    data &#x3D; data.reset_index(drop&#x3D;True)\n    return data\ndf &#x3D; price_level(df)\nrecent_df &#x3D; df[df.date&#x3D;&#x3D;&#39;2018-02-27&#39;]\nrecent_df[[&#39;sales&#39;,&#39;vote_count&#39;,&#39;amount&#39;]].sum()\nrecent_df.describe()\nlzlj_df &#x3D; df[df.brand&#x3D;&#x3D;&#39;泸州老窖&#39;].reset_index(drop&#x3D;True)\nlzlj_df &#x3D; price_level(lzlj_df)\nlzlj_df.describe()\n近期各厂家的表现#各厂家的表现就在这了\nall_brand &#x3D; recent_df.groupby(&#39;brand&#39;)[[&#39;sales&#39;,&#39;vote_count&#39;,&#39;amount&#39;]].sum().sort_values(by&#x3D;\n&#39;amount&#39;,ascending &#x3D; True).reset_index()\nall_brand.sales.plot.bar()\nplt.title(&#39;各厂家销量对比&#39;)\nall_brand.vote_count.plot.bar()\nplt.title(&#39;各厂家评论数&#39;)\nall_brand.amount.plot.bar()\nplt.title(&#39;各厂家销售额&#39;)\n\n画柱状图#x写个画图函数，不然太麻烦了\ndef pic_barh(data,tit,xbel,ybel):\n    data.sort_values().plot.barh(figsize&#x3D;(12,6))\n    plt.title(tit,fontsize &#x3D; 20)\n    plt.xlabel(xbel,fontsize &#x3D; 20)\n    plt.ylabel(ybel,fontsize &#x3D; 20)\n    plt.show()\npic_barh(level_performance_mean.price,&#39;近期平均价格表现&#39;,&#39;价格&#39;,&#39;区间&#39;)\npic_barh(level_performance_sum.amount,&#39;近期销售额表现&#39;,&#39;金额&#39;,&#39;区间&#39;)\npic_barh(level_performance_mean.vote_count,&#39;近期评论表现&#39;,&#39;评论数&#39;,&#39;区间&#39;)\npic_barh(level_performance_mean.amount,&#39;近期平均金额表现&#39;,&#39;金额&#39;,&#39;区间&#39;)\n近期各价位段表现level_performance_sum &#x3D; recent_df.groupby(&#39;price_level&#39;)[\n&#39;sales&#39;,&#39;vote_count&#39;,&#39;amount&#39;].sum().sort_values(by&#x3D;&#39;sales&#39;,ascending&#x3D;False)\nlevel_performance_mean &#x3D; recent_df.groupby(&#39;price_level&#39;)[\n&#39;price&#39;,&#39;sales&#39;,&#39;vote_count&#39;,&#39;amount&#39;].mean().sort_values(by&#x3D;&#39;sales&#39;,ascending&#x3D;False)\n#绘制利润与评论数柱状图\nlevel_performance_sum.loc[:,[&#39;sales&#39;,&#39;vote_count&#39;]].plot.bar(figsize&#x3D;(12,6))\n寻找竞争品牌#想写个函数找出泸州老窖的上下各相邻两个的品牌，也就是它的竞争品牌\ndef lookup_name(data):\n    for i in range(len(data)):\n        if data.loc[i,&#39;brand&#39;] &#x3D;&#x3D;&#39;泸州老窖&#39;:\n            return [data.loc[i-1,&#39;brand&#39;],data.loc[i-2,&#39;brand&#39;],data.loc[i+1,&#39;brand&#39;],data.loc[i+2,&#39;brand&#39;]]\n        else:\n            continue\n#按品牌分组求均值，再分别按价格、销量和金额排序，然后找出竞争品牌\ndf_brand_price_mean &#x3D; df.groupby(&#39;brand&#39;,as_index&#x3D;False)[[\n    &#39;price&#39;,&#39;sales&#39;,&#39;amount&#39;]].mean().sort_values(by&#x3D;&#39;price&#39;,ascending&#x3D;True).reset_index(drop&#x3D;True)\nlookup_name(df_brand_price_mean)#[&#39;汾酒&#39;, &#39;珍酒&#39;, &#39;剑南春&#39;, &#39;白云边&#39;]\ndf_brand_sales_mean&#x3D;df.groupby(&#39;brand&#39;,as_index&#x3D;False)[[\n    &#39;price&#39;,&#39;sales&#39;,&#39;amount&#39;]].mean().sort_values(by&#x3D;&#39;sales&#39;,ascending&#x3D;True).reset_index(drop&#x3D;True)\ndf_brand_amount_mean&#x3D; df.groupby(&#39;brand&#39;,as_index&#x3D;False)[[\n    &#39;price&#39;,&#39;sales&#39;,&#39;amount&#39;]].mean().sort_values(by&#x3D;&#39;amount&#39;,ascending&#x3D;True).reset_index(drop&#x3D;True)\n#按品牌分组求和，再分别按价格、销量和金额排序，然后找出竞争品牌\ndf_brand_amount_sum&#x3D;df.groupby(&#39;brand&#39;,as_index&#x3D;False)[[\n    &#39;sales&#39;,&#39;amount&#39;]].sum().sort_values(by&#x3D;&#39;amount&#39;,ascending &#x3D; True).reset_index(drop&#x3D;True)\ndf_brand_sales_sum&#x3D;df.groupby(&#39;brand&#39;,as_index&#x3D;False)[[\n    &#39;sales&#39;,&#39;amount&#39;]].sum().sort_values(by&#x3D;&#39;sales&#39;,ascending &#x3D; True).reset_index(drop&#x3D;True)\na_sums &#x3D; set(lookup_name(df_brand_amount_sum)+lookup_name(df_brand_sales_sum))\na_means &#x3D; set(lookup_name(df_brand_price_mean)+lookup_name(df_brand_sales_mean)+lookup_name(df_brand_amount_mean))\ns &#x3D; set(list(a_means)+list(a_sums))\n#&#123;&#39;习酒&#39;,&#39;五粮液&#39;,&#39;剑南春&#39;,&#39;劲酒&#39;,&#39;古井贡酒&#39;, &#39;水井坊&#39;, &#39;江小白&#39;, &#39;汾酒&#39;, &#39;洋河&#39;, &#39;牛栏山&#39;,&#39;珍酒&#39;,\n# &#39;白云边&#39;,&#39;红星&#39;,&#39;茅台&#39;&#125; 选取剑南春 古井贡酒 牛栏山 五粮液作为泸州老窖的竞争对手\n生成词云图#提取广告词字符串\ndef ad_words_str(data):\n    ad_words_list &#x3D; []\n    for x in data.ad_word.dropna():\n        ad_words_list.append(x)\n    ad_words_list &#x3D; &#39;&#39;.join(ad_words_list)\n    return ad_words_list\n#提取促销活动字符串\ndef buy_act_str(data):\n    buy_act_list&#x3D;[]\n    for x in data.buy_act.dropna():\n        buy_act_list.append(x)\n    buy_act_list &#x3D; &#39;&#39;.join(buy_act_list)\n    return buy_act_list\n#生成词云\ndef pic_words(keywords_list):\n    keywords_list.replace(&#39;\\s&#39;,&#39;&#39;)#去除字符串中空字符串（\\s用于匹配空白字符，可能是空格、制表符、其他空白））\n    font &#x3D; &#39;C:\\Windows\\Fonts\\msyh.ttc&#39;\n    wordcloud &#x3D; WordCloud(background_color&#x3D;&#39;white&#39;,max_words&#x3D;3000,scale&#x3D;1.5,font_path&#x3D;font).generate(keywords_list)\n    plt.figure(figsize&#x3D;(14,8))\n    plt.imshow(wordcloud)\n    plt.axis(&#39;off&#39;)\n    plt.show()\nlistb &#x3D; ad_words_str(lzlj_df)+buy_act_str(lzlj_df)\n#行业大盘最近一个周期的词云\npic_words(ad_words_str(recent_df))\npic_words(buy_act_str(recent_df))\npic_words(ad_words_str(lzlj_df))\npic_words(buy_act_str(lzlj_df))\n画走势图df.plot.scatter(x&#x3D;&#39;price&#39;,y&#x3D;&#39;sales&#39;)\nplt.title(&#39;销量与单价&#39;)\ndf.plot.scatter(x&#x3D;&#39;vote_count&#39;,y&#x3D;&#39;sales&#39;)\nplt.title(&#39;销量与评论数&#39;)\n#写个画图函数，它不香吗\ndef pic_trend(data,val,agg,tit,ylab):\n    a_sum &#x3D; data.pivot_table(\n        index&#x3D;&#39;price_level&#39;,columns&#x3D;&#39;month&#39;,values&#x3D;val,aggfunc&#x3D;agg).fillna(0).T\n    plt.figure(figsize&#x3D;(12,6))\n    a_sum.plot()\n    plt.title(tit,fontsize&#x3D;20)\n    plt.ylabel(ylab,fontsize&#x3D;15)\n    plt.show()\npic_trend(lzlj_df,&#39;sales&#39;,&#39;sum&#39;,&#39;泸州老窖各区间产品销量走势&#39;,&#39;sales&#39;)\npic_trend(lzlj_df,&#39;amount&#39;,&#39;sum&#39;,&#39;泸州老窖销售额走势&#39;,&#39;amount&#39;)\npic_trend(lzlj_df,&#39;price&#39;,&#39;mean&#39;,&#39;泸州老窖产品单价走势&#39;,&#39;price&#39;)\npic_trend(lzlj_df,&#39;vote_count&#39;,&#39;sum&#39;,&#39;泸州老窖产品评论走势&#39;,&#39;vote_count&#39;)\npic_trend(df,&#39;sales&#39;,&#39;sum&#39;,&#39;总体各区间产品销量走势&#39;,&#39;sales&#39;)\npic_trend(df,&#39;amount&#39;,&#39;sum&#39;,&#39;总体产品销售额走势&#39;,&#39;amount&#39;)\npic_trend(df,&#39;price&#39;,&#39;mean&#39;,&#39;总体产品单价走势&#39;,&#39;price&#39;)\npic_trend(df,&#39;vote_count&#39;,&#39;sum&#39;,&#39;总体产品评论走势&#39;,&#39;vote_count&#39;)\n得到各品牌数据#写个函数用来对各品牌数据拆分\ndef df_brand(data,brand):\n    data &#x3D; data[data.brand&#x3D;&#x3D;brand].reset_index(drop&#x3D;True)\n    data &#x3D; price_level(data)\n    data[&#39;amount&#39;] &#x3D; data[&#39;sales&#39;]*data[&#39;price&#39;]\n    return data\n# list_brand &#x3D; [&#39;剑南春&#39;,&#39;古井贡酒&#39;,&#39;牛栏山&#39;,&#39;五粮液&#39;,&#39;泸州老窖&#39;]\n# for i in list_brand:\n#     df_brand(df,i)\n#对该品牌的各价位段进行分组求和\ndef df_brand_groupby_sum(data):\n    data &#x3D; data.groupby(&#39;price_level&#39;).sum().loc[:,[&#39;sales&#39;,&#39;vote_count&#39;,&#39;amount&#39;]]\n    return data\n\n# 剑南春 古井贡酒 牛栏山 五粮液 #各个价格段的销量、评论量、销售额汇总\nlzlj_sum &#x3D; df_brand_groupby_sum(df_brand(df,&#39;泸州老窖&#39;))\njlc_sum &#x3D; df_brand_groupby_sum(df_brand(df,&#39;剑南春&#39;))\ngjgj_sum &#x3D; df_brand_groupby_sum(df_brand(df,&#39;古井贡酒&#39;))\nnls_sum &#x3D; df_brand_groupby_sum(df_brand(df,&#39;牛栏山&#39;))\nwly_sum &#x3D; df_brand_groupby_sum(df_brand(df,&#39;五粮液&#39;))\n画饼图def pic_pie(data,gby,tit):\n    price_count &#x3D; data.groupby(gby).count().reset_index(drop&#x3D;False)\n    fig &#x3D; plt.figure(figsize&#x3D;(16,8))\n    plt.pie(price_count.price,labels&#x3D;price_count[gby],autopct&#x3D;&#39;%.1f%%&#39;)\n    plt.title(tit,fontsize &#x3D; 15)\npic_pie(nls_df,&#39;price_level&#39;,&#39;牛栏山产品价位规模&#39;)\npic_pie(nls_df,&#39;month&#39;,&#39;牛栏山产品月份规模&#39;)\npic_pie(lzlj_df,&#39;price_level&#39;,&#39;泸州老窖产品价位规模&#39;)\npic_pie(lzlj_df,&#39;month&#39;,&#39;泸州老窖产品月份规模&#39;)\n\nfig &#x3D; plt.figure(figsize&#x3D;(16,8))\nplt.pie(lzlj_sum.sales,labels&#x3D;lzlj_sum.index,autopct&#x3D;&#39;%.1f%%&#39;)\nplt.title(&#39;泸州老窖各价位销量图&#39;,fontsize &#x3D; 15)\nfig &#x3D; plt.figure(figsize&#x3D;(16,8))\nplt.pie(nls_sum.vote_count,labels&#x3D;nls_sum.index,autopct&#x3D;&#39;%.1f%%&#39;)\nplt.title(&#39;牛栏山各价位评论数图&#39;,fontsize &#x3D; 15)\n\n#按月份销量变化\nlzlj_df.groupby(&#39;month&#39;).sales.sum().plot()\nplt.title(&#39;销量按月份变化&#39;)\n#总销售额随时间变化\nlzlj_df.groupby(&#39;month&#39;).amount.sum().plot()\nplt.title(&#39;总销售额随时间变化&#39;)\n\ndef pic_bar2(arg):\n    sales_dif &#x3D; nls_sum.sales.reset_index().merge(lzlj_sum[arg].reset_index(),on&#x3D;&#39;price_level&#39;,how&#x3D;&#39;outer&#39;,suffixes&#x3D;[&#39;_nls&#39;,&#39;_lzlj&#39;])\n    sales_dif &#x3D; sales_dif.set_index(&#39;price_level&#39;)\n    plt.figure(figsize&#x3D;(12,10))\n    sales_dif.plot.bar()\n    plt.title(&#39;泸州老窖与牛栏山&#39;+str(arg)+&#39;对比&#39;)\npic_bar2(&#39;sales&#39;)\npic_bar2(&#39;amount&#39;)\npic_bar2(&#39;vote_count&#39;)\n\npic_barh(df_brand_sum.sales,&#39;各品牌销售总量对比&#39;,&#39;销量&#39;,&#39;品牌&#39;)\npic_barh(df_brand_sum.amount,&#39;各品牌销售总金额对比&#39;,&#39;金额&#39;,&#39;品牌&#39;)\npic_barh(df_brand_sum.vote_count,&#39;各品牌产品评论数对比&#39;,&#39;评论数&#39;,&#39;品牌&#39;)\n","slug":"python酒类数据分析","date":"2020-05-06T12:54:54.000Z","categories_index":"python","tags_index":"数据分析","author_index":"弦好想断"},{"id":"3e2cb49607eb328dbcf69849d600f074","title":"sql互联网游戏数据分析","content":"一、数据概览数据共有828934条，108列标签\n\n本文主要对以下10个字段进行分析\n\n使用工具：Navicat Premium ，jupyter notebook技能要求：SQL掌握到子查询，Python连接数据库（不连也可以）\n二、提出问题：1、新增玩家分析：从玩家数量、玩家占比、每日新增玩家数展开分析2、玩家活跃度分析：从不同用户在线时长、分布特征展开分析3、玩家付费情况分析：从PUR（付费比率）、ARPPU（活跃付费用户平均消费金额）等关键指标展开分析4、玩家游戏习惯分析：从不同玩家类型、游戏模式（PVP与PVE）得出的情况来展开分析\n三、新增玩家分析新增玩家数量：828934人\nSELECT count(DISTINCT user_id) 新增玩家数量 FROM &#96;tap_fun_test&#96;\n新增付费玩家数量：19549\nselect count(DISTINCT(user_id))  新增付费玩家数量 from tap_fun_test where pay_price &gt;0;\n付费玩家占比:0.0236\nselect 新增付费玩家&#x2F;新增玩家数 as 付费玩家占比 from \n(SELECT count(distinct user_id) 新增玩家数 from tap_fun_test) as t1 ,\n(SELECT count(DISTINCT user_id)  新增付费玩家 from tap_fun_test where pay_price&gt;0) as t2 ;\n每日新增用户数量\nselect date(register_time) 日期,count(DISTINCT(user_id)) from tap_fun_test GROUP BY 日期;\n\n每日新增付费用户数\nselect date(register_time) 日期,count(DISTINCT(user_id)) from tap_fun_test where pay_price&gt;0 GROUP BY 日期;\n\n\n每日新增玩家在3月10日有一次大高峰增长，可能举办活动，但活动一过后续新增玩家数并没有显著提升，可见活动没有游戏的人气带来实质性的帮助。活动需要力度加强并保持一定时间维度，给玩家充分时间了解游戏，才能提高秀逸热度。\n全部玩家平均在线时长:11.741103057664969\nSELECT avg(avg_online_minutes)  as 全部玩家平均在线时长 from tap_fun_test;\n付费玩家平均在线时长:135.8732415946089\nselect avg(avg_online_minutes) from tap_fun_test where pay_price&gt;0;\n四、玩家活跃度分析平均在线时长的分布特点###全部玩家人数的中位数、上下四分位数\nselect round(count(distinct user_id)&#x2F;4) as 下四分位数,\nround(count(distinct user_id)&#x2F;2) as 中位数,\nround(count(distinct user_id)&#x2F;4*3) as 上四分位数\nfrom tap_fun_test;\n下四分位数：207234    中位数：414467    上四分位数：621701全部玩家在线时长箱线图关键值SELECT min(avg_online_minutes) 最小值,\n(select avg_online_minutes from tap_fun_test ORDER BY avg_online_minutes LIMIT 207233,1) as 下四分位数,\n(select avg_online_minutes from tap_fun_test ORDER BY avg_online_minutes LIMIT 414466,1) as 中位数,\n(select avg_online_minutes from tap_fun_test ORDER BY avg_online_minutes LIMIT 621700,1) as 上四分位数,\nmax( avg_online_minutes) 最大值\nFROM &#96;tap_fun_test&#96;\t\n最小值0.0,下四分位数:0.5,中位数:1.666667，上四分位数：5，最大值：1605.833333付费玩家的人数最大值最小值、中位数、上下四分位数select round(count(distinct user_id)&#x2F;4) as 下四分位数,\nround(count(distinct user_id)&#x2F;2) as 中位数,\nround(count(distinct user_id)&#x2F;4*3) as 上四分位数\nfrom tap_fun_test \nWHERE pay_price&gt;0;\n下四分位数：4887，    中位数：9775    上四分位数：14662付费玩家在线时长箱线图关键值SELECT min(avg_online_minutes) 最小值,\n(select avg_online_minutes from tap_fun_test where pay_price&gt;0 ORDER BY avg_online_minutes LIMIT 4886,1) as 下四分位数,\n(select avg_online_minutes from tap_fun_test where pay_price&gt;0 ORDER BY avg_online_minutes LIMIT 9774,1) as 中位数,\n(select avg_online_minutes from tap_fun_test where pay_price&gt;0 ORDER BY avg_online_minutes LIMIT 14661,1) as 上四分位数,\nmax( avg_online_minutes) 最大值\nFROM &#96;tap_fun_test&#96; \nwhere pay_price&gt;0;\n最小值：0.3333 ,下四分位数:30.6667,中位数:84.5，上四分位数：191.1667，最大值：1081.5\n全部玩家的在线时长箱线图中向下压缩的很厉害，全部玩家上四分位数为5，说明75%的玩家平均在线只有大约5分钟，可能一局游戏都没有玩完，可见玩家流失情况比较严重。付费用户的箱型图中下四分位数为30，中位数84，上四分位数为191，说明付费用户中75%以上的用户在线时长都超过了30分钟。\n五、玩家付费情况分析关键指标AU（active users）活跃用户：游戏时长超过15分钟 PU（Paying users）付费用户APA（Active Paying Account）:活跃付费用户数ARPU：平均每个活跃用户的收入，总收入/AU ARPPU：平均活跃付费用户收入,总收入/APU PUR(付费比率)：APA/AU\n每个活跃玩家的收入select count(DISTINCT user_id) as AU,\n(select sum(pay_price) from tap_fun_test as 总收入),\n(select sum(pay_price) from tap_fun_test) &#x2F;count(DISTINCT user_id) as 每个活跃玩家收入 \nfrom tap_fun_test \nwhere avg_online_minutes &gt; 15;\n#and pay_price&gt;0;每个活跃付费玩家的收入\nAU：99846，总收入：556900.04，每个活跃玩家收入ARPU：5.57758989每个活跃付费玩家的收入APA：16982，总收入：556900.04，每个活跃付费玩家收入ARPPU：32.79354846\n付费比率select count(DISTINCT user_id) as APA ,\n(SELECT count(DISTINCT user_id) from tap_fun_test WHERE avg_online_minutes&gt;&#x3D;15) as AU ,\ncount(DISTINCT user_id)&#x2F;(select count(DISTINCT user_id) from tap_fun_test \nwhere avg_online_minutes&gt;&#x3D;15) as PUR\nfrom tap_fun_test \nwhere avg_online_minutes&gt;&#x3D;15 and pay_price &gt;0;\nAPA：17005；AU：100649；活跃玩家的付费率PUR：0.169，全部玩家的付费比率：0.021\n该游戏的PUR（人均付费率）为0.169较低，且ARPU（活跃玩家平均消费额）为5.58，说明收入表现差；相对于ARPPU，活跃付费用户消费很高，是ARPU的6倍左右，针对这点我们可以做首次消费门槛和专属大V玩家的福利与活动进行调整与优化。\n六、玩家游戏习惯分析select AVG(pvp_battle_count) as 平均PVP次数 ,\nsum(pvp_lanch_count)&#x2F;sum(pvp_battle_count) as 主动发起PVP概率,\nsum(pvp_win_count)&#x2F;sum(pvp_battle_count) as PVP获胜概率\nfrom tap_fun_test\nwhere avg_online_minutes&gt;&#x3D;15;\nPVP活跃玩家\n平均PVP次数：15.164651412333953；主动发起PVP概率：0.5688357584679884；PVP获胜概率：0.532222547626395\nPVP活跃付费玩家(加一个pay_price&gt;0)\n平均PVP次数：27.301911202587473；主动发起PVP概率：0.6553937480210826；PVP获胜概率：0.6872459716242092\n\nPVE活跃玩家平均PVE次数：28；主动发起PVE概率：0.9967；PVE获胜概率：0.9041PVE活跃付费玩家平均PVE次数：52；主动发起PVE概率：0.9957；PVE获胜概率：0.9110\n\n\n\nAPA（付费活跃用户）玩家的平均PVE和PVP次数都是AU（活跃）玩家次数的两倍左右，显然APA玩家是重要的发展对象。PVP活动中，APA玩家主动发起和胜利的概率都明显高于AU玩家。PVE活动中，APA玩家主动发起和胜利的概率与AU玩家都基本持平，其中主动发起PVE的概率非常高，且二者的PVE胜率高达90%，游戏体验较好。\n","slug":"sql互联网游戏数据分析","date":"2020-04-19T17:45:16.000Z","categories_index":"sql","tags_index":"数据分析","author_index":"弦好想断"},{"id":"defb5a725379b00e673d55a61c52ceb3","title":"python电影数据分析","content":"\n一、数据概述id：标识号imdb_id：IMDB 标识号popularity：在 Movie Database 上的相对页面查看次数budget：预算（美元）revenue：收入（美元）original_title：电影名称cast：演员列表，按 | 分隔，最多 5 名演员homepage：电影首页的 URLdirector：导演列表，按 | 分隔，最多 5 名导演tagline：电影的标语keywords：与电影相关的关键字，按 | 分隔，最多 5 个关键字overview：剧情摘要runtime：电影时长genres：风格列表，按 | 分隔，最多 5 种风格production_companies：制作公司列表，按 | 分隔，最多 5 家公司release_date：首次上映日期vote_count：评分次数vote_average：平均评分based on novel 是否由小说改编\n二、提出问题每年上映电影数量、电影总票房表现？电影票房与哪些因素最相关？各类型电影表现？各电影类型之间的关联性原创电影与改编电影有何差异？受众喜好与那些因素有关？电影时长为多少最合适？Universal Pictures与Paramount Pictures两家行业巨头的业绩如何？\n三、每年上映电影数量、电影总票房是多少？\n\n\n电影工业在最近三十几年呈现稳步式增长，2014年数量最多。虽然电影数量最近二十年内有3次较大的波动，但电影总票房仍然保持在较高的水准，说明电影市场已经成熟，有固定的消费人群，可见投资电影仍然是很好的投资方式。\n四、电影票房与哪些因素最相关？\n由以上可知，电影票房与电影预算（0.73），受欢迎度（0.66），评价次数（0.78）存在强相关。 绘制电影票房与受欢迎度，评价次数，电影预算的相关性散点图及其线性回归线。\n\n如图，电影预算、评分基本与电影票房呈正线性相关的关系，这也符合正常经济规律。\n五、各类型电影表现？\n约从1992开始，电影市场开始爆发式增长，其中戏剧类（Drama）和喜剧类（Comedy）这两个类型是随时间增长幅度最大的，现在也比较热门。\n\n如上图，可见投资一部电影的话，上图中的类型是最好的选择，尤以comedy和drama最佳。那不同类型电影的盈利能力如何呢？\n\n电影关键词主要以based on novel（基于小说）、women（女性）、independent film（独立电影）、murder（谋杀）为主\n\n由图可知，平均收益前3的电影类型为：冒险类（Adventure）、科幻类（Fantasy）、动画类（Animation），而外国电影类（Foreign）和电视电影类（TV Movie）有亏损的风险。\n六、各电影类型之间关联性\n(Animation)与(Family)、(Adventure, Thriller)与(Action)、(Fantasy) 与(Family)、(Thriller, Drama)与(Crime) 在支持度阈值2.5%，提升度为3 的情况下，表现出较强的关联性，也符合人们的生活常识\n七、原创电影与改编电影有何差异？\n可见，绝大部分电影还是原创为主。\n\n原创电影的利润与改编电影相差一倍多。\n八、受众喜好与那些因素有关？电影时长为多少最合适？\n受众欢迎度较高的电影类型为Adventure，Science Fiction ，Fantasy。\n\n受众欢迎度较高的电影的时长基本在90-200分钟之间。\n\n受欢迎度高的电影，评分肯定高。反之评分高的电影，受欢迎度可能低，这就是冷门好片的天地。\n九、Universal Pictures与Paramount Pictures两家行业巨头的业绩如何？\n\n两家公司制作的主要电影类型几乎一致，戏剧类（Drama）、喜剧类（Comedy）、惊悚类（Thriller）、动作类（Action）占据了两家公司制作总量的60%左右，这与总的各类型电影数量分布也是相似的，可供其他公司参考其布局策略。\n十、结论目前电影市场成熟，产量和票房都处于较高的水平；电影的预算、评价会直接影响电影票房，故一定的电影预算是电影票房成功的基础；(Animation)与(Family)、(Adventure, Thriller)与(Action)、(Fantasy) 与(Family)、(Thriller, Drama)与(Crime) 在给定阈值下有较强的关联性。最受欢迎的电影类型是comedy和drama，投资这两个类型的电影是不错的选择；(Universal Pictures)的电影数量多于(Paramount Pictures)，两者票房表现不相上下。原创电影在电影工业中占绝对主导地位，因此应重视编剧和剧本的选择；电影时长应控制在90～200分钟，最符合观众的观影习惯，也最易获得成功。\n十一、Python代码导入包import pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\n%matplotlib inline\nimport seaborn as sns\nfrom wordcloud import WordCloud\nfrom mlxtend.frequent_patterns import apriori\nfrom mlxtend.frequent_patterns import association_rules\nplt.rcParams[&#39;font.sans-serif&#39;] &#x3D; [&#39;SimHei&#39;]#显示中文\nplt.style.use(&#39;ggplot&#39;)\n使用apriori算法进行关联规则挖掘path &#x3D; &#39;D:&#x2F;python_data_file&#x2F;based_on_novel.csv&#39;\ndata &#x3D; pd.read_csv(path)\n\nmovie_genres &#x3D; pd.DataFrame(data,columns&#x3D;[&#39;original_title&#39;,&#39;genres&#39;])\nmovies_ohe &#x3D; movie_genres.drop(&#39;genres&#39;,1).join(movie_genres.genres.str.get_dummies())\n# print(movies_ohe.shape)#(10866, 21)\nmovies_ohe.set_index([&#39;original_title&#39;],inplace&#x3D;True)\n\nfrequent_itemsets_movies &#x3D; apriori(movies_ohe,use_colnames&#x3D;True, min_support&#x3D;0.025)\nresult &#x3D; [i for i in frequent_itemsets_movies.itemsets if len(i)&gt;1]\n# len(result)#37\nrules_movies &#x3D;  association_rules(frequent_itemsets_movies, metric&#x3D;&#39;lift&#39;, min_threshold&#x3D;1.25)\n# print(rules_movies)\nrules_movies[(rules_movies.lift&gt;3)].sort_values(by&#x3D;[&#39;lift&#39;], ascending&#x3D;False)\n处理数据xdata &#x3D; data[[&#39;id&#39;,&#39;popularity&#39;,&#39;production_companies&#39;,\n              &#39;budget&#39;,&#39;revenue&#39;,&#39;original_title&#39;,&#39;runtime&#39;,&#39;release_date&#39;,&#39;genres&#39;,&#39;vote_count&#39;,&#39;vote_average&#39;,&#39;based on novel&#39;]]\n#要求制造商和电影类型不能为空\nclean_xdata &#x3D; xdata[xdata.production_companies.notnull()&amp;xdata.genres.notnull()].reset_index(drop&#x3D;True)\n# 每年总票房\nclean_xdata[&#39;year&#39;] &#x3D; pd.to_datetime(clean_xdata.release_date,format&#x3D;&#39;%Y-%m-%d&#39;).dt.year\nyear_revenue &#x3D; clean_xdata.groupby(&#39;year&#39;)[&#39;revenue&#39;].sum()\ndef pic_trend(data,tit,xlab,ylab):\n    plt.figure(figsize&#x3D;(12,6))\n    data.plot()\n    plt.title(tit,fontsize &#x3D; 20)\n    plt.xlabel(xlab,fontsize&#x3D;15)\n    plt.ylabel(ylab,fontsize&#x3D;15)\n    plt.show()\npic_trend(year_revenue,&#39;每年总票房统计&#39;,&#39;年份&#39;,&#39;总票房&#39;)\n#每年上映电影数量统计\nyear_count &#x3D; clean_xdata.groupby(&#39;year&#39;).id.count()\npic_trend(year_count,&#39;每年上映电影数量统计&#39;,&#39;年份&#39;,&#39;上映电影数量&#39;)\n#每年上映电影数量饼图\ndef pic_pie(data,val,gby,tit):\n    data &#x3D; data.reset_index(drop&#x3D;False)\n    fig &#x3D; plt.figure(figsize&#x3D;(16,8))\n    plt.pie(data[val],labels&#x3D;data[gby],autopct&#x3D;&#39;%.1f%%&#39;)\n    plt.title(tit,fontsize &#x3D; 15)\npic_pie(year_count,&#39;id&#39;,&#39;year&#39;,&#39;每年上映电影数量&#39;)\n画走势图# 随时间推移如何发生变化的\ngenre_df &#x3D; clean_xdata.genres.str.get_dummies()#构建虚拟变量，相当于把各电影类型作为列名展开为一个稀疏矩阵\ngenre_df[&#39;release_date&#39;] &#x3D; clean_xdata[&#39;year&#39;]\ngenre_by_year &#x3D; genre_df.groupby(&#39;release_date&#39;).sum()\nfig &#x3D; plt.figure(figsize&#x3D;(12,6))\nplt.plot(genre_by_year,label &#x3D; genre_by_year.columns)\nplt.legend(genre_by_year)\nplt.xticks(range(1950,2020,10))\nplt.title(&#39;电影类型随时间变动趋势图&#39;,fontsize&#x3D;20)\nplt.xlabel(&#39;年份&#39;,fontsize &#x3D; 20)\nplt.ylabel(&#39;数量&#39;,fontsize &#x3D; 20)\n\n# ②电影类型数量分布\ngenre_sum &#x3D; genre_by_year.sum().sort_values(ascending &#x3D; False)\n#这里的label参数加不加在图中没有任何变化\ngenre_sum.plot.barh(label&#x3D;&#39;genre&#39;,figsize &#x3D; (12,6))\nplt.title(&#39;电影类型数量分布图&#39;,fontsize &#x3D; 20)\nplt.xlabel(&#39;数量&#39;,fontsize&#x3D;20)\nplt.ylabel(&#39;电影类型&#39;,fontsize&#x3D;20)\nplt.show()\n计算指标# （二）不同类型电影的盈利能力如何？\n# 建立电影类型-利润数据框，计算各电影类型平均收益：\na &#x3D; clean_xdata.revenue - clean_xdata.budget\nprofit_df &#x3D; genre_df.join(pd.DataFrame(a,columns&#x3D;[&#39;profit&#39;]))\n\n#计算个电影类型的利润平均值\n#传递as_index&#x3D;False，把分组键的类型作为一列返回在DataFrame中，而不是默认True时作为Series的索引返回\ngenre_set &#x3D; clean_xdata[&#39;genres&#39;].str.get_dummies().columns.unique()\nprofit_by_genre &#x3D; pd.Series(index&#x3D;genre_set)\nfor genre in genre_set:\n    profit_by_genre[genre] &#x3D; profit_df.groupby(genre,as_index &#x3D; False).profit.mean().loc[1,&#39;profit&#39;]\n#画出各电影类型平均收益分布图\nprofit_by_genre.sort_values().plot.barh(label&#x3D;&#39;genre&#39;,figsize&#x3D;(12,6))\nplt.title(&#39;各电影类型平均收益分布图&#39;,fontsize&#x3D;20)\nplt.xlabel(&#39;利润&#39;,fontsize&#x3D;20)\nplt.ylabel(&#39;电影类型&#39;,fontsize&#x3D;20)\nplt.show()\n\noriginal_recompose &#x3D; pd.DataFrame(clean_xdata[&#39;budget&#39;])\noriginal_recompose.loc[:,&#39;profit&#39;] &#x3D; profit_df.profit\noriginal_recompose[&#39;type&#39;] &#x3D; clean_xdata[&#39;based on novel&#39;].map(lambda x :1 if x&#x3D;&#x3D;&#39;based on novel&#39; else 0)\n#原创或改编电影的预算与利润\n#这个地方重新定义新的DataFrame --original_recompose_groupby用来存储各个指标分组后的均值（原创与改编电影概要）\noriginal_recompose_groupby &#x3D; original_recompose.groupby(&#39;type&#39;).mean()\noriginal_recompose_groupby[&#39;count&#39;] &#x3D; original_recompose.groupby(&#39;type&#39;).type.count()\noriginal_recompose_groupby[&#39;profit_rate&#39;] &#x3D; original_recompose_groupby.profit&#x2F;original_recompose_groupby.budget#这里有细节,平均利润率\noriginal_recompose_groupby.rename(index &#x3D; &#123;0:&#39;original&#39;,1:&#39;recompose&#39;&#125;,inplace &#x3D; True)#传递inplace&#x3D;True会删去原来的索引，否则会保留\n#是否原创电影数量对比图\nplt.figure(figsize &#x3D;(12,6))\noriginal_recompose_groupby.loc[original_recompose_groupby.index,&#39;count&#39;].plot.bar()#传入loc【】里面的参数不能是；&#39;type&#39;,会报错\nplt.title(&#39;原创改编电影数量对比&#39;,fontsize &#x3D; 20)\nplt.xlabel(&#39;原创-改变&#39;,fontsize &#x3D; 20)\nplt.ylabel(&#39;数量&#39;,fontsize &#x3D; 20)\nplt.show()\n\n#绘制利润柱状图\nx&#x3D; list(range(len(original_recompose_groupby.index)))#索引长度序列\nxl &#x3D; original_recompose_groupby.index#xl为索引实际值\nfig &#x3D; plt.figure()\nax1&#x3D;fig.add_subplot(111)\nplt.bar(x,original_recompose_groupby.profit)\n#接下来有疑问？\nplt.xticks(x,xl,rotation &#x3D; 0,fontsize&#x3D;12)\nplt.yticks(fontsize&#x3D;15)\nax1.set_title(&#39;原创与改编电影平均利润对比&#39;,fontsize &#x3D; 20)\nax1.set_xlabel(&#39;原创-改变&#39;,fontsize &#x3D; 18)\nax1.set_ylabel(&#39;利润&#39;,fontsize &#x3D; 18)\nax1.legend(loc&#x3D;2,labels&#x3D;&#39;利润&#39;)\n\n#绘制利润折线图\nimport matplotlib.ticker as mtick\nax2 &#x3D; ax1.twinx()\nax2.plot(x,original_recompose_groupby[&#39;profit_rate&#39;],&#39;go-&#39;,lw&#x3D;2)\nfmt&#x3D;&#39;%.2f%%&#39;\nyticks &#x3D; mtick.FormatStrFormatter(fmt)\nax2.yaxis.set_major_formatter(yticks)#次纵坐标标签设置为百分比显示\nplt.yticks(fontsize &#x3D; 15)\nax2.set_ylabel(&#39;利润率&#39;,fontsize &#x3D; 18)\nax2.legend(loc&#x3D;4,labels &#x3D; &#39;profit_rate&#39;)#传递labels参数避免警告\n生成词云keywords_data &#x3D; data[[&#39;id&#39;,&#39;popularity&#39;,&#39;production_companies&#39;,&#39;budget&#39;,&#39;revenue&#39;,&#39;original_title&#39;,&#39;runtime&#39;,&#39;release_date&#39;,&#39;genres&#39;,&#39;vote_count&#39;,&#39;vote_average&#39;,&#39;based on novel&#39;,&#39;keywords&#39;]]\nkeywords_data &#x3D; data[data.production_companies.notnull()&amp;data.genres.notnull()].reset_index(drop&#x3D;True)#得到 包含关键字keywords数据的列表\nkeywords_list1 &#x3D; []\nfor x in keywords_data.keywords.dropna():\n    keywords_list1.append(x)\nkeywords_list1 &#x3D; &#39;&#39;.join(keywords_list1)\nkeywords_list1 &#x3D; keywords_list1.replace(&#39;\\s&#39;,&#39;&#39;)#去除字符串中空字符串（\\s用于匹配空白字符，可能是空格、制表符、其他空白））\n\nwordcloud &#x3D; WordCloud(background_color&#x3D;&#39;black&#39;,max_words&#x3D;3000,scale&#x3D;1.5).generate(keywords_list1)\nplt.figure(figsize&#x3D;(14,8))\nplt.imshow(wordcloud)\nplt.axis(&#39;off&#39;)\nplt.show()\npopular_genre_df &#x3D; pd.concat([genre_df.iloc[:,:-1],clean_xdata.popularity],axis&#x3D;1)\n#计算各类型电影受欢迎度均值\nlist &#x3D; []\nfor genre in genre_set:\n    list.append(popular_genre_df.groupby(genre,as_index &#x3D; False).popularity.mean().loc[1,&#39;popularity&#39;])\npopular_by_genre&#x3D; pd.DataFrame(index&#x3D;genre_set)\npopular_by_genre[&#39;popularity_mean&#39;] &#x3D; list\n#电影类型受欢迎度分布图\npopular_by_genre.sort_values(by&#x3D;&#39;popularity_mean&#39;).plot.barh(figsize&#x3D;(14,8))\nplt.title(&#39;电影类型受欢迎度分布图&#39;,fontsize&#x3D;20)\nplt.xlabel(&#39;受欢迎度&#39;,fontsize&#x3D;20)\nplt.ylabel(&#39;电影类型&#39;,fontsize&#x3D;20)\nplt.show()\n# ②电影时长与受众欢迎度\nplt.scatter(clean_xdata.runtime,clean_xdata.popularity)\nplt.title(&#39;时长与欢迎度散点图&#39;,fontsize&#x3D;20)\nplt.xlabel(&#39;电影时长&#39;,fontsize&#x3D;20)\nplt.ylabel(&#39;受欢迎度&#39;,fontsize&#x3D;20)\nplt.show()\n# ③电影评分与受众欢迎度\nplt.scatter(clean_xdata.vote_average,clean_xdata.popularity)\nplt.title(&#39;评分与欢迎度散点图&#39;,fontsize&#x3D;20)\nplt.xlabel(&#39;电影评分&#39;,fontsize&#x3D;20)\nplt.ylabel(&#39;受欢迎度&#39;,fontsize&#x3D;20)\nplt.show()\nUniversal Pictures与Paramount Picturescompanies_list &#x3D;[&#39;Universal Pictures&#39;,&#39;Paramount Pictures&#39;]\ncompanies_df &#x3D; pd.DataFrame()\nfor company in companies_list:#各电影的电影商是否包含两者中其中一个，是则返回1，否则返回0\n    companies_df[company] &#x3D;clean_xdata.production_companies.str.contains(company).map(lambda x :1 if x else 0)\ncompanies_df &#x3D; pd.concat([companies_df,genre_df.iloc[:,:-1],profit_df.profit],axis&#x3D;1)\nlist &#x3D; []\nfor company in companies_list:\n    list.append(companies_df.groupby(company,as_index&#x3D;False).profit.sum().loc[1,&#39;profit&#39;])\ncompanies_profit&#x3D; pd.DataFrame(list,index &#x3D; companies_list,columns&#x3D;[&#39;profit_sum&#39;])\ncompanies_profit.plot.bar(label &#x3D; companies_profit.index,figsize&#x3D;(8,6))\nplt.title(&#39;两家公司利润对比&#39;,fontsize&#x3D;20)\nplt.xticks(rotation &#x3D; 0)\nplt.ylabel(&#39;利润&#39;,fontsize &#x3D; 20)\nplt.show()\n\ncompanies_df_1 &#x3D; companies_df.groupby(&#39;Universal Pictures&#39;)[[&#39;Action&#39;, &#39;Adventure&#39;, &#39;Animation&#39;, &#39;Comedy&#39;, &#39;Crime&#39;, &#39;Documentary&#39;,\n       &#39;Drama&#39;, &#39;Family&#39;, &#39;Fantasy&#39;, &#39;Foreign&#39;, &#39;History&#39;, &#39;Horror&#39;, &#39;Music&#39;,\n       &#39;Mystery&#39;, &#39;Romance&#39;, &#39;Science Fiction&#39;, &#39;TV Movie&#39;, &#39;Thriller&#39;, &#39;War&#39;,\n       &#39;Western&#39;]].sum().loc[1,:]\ncompanies_df_2 &#x3D; companies_df.groupby(&#39;Paramount Pictures&#39;)[[&#39;Action&#39;, &#39;Adventure&#39;, &#39;Animation&#39;, &#39;Comedy&#39;, &#39;Crime&#39;, &#39;Documentary&#39;,\n       &#39;Drama&#39;, &#39;Family&#39;, &#39;Fantasy&#39;, &#39;Foreign&#39;, &#39;History&#39;, &#39;Horror&#39;, &#39;Music&#39;,\n       &#39;Mystery&#39;, &#39;Romance&#39;, &#39;Science Fiction&#39;, &#39;TV Movie&#39;, &#39;Thriller&#39;, &#39;War&#39;,\n       &#39;Western&#39;]].sum().loc[1,:]\ncompany_genre_df &#x3D; pd.DataFrame([companies_df_1,companies_df_2],index &#x3D; [&#39;Universal Pictures&#39;,&#39;Paramount Pictures&#39;]).T\nfig &#x3D; plt.figure(figsize&#x3D;(16,8))\nax1 &#x3D; fig.add_subplot(121)\nplt.pie(company_genre_df[&#39;Universal Pictures&#39;],labels&#x3D;company_genre_df.index,autopct&#x3D;&#39;%.1f%%&#39;)\nplt.title(&#39;Universal Pictures&#39;,fontsize &#x3D; 15)\n\nax2 &#x3D; fig.add_subplot(122)\nplt.pie(company_genre_df[&#39;Paramount Pictures&#39;],labels&#x3D;company_genre_df.index,autopct&#x3D;&#39;%.1f%%&#39;)\nplt.title(&#39;Paramount Pictures&#39;,fontsize&#x3D;15)\n# 电影票房与哪些因素最相关？\nclean_xdata[[&#39;budget&#39;,&#39;popularity&#39;,&#39;release_date&#39;,&#39;runtime&#39;,&#39;vote_average&#39;,&#39;vote_count&#39;,&#39;revenue&#39;]].corr()\nimport seaborn as sns\nrevenue_corr &#x3D; clean_xdata[[&#39;budget&#39;,&#39;popularity&#39;,&#39;vote_count&#39;,&#39;revenue&#39;]]\nfig &#x3D; plt.figure(figsize&#x3D;(18,6))\n#电影票票房与电影预算相关性散点图\n\nax1 &#x3D; plt.subplot(1,3,1)\nax1 &#x3D; sns.regplot(x&#x3D;&#39;popularity&#39;, y&#x3D;&#39;revenue&#39;, data&#x3D;revenue_corr, x_jitter&#x3D;.1)\nax1.text(400,2e9,&#39;r&#x3D;0.64&#39;,fontsize&#x3D;15)\nplt.title(&#39;revenue by popularity&#39;,fontsize&#x3D;15)\nplt.xlabel(&#39;popularity&#39;,fontsize&#x3D;13)\nplt.ylabel(&#39;revenue&#39;,fontsize&#x3D;13)\n \nax2 &#x3D; plt.subplot(1,3,2)\nax2 &#x3D; sns.regplot(x&#x3D;&#39;vote_count&#39;, y&#x3D;&#39;revenue&#39;, data&#x3D;revenue_corr, x_jitter&#x3D;.1,color&#x3D;&#39;g&#39;,marker&#x3D;&#39;+&#39;)\nax2.text(6800,1.1e9,&#39;r&#x3D;0.78&#39;,fontsize&#x3D;15)\nplt.title(&#39;revenue by vote_count&#39;,fontsize&#x3D;15)\nplt.xlabel(&#39;vote_count&#39;,fontsize&#x3D;13)\nplt.ylabel(&#39;revenue&#39;,fontsize&#x3D;13)\n \nax3 &#x3D; plt.subplot(1,3,3)\nax3 &#x3D; sns.regplot(x&#x3D;&#39;budget&#39;, y&#x3D;&#39;revenue&#39;, data&#x3D;revenue_corr, x_jitter&#x3D;.1,color&#x3D;&#39;r&#39;,marker&#x3D;&#39;^&#39;)\nax3.text(1.6e8,2.2e9,&#39;r&#x3D;0.73&#39;,fontsize&#x3D;15)\nplt.title(&#39;revenue by budget&#39;,fontsize&#x3D;15)\nplt.xlabel(&#39;budget&#39;,fontsize&#x3D;13)\nplt.ylabel(&#39;revenue&#39;,fontsize&#x3D;13)\n思路要明确，代码要简洁，以后尽量都写成函数。\n","slug":"python电影数据分析","date":"2020-03-11T05:25:31.000Z","categories_index":"python","tags_index":"","author_index":"弦好想断"},{"id":"1eac341c429c84a40e6d901f88df1212","title":"python面向对象习题","content":"写完对对象这个东西了解很多了\n# coding&#x3D;utf-8\n&quot;&quot;&quot;\n一：定义一个学生类。有下面的类属性：\n1 姓名\n2 年龄\n3 成绩（语文，数学，英语)[每课成绩的类型为整数]\n类方法：\n1 获取学生的姓名：get_name() 返回类型:str\n2 获取学生的年龄：get_age() 返回类型:int\n3 返回3门科目中最高的分数。get_course() 返回类型:int\n写好类以后，可以定义2个同学测试下:\nzm &#x3D; Student(&#39;zhangming&#39;,20,[69,88,100])\n返回结果：\nzhangming\n20\n100\n&quot;&quot;&quot;\nclass Student(object):\n    def __init__(self, name, age, scores):\n        self.name &#x3D; name\n        self.age &#x3D; age\n        self.scores &#x3D; scores\n    def get_name(self):\n        return self.name\n    def get_age(self):\n        return self.age\n    def get_course(self):\n        return max(self.scores)\nzm &#x3D; Student(&#39;zhangming&#39;, 20, [69, 88, 100])\nprint zm.get_name()\nprint zm.get_age()\nprint zm.get_course()\n\n&quot;&quot;&quot;\n二：定义一个字典类：dictclass。完成下面的功能：\ndict &#x3D; dictclass(&#123;你需要操作的字典对象&#125;)\n1 删除某个key\ndel_dict(key)\n2 判断某个键是否在字典里，如果在返回键对应的值，不存在则返回&quot;not found&quot;\nget_dict(key)\n3 返回键组成的列表：返回类型;(list)\nget_key()\n4 合并字典，并且返回合并后字典的values组成的列表。返回类型:(list)\nupdate_dict(&#123;要合并的字典&#125;)\n&quot;&quot;&quot;\nclass dictclass(object):\n    def __init__(self, dict):\n        self.dict &#x3D; dict\n    def get_dict(self, key):\n        if self.dict. has_key(key):\n            return self.dict[key]\n        return &#39;not found&#39;\n    def del_dict(self, key):\n        if self.dict.has_key(key):\n            self.dict.pop(key)\n        else:\n            return &#39;no that key&#39;\n    def get_key(self):\n        return self.dict.keys()\n    def updata_dict(self, dict2):\n        self.dict &#x3D; dict(self.dict, **dict2)\n        return self.dict.values()\n \nA &#x3D; dictclass(&#123;&#39;a&#39;: 1, &#39;b&#39;: 2&#125;)\nprint A.get_dict(&#39;c&#39;)\nprint A.del_dict(&#39;c&#39;)\nprint A.get_key()\nprint A.updata_dict(&#123;&#39;c&#39;: 3, &#39;d&#39;: 4&#125;)\n \n# 关于删除字典中的元素\n# pop 删除并返回对应的value值\nB &#x3D; &#123;&#39;a&#39;: 1, &#39;b&#39;: 2&#125;\nprint B.pop(&#39;b&#39;)\nprint B\n# del void不返回值\nC &#x3D; &#123;&#39;a&#39;: 1, &#39;b&#39;: 2&#125;\ndel C[&#39;a&#39;]\nprint C\n# del dict 删除字典，不存在这个字典\n# dict.clear()删除字典内所有元素但字典还是存在只是没有元素\nD &#x3D; &#123;&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3&#125;\nD.clear()\n# 关于合并字典\nA &#x3D; &#123;&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3&#125;\nB &#x3D; &#123;&#39;d&#39;: 4, &#39;e&#39;: 5, &#39;f&#39;: 6&#125;\nC &#x3D; dict(A.items() + B.items())\nD &#x3D; dict(A, **B)  # 这种合并方法会比上一种快很多对于重复的key，B会覆盖A\n&quot;&quot;&quot;\n定义一个列表的操作类：Listinfo\n包括的方法:\n1 列表元素添加: add_key(keyname)  [keyname:字符串或者整数类型]\n2 列表元素取值：get_key(num) [num:整数类型]\n3 列表合并：update_list(list)\t  [list:列表类型]\n4 删除并且返回最后一个元素：del_key()\nlist_info &#x3D; Listinfo([44,222,111,333,454,&#39;sss&#39;,&#39;333&#39;])\n&quot;&quot;&quot;\nclass Listinfo(object):\n    def __init__(self, list_val):\n        self.varlist &#x3D; list_val\n \n    def add_key(self, key_name):\n        if isinstance(key_name, (str, int)):\n            self.varlist.append(key_name)\n            return self.varlist\n        else:\n            return &#39;error&#39;\n \n    def get_key(self, num):\n        if num &gt;&#x3D; 0 and num &lt; len(self.varlist):\n            return self.varlist[num]\n        else:\n            return &#39;error&#39;\n \n    def update_list(self, List_et):\n        self.varlist.extend(List_et)\n        return self.varlist\n \n    def del_key(self):\n        if len(self.varlist) &gt;&#x3D; 0:\n            return self.varlist.pop(-1)\n        else:\n            return &#39;error&#39;\nlist_info &#x3D; Listinfo([44, 222, 111, 333, 454, &#39;sss&#39;, &#39;333&#39;])\nprint list_info.add_key(&#39;1111&#39;)\nprint list_info.get_key(4)\nprint list_info.update_list([&#39;1&#39;, &#39;2&#39;, &#39;3&#39;])\nprint list_info.del_key()\n&quot;&quot;&quot;\n定义一个集合的操作类：Setinfo\n包括的方法:\n1 集合元素添加: add_setinfo(keyname)  [keyname:字符串或者整数类型]\n2 集合的交集：get_intersection(unioninfo) [unioninfo :集合类型]\n3 集合的并集： get_union(unioninfo)[unioninfo :集合类型]\n4 集合的差集：del_difference(unioninfo) [unioninfo :集合类型]\nset_info &#x3D;  Setinfo(你要操作的集合)\n&quot;&quot;&quot;\nclass Setinfo(object):\n    def __init__(self, my_Set):\n        self.Sett &#x3D; my_Set\n \n    def add_setinfo(self, keyname):\n        if isinstance(keyname, (int, str)):\n            self.Sett.add(keyname)\n            return self.Sett\n        return &#39;error&#39;\n \n    def get_intersection(self, unioninfo):\n        if isinstance(unioninfo, set):\n            return self.Sett &amp; unioninfo\n        return &#39;error&#39;\n \n    def get_union(self, unioninfo):\n        if isinstance(unioninfo, set):\n            return self.Sett | unioninfo\n        return &#39;error&#39;\n \n    def del_difference(self, unioninfo):\n        if isinstance(unioninfo, set):\n            return self.Sett - unioninfo\n        return &#39;error&#39;\n \nA &#x3D; set([1, 2, 3, 4, 5, 2])\nB &#x3D; set([5, 6, 3])\nset_info &#x3D; Setinfo(A)\nprint set_info.add_setinfo(&#39;f&#39;)\nprint set_info.get_intersection(B)\nprint set_info.get_union(B)\nprint set_info.del_difference(B)\n&quot;&quot;&quot;\n题目一： 写一个网页数据操作类。完成下面的功能：\n提示：需要用到urllib模块\nget_httpcode()获取网页的状态码，返回结果例如：200,301,404等 类型为int\nget_htmlcontent() 获取网页的内容。返回类型:str\nget_linknum()计算网页的链接数目。\n&quot;&quot;&quot;\nimport urllib\nimport urllib2\nclass page_data(object):\n    def __init__(self, url_add):\n        self.url &#x3D; url_add\n \n    def get_httpcode(self):\n        status &#x3D; urllib.urlopen(self.url).code\n        return status\n \n    def get_htmlcontent(self):\n        contentstr &#x3D; urllib2.urlopen(self.url).read()\n        return contentstr\n \n    def get_linknum(self):\n        content &#x3D; urllib2.urlopen(self.url).read()\n        return len(content.split(&#39;&lt;a href&#x3D;&#39;)) - 1\n \nA &#x3D; page_data(&quot;http:&#x2F;&#x2F;www.baidu.com&quot;)\nprint A.get_httpcode()\nprint A.get_htmlcontent()\nprint A.get_linknum()\n\n# coding&#x3D;utf-8\nclass SchoolMember:\n    # Represents any school member.\n    def __init__(self, name, age):\n        self.name &#x3D; name\n        self.age &#x3D; age\n        print &#39;(Initialized SchoolMember: %s)&#39; % self.name\n \n    def tell(self):\n        # Tell my details.\n        print &#39;Name:&quot;%s&quot; Age:&quot;%s&quot;&#39; % (self.name, self.age),\n \n \nclass Teacher(SchoolMember):\n    # Represents a teacher.\n    def __init__(self, name, age, salary):\n        SchoolMember.__init__(self, name, age)\n        self.salary &#x3D; salary\n        print &#39;(Initialized Teacher: %s)&#39; % self.name\n \n    def tell(self):\n        SchoolMember.tell(self)\n        print &#39;Salary: &quot;%d&quot;&#39; % self.salary\n \n \nclass Student(SchoolMember):\n    # Represents a student.\n    def __init__(self, name, age, marks):\n        SchoolMember.__init__(self, name, age)\n        self.marks &#x3D; marks\n        print &#39;(Initialized Student: %s)&#39; % self.name\n \n    def tell(self):\n        SchoolMember.tell(self)\n        print &#39;Marks: &quot;%d&quot;&#39; % self.marks\n \nt &#x3D; Teacher(&#39;Mrs. Shrividya&#39;, 40, 30000)\ns &#x3D; Student(&#39;Swaroop&#39;, 22, 75)\nc &#x3D; SchoolMember(&#39;Swar&#39;, 22)\nt.tell()\ns.tell()\nc.tell()\n\nhttps://blog.csdn.net/bullpride/article/details/52022701\n","slug":"python面向对象习题","date":"2019-07-19T04:59:17.000Z","categories_index":"python","tags_index":"数据分析","author_index":"弦好想断"},{"id":"cf1675b4714191423290b7ca7c89a04a","title":"大学三年，写给那个迟到的人","content":"亲爱的X姑娘：\n你好！给你写这封信的时候，我正在学校的机电楼B301上第一节课。看了简书里好多给异性朋友写信的文章，我也心血来潮，忍不住想要和你说说话了。\n—1—\n早上醒的很早，在床上平躺到闹铃声响起，依旧照常的起床，洗漱，整理好出门。\n没有胃口，不太想吃饭。但想到将来要在你面前呈现一个健康阳光的自己，还是买了一份豆浆和两个早餐包。\n吃完走进教室，已经零零散散的坐满了一些人，我打开耳机里的纯音乐，想着舒缓下情绪，来迎接这节并不怎么让我心动的课程。\n邻桌有一对情侣坐得很近，我看着老师走进教室，紧接着用余光一瞥到他们有说有笑的样子，顿时心生怅惘。\n如果，我想说是如果，你在后面轻轻地拍一下我的肩膀，我回头看到一个嘴角微微上扬的弧度，那这节课我一定带着满满的能量。\n或者，你就只是静静地坐在我的前面，我看着你，心生欢喜，脸上也应该会不自觉的泛起笑容……\n有时候我会一个人坐在三个座位的中间，就好像潜意识里给你留了一个位置一样。\n其实，一个人，一个座位，一支沙沙作响的笔，一个低下视线的背影。总是会显得孤零零的，在周围整齐的人群背景下，不免会有些格格不入…\n—2—\n你知道吗，我已经习惯了一个人走在去图书馆的路上，我听着音乐，看着一路沿途的风景，为了包裹住心中的孤独，我昂首挺胸，略显悠闲、惬意的走着。\n但是，如果是你和我一起，我可能会满含笑意地和你谈天说地，像个孩子一样大大方方的走着…\n又或是，你挽着我的手，不需要讲太多话，一起慢悠悠的走在石头小路上。就像《成都》里描绘的意境那样：”你会挽着我的衣袖，我会把手揣进裤兜……”\n有一个秘密要告诉你，我会用吉他弹唱这首歌了，不知道在你面前的时候，我能不能饱含深情的唱出来带给你浪漫的感觉。\n从图书馆出来，我们一起去食堂买饭，我会想先去你喜欢的窗口排队，你是想拿着书包去寻找空着的座位，还是想和我走在一起呢…\n你知道吗，平时都是和舍友一起吃饭，聊的也都是各自的事情。但是如果是和你一起，我想不但胃口会大涨，我们还可以有更多的故事一起回忆…\n吃完饭，我们坐在图书馆旁林荫小道的长凳上，听微风拂过耳边的声音，看那阳光沐浴下的一片绿林。\n你慢慢地把头靠在我的臂弯，我低头捕捉你眸底似海一般的温柔…\n我会想调皮地刮你的鼻子，你会闭上眼睛满意地笑吗，还是轻轻的戳我一下。\n你知道吗，就这样一个简单的动作，也会让我的整个世界都开满了花。\n—3—\n﻿假期的时候你会去哪玩呢！是在宿舍刷刷剧，和朋友聊聊天，还是出去旅游，拍照，发朋友圈，或是和我一样会去商业街兼职呢！﻿\n﻿我也会想着挣钱去买自己喜欢的东西呀，或是旅游去一个心驰神往的地方呢，又或者是，和我爱的人一起去吃顿火锅怎么样！oh！ that’s a good idea!﻿\n﻿当然，有时候他也会把握不好分寸，甚至不愿意安排自己学习的时间，逃课去做一些他感兴趣的东西呢。﻿\n﻿他觉得，要是有个心思细腻的你在身边的话，他们一起，一定能过着更有节奏、充实的生活！﻿\n﻿节日的时候我们去看场电影吧！要是去的比较早，那就在休息区玩一个超级有趣的双人小游戏怎么样！你知道怎么玩吗，不会？那我教你好了…﻿\n﻿我会宠爱地喂你爆米花，你会不会依偎在我的肩膀呢！不然的话我可能会把送到你嘴边的零食马上缩回到我嘴边哦！啊！你别生气，还是给你吃好了…\n﻿你知道吗，从这个时候起，在他期待的未来里，全都将是你……\n—4—\n晚上你喜欢出去逛逛吗！下自习后我常常会去超市，即便只买那几样东西，我也会在里面多逛一小会儿，可能是因为那里有浓浓的生活气息吧。\n愿在将来的某一天，我推着购物车，你牵着我的手，走在喧闹的商场。我悄悄把你喜欢的零食放进车里，你认真地挑着我爱吃的水果，然后我们拎着这简单而平凡的幸福，满载而归。\n我还有个夜跑的小习惯，我也希望和你一起，趁着夜幕降临，去草坪上繁星点点的操场。戴上耳机，跟着音乐的节奏，在皎洁的月光下挥洒汗水。\n一圈一圈的轮回，甩掉心中所有的不愉快，接着再去澡堂，冲去一天中纷乱的小情绪…\n又或是，我带着吉他，你当我的专属观众，在柔软舒适的草坪席地而坐，弹唱那些为你学过的歌好不好呢！\n你和我一起唱怎么样，可不能放过你那被天使吻过的嗓子，还有我可能会跑调哦，你会笑吗，还是大声一点，带回我跑偏的部分呢…\n想到这个唯美的画面，也会让我感动的红了眼。\n忙着为下一段人生做准备，好久都不去KTV了，好像也没有那种想在人前表现的冲动了，只希望现在的拼搏能为余生发掘出与众不凡的核心竞争力。\n不知道你是不是也正处于人生的某一个风口浪尖呢，你是不是已经完成蜕变了呢，你憧憬的未来里有没有一个像我这样的人呢。\n我相信，你肯定正走在和我相遇的路上呢。而我，也正在寻找着那一份懂你的资格呀。\n﻿突然间，清晨的一缕阳光掠过窗帘的缝隙撞到我的手上，照在这些热烈而又抽象的文字上，我顿下笔来，多想能永远保存此刻心里正诞生的阵阵暖意…\n他多么希望可以有一个人陪他看陌生城市里的每一个落日，他们一起去听喜欢的课程。一起规划未来，一起带着足够的知识，去闯荡这色彩斑斓的平凡世界。\n——你东半球官方指定唯一的男朋友\n","slug":"大学三年，写给那个迟到的人","date":"2018-11-19T08:28:23.000Z","categories_index":"随笔","tags_index":"成长，旧时光","author_index":"弦好想断"},{"id":"6919b9fcac48b5491910463656acfa3a","title":"至少你，存在过我的记忆","content":"人海中错过的那个人，至少，在我失眠梦呓间，脑海里还是会依稀浮现出你的容颜。\n贝蒂，我是里克。最近你的城市下雨了吗，我这里的温度有些难过，不知道你过得怎么样。\n济南的天照旧那样调皮，就像世界末日里的那句歌词，Why dose the sun go on shining一样，一次又一次地挑战着我出门的勇气，还好我坐的地方阳光有所收敛，不然我炽热的内心暴露在烈日下，真不知道会发生什么化学反应。\n家庭生活的原因，我很早就开始了一个人的生活，可能除了自己，没有谁能左右我的想法了。一个人无拘无束，一个人天马行空，一个人桀骜不驯，一个人胆怯如鼠。\n周国平说，在多数场合，我不是觉得对方乏味，就是害怕对方觉得我乏味，我既不愿意忍受对方的乏味，又不愿意费劲使自己有趣，所以我选择独处，那就自己承受自己的乏味，不累及他人。我大概就是这样一种人吧，得意的时候手舞足蹈，逢场作戏，可稍不如意就黯然失色，冷若冰霜，你说乏味不乏味。\n浮躁的生活中让人有太多无法控制的遐想，也许，我应该找到一个更好的娱乐方式，以至于不会在休息的时候，不由自主的沦陷。\n每次听到廖俊涛的那首《谁》，特别想拿起吉他练琴，弹着弹着，就忘记了后天还要考试的束缚感。有时候真希望时间定格在这一刻，不用去想其他任何事情。\n当然也好羡慕那些在架子鼓上不可一世的乐手们，想学习打鼓，一直追求这样的发泄方式，可是生活总归会有些小遗憾，习惯了时光静好，心情似乎一直都波澜不惊。\n最近经历了一连串的考核，带着满满的用心，和一丁点慌张，完成着之前感觉惊天动地的事情。\n前段时间帮驾校招生，拿到了辛苦换来的一点小回报。不过贝蒂，很多次的社会经验使我觉得，人们好像都不愿意看到别人变好的样子，他们尽可能与遭遇苦难的人找到共鸣，要么保持缄默，要么施以怜悯。当他们发现别人的好时，它们立刻感到毛骨悚然。\n贝蒂，你说像我这样的人，会活成自己想要成为的样子吗，我要学习的东西在需要通过考试拿到的学分面前，已经搁浅了一阵时间。我想，过完这一阵，我会继续坚持。因为，在这场游戏中，并没有什么其他的角色供我选择。\n当然我相信，这些很快就会过去的。时间总是这样无情地切割我们的生命，夜里想着心事，第二天的闹铃就响了；下几次雨，夏天也结束了；等反应过来的时候，那个穿着开裆裤在邻居家乱跑的小屁孩，都长这么大了。\n","slug":"至少你，存在过我的记忆","date":"2018-10-19T08:31:17.000Z","categories_index":"随笔","tags_index":"成长，旧时光","author_index":"弦好想断"},{"id":"830c703305ad4b55b8b0f615c2c13739","title":"大学里，最丧的时候","content":"—1—\n看到香港大学孙教授的一段话：\n﻿﻿“大学，就应该是早起吃点早餐；跑跑步；专业课认真听；公共课看看自己喜欢的杂志；中午小睡一会儿；下午参加个社团活动或打打篮球；晚上陪着喜欢的人散散步；或去自习室安静地看看书……  社会不需要学霸，也不认什么学生会主席，更不希望看到学生放弃学业去创业。你只要能平稳完整地读完大学，寻找到自己所爱的人和兴趣，多去没有目的的看些能丰富自己思想的书，认识几个好的不成样子的朋友，锻炼或是塑造自己的身体，学精自己想要从事事业的专业知识…… 做到这些，平淡地度过大学这几年你就已经足够优秀了。 ”\n可为什么今年大三的我，感觉这辈子算是完了。\n—2—\n大学，是一段没有烟火气的生活，是一个比毕业后舒服的状态。\n调剂到一个一眼无缘的理科专业，而你做的最无力的抗拒，就是在课上看自己感兴趣的东西，在宿舍听歌，看电影，打游戏，一日三餐，南来北往。渐渐，这成了一个司空见惯的事情。失落的时候练下吉他，你也曾想活在音乐的小世界里无人问津…\n每天坚持吃早饭，天气暖和会去操场跑步，中午很难睡着，晚上精力旺盛到连开玩笑都尤其认真，每一次赶作业都是一场和时间赛跑的特殊行动，当然你还可以在期末的时候完成一些感觉惊天动地的事情﻿…\n你慢慢疏远书本理论里面的成就感，开始厌倦众口一词的最佳答案，逃避一次又一次选择中的唯唯诺诺，沉醉在自己对于儿时梦境的美好想往里…\n你不是学霸也没进学生会，你总是庆幸地以为低分通过就是比那个挂了科的室友强，你甚至想着在学校待上四年然后发财，慢慢地，你变得不愿意参加带着利益性质炫耀嘲讽的社团活动，没有能力去美化人家的游戏体验…\n这是一个记忆稍纵即逝的年纪，你读的那些感觉挺有意思的书，随着旋转的时间轴忘得所剩无几。你做了一些兼职，挣了一点小钱，在同学面前过得洋洋洒洒。你去过几个地方，认识了好少好少可以交心的人，每次吃饭想说心里话的时候，你总害怕别人抓住你的软肋而欲言又止。你还考了几个希望能给未来生活带来惊喜的证书……\n做到这些，平淡的度过大学，你也很害怕平凡的你一无所成。﻿﻿\n—3—\n这是一个花里胡哨的时代，你可能永远都不会知道，那个在朋友圈里高大上的陌生人，在真实里，究竟是怎样的际遇。﻿﻿\n你尽可能的在人前把自己装点得光鲜亮丽，绅士般的接受所有的缘行渐远。你变得害怕承诺，躲避爱情，却又不愿意享受孤独，独当一面…﻿﻿\n你见识到的世界的确比父辈要大，可是对自我的认知却很浅。\n你每天在爆炸的信息中学习各种道理，通过网络你知道了身边好多人赢，于是你变得更加不甘平凡，时而凝神聚气的笃定，时而云淡风轻的随意，在对比中渐渐迷失﻿…﻿﻿\n﻿你感觉自己变成了一台机器，可以不对生活付诸任何情感，他能一直工作，只是会越来越慢。﻿﻿\n如果现在有一个可以看到的决定，未来你会在世界的某一个角落，从事一份称心如意的职业，可能你就不会在错过一节专业课的时候坐立不安，更不会因为身边的人活的体面潇洒而心惊胆战了。﻿﻿\n也许正是因为这种人生的不确定性，才愈加增大了人们对未来五彩缤纷的构想吧。﻿﻿\n克莱顿在《你要如何衡量你的人生》中提到，人对自己一生的规划，无非是周密战略和意外机遇相结合的产物，关键是要走出去，并行动起来，直到你明白应该将自己的聪明才智，兴趣和重点放在哪里，再将应急战略转化为周密战略。\n我希望你，在试图跳出规则之前，能做出关于自己本心的选择，愿你强大到能冲破社会的桎梏，以自己愿意的姿态生活下去。﻿﻿﻿\n","slug":"大学里，最丧的时候","date":"2018-10-18T03:12:12.000Z","categories_index":"随笔","tags_index":"成长，旧时光","author_index":"弦好想断"}]