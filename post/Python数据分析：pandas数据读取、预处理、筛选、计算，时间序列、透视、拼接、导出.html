<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="Hexo Theme Keep">
    <meta name="author" content="WenGe Zhang">
    
    <title>
        
            Python数据分析 :pandas数据读取、预处理、筛选、计算，时间序列、透视、拼接、导出 |
        
        弦好想断
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="shortcut icon" href="/images/logo.svg">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/css/font-awesome.min.css">
    <script id="hexo-configurations">
    let KEEP = window.KEEP || {};
    KEEP.hexo_config = {"hostname":"example.com","root":"/","language":"zh-CN","path":"search.xml"};
    KEEP.theme_config = {"toc":{"enable":true,"number":true,"expand_all":false,"init_open":true},"style":{"primary_color":"#0066CC","avatar":"/images/avatar.svg","favicon":"/images/logo.svg","article_img_align":"left","left_side_width":"260px","content_max_width":"920px","hover":{"shadow":"true# shadow effect when the mouse hover","scale":"true# scale effect when the mouse hover"},"first_screen":{"enable":true,"background_img":"/images/bg.svg","description":"毋庸置疑，好的事情总会到来，而当它来晚的时候，也不失为一种惊喜。"},"scroll":{"progress_bar":{"enable":true},"percent":{"enable":true}}},"local_search":{"enable":true,"preload":true},"code_copy":{"enable":true,"style":"default"},"pjax":{"enable":true},"lazyload":{"enable":true},"version":"3.4.3"};
    KEEP.language_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 月前","year":"%s 年前"};
  </script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
<div class="progress-bar-container">
    
        <span class="scroll-progress-bar"></span>
    

    
        <span class="pjax-progress-bar"></span>
        <span class="pjax-progress-icon">
            <i class="fas fa-circle-notch fa-spin"></i>
        </span>
    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="header-wrapper">

    <div class="header-content">
        <div class="left">
            
            <a class="logo-title" href="/">
                弦好想断
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                首页
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/archives"
                            >
                                归档
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/tags"
                            >
                                标签
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/about"
                            >
                                关于
                            </a>
                        </li>
                    
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fas fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/">首页</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives">归档</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/tags">标签</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/about">关于</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="article-content-container">

        <div class="article-title">
            <span class="title-hover-animation">Python数据分析 :pandas数据读取、预处理、筛选、计算，时间序列、透视、拼接、导出</span>
        </div>

        
            <div class="article-header">
                <div class="avatar">
                    <img src="/images/avatar.svg">
                </div>
                <div class="info">
                    <div class="author">
                        <span class="name">WenGe Zhang</span>
                        
                            <span class="author-label">干饭分析师</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fas fa-edit"></i>&nbsp;2021-10-04 14:02:22
    </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fas fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/">数据分析</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fas fa-file-word"></i>&nbsp;<span>6.8k 字</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fas fa-clock"></i>&nbsp;<span>30 分钟</span>
        </span>
    
    
        <span class="article-pv article-meta-item">
            <i class="fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                    </div>
                </div>
            </div>
        

        <div class="article-content markdown-body">
            <h3 id="一、Pandas数据结构"><a href="#一、Pandas数据结构" class="headerlink" title="一、Pandas数据结构"></a>一、Pandas数据结构</h3><pre class="line-numbers language-none"><code class="language-none">S1&#x3D;pd.Series([‘a’,’b’,’c’]) series是一组数据与一组索引（行索引）组成的数据结构
S1&#x3D;pd.Series([‘a’,’b’,’c’],index&#x3D;(1,3,4)) 指定索引
S1&#x3D;pd.Series(&#123;1:‘a’,2:’b’,3:’c’&#125;) 用字典形式指定索引
S1.index() 返回索引
S1.values() 返回值
Df&#x3D;pd.DataFrame([‘a’,’b’,’c’]) dataframe是一组数据与两组索引（行列索引）组成的数据结构
Df&#x3D;pd.DataFrame([[a,A],[b,B],[c,C]],columns&#x3D;[‘小写’,’大写’]，index&#x3D;[‘一’,’二’,’三’])
Columms 为列索引，index为行索引
pip install -i [https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple](https:&#x2F;&#x2F;link.zhihu.com&#x2F;?target&#x3D;https%3A&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple) pyspider 清华镜像</code></pre>
<ul>
<li>查找某个包 anaconda search -t conda tensorflow<br>下载某个包 anaconda show package<br>data={‘小写’:[‘a’,’b’,’c’],’大写’:[‘A’,’B’,’C’]} 传入字典<br>Df=Pd.DataFrame(data)<br>Df.index() df.columns()</li>
<li>建立分层索引的dataframe：pd.MultiIndex.from_arrays([[,,]],name=[,,]）</li>
</ul>
<h3 id="二、读取数据"><a href="#二、读取数据" class="headerlink" title="二、读取数据"></a>二、读取数据</h3><pre class="line-numbers language-none"><code class="language-none">df&#x3D;pd.read_excel(r’C:\user\...xlsx’,sheet_name&#x3D;’sheet1’) 或
pd.read_excel(r’C:\user\...xlsx’,sheet_name&#x3D;0) 读取excel表
pd.read_excel(r’C:\user\...xlsx’,index_col&#x3D;0,header&#x3D;0)
index_col指定行索引，header指定列索引
pd.read_excel(r’C:\user\...xlsx’,usecols&#x3D;[0,1]) 导入指定列,不能有index_col和header
pd.read_tablel(r’C:\user\...txt’，sep&#x3D;’ ’) 导入txt文件,sep指定分隔符是什么
df.head(2) 展示前两行，默认展示前5行
df.shape 显示数据几行几列，不包含行和列索引
df.info()可查看表中数据的类型
df.describe() 可获得表中数值类型指端的分布值（和、平均值、方差等）</code></pre>
<ul>
<li>获取Excel文件下所有的sheet名称<pre class="line-numbers language-none"><code class="language-none"># 读取所有Sheet
df &#x3D; pd.read_excel(&#39;456.xlsx&#39;, sheet_name&#x3D;None)
# 第一种
for i in df.keys():
    print(i)
# 第二种
df &#x3D; pd.read_excel(&#39;456.xlsx&#39;, sheet_name&#x3D;None)
print(list(df))</code></pre></li>
</ul>
<h3 id="三、数据预处理"><a href="#三、数据预处理" class="headerlink" title="三、数据预处理"></a>三、数据预处理</h3><ul>
<li><p>多个Series合并成DataFrame：pd.DataFrame(list(zip(series_1, series_2)))</p>
</li>
<li><p>python在字符串前面加0：str(1).zfill(2)</p>
<pre class="line-numbers language-none"><code class="language-none">df.info() 可显示表中哪个数据为空
df.isnull() 方法可以判断哪个值是缺失值，如果缺失返回True，否则为False
df.dropna() 默认删除含缺失值的行
df.dropna(how&#x3D;’all’) 删除全为空值的行，不全为空值的行不会删除
df.fillna(0) 用0填充所有空值
df.fillna(&#123;‘性别’:’男’,’年龄’:’30’&#125;) 对性别列中空值填充男，年龄填充30</code></pre></li>
<li><p>通过随机选择非缺失值来填充缺失值<br>foo[‘A’].apply(lambda x: np.random.choice(<br>[x for x in range(min(foo[‘A’]),max(foo[‘A’])]) if (np.isnan(x)) else x)</p>
</li>
<li><p>按一列数据填充另一列数据中的缺失值<br>df_real[‘净含量’] = df_real[‘净含量’].fillna(df_real[‘净含量_y’])</p>
</li>
<li><p>df1.combine_first(df2)：将df2的非缺失值填充df1中的缺失（dataframe根据列名和索引）值；<br>ser1.combine_first(ser2)：用ser2的非缺失值填充ser1中的缺失值（series根据索引）</p>
</li>
<li><p>按指定的字符合并多列：df[‘A’].str.cat([df[‘B’], df[‘C’]], sep=’-‘)</p>
<pre class="line-numbers language-none"><code class="language-none">df.drop_duplicates(inplace&#x3D;True) 默认对所有值进行重复值检查，保留第一行的值，inplace&#x3D;True表示直接在原来的DataFrame上删除重复项，而默认值False表示生成一个副本。
df.drop_duplicates(subset&#x3D;’性别’) 对性别列中重复值查询保留第一行
df.drop_duplicates(subset&#x3D;[’性别’,’公司’]，keep&#x3D;’last’) 对性别和公司两列查重
keep设置默认为first（保留第一个），可设置为last（保留最后一个） 或False(都不保留)
df[‘ID’].dtype 查看ID列的数据类型
df[‘ID’].astype(‘float’) 将ID列的数据类型转换为float类型
数据类型：int、float、object、string、unicode、datetime
df[‘ID’][1] ID列的第二个数据
df.columns&#x3D;[‘大写’,’小写’,’中文’] 为无索引表添加列索引
df.index&#x3D;[1,2,3] 添加行索引
df.set_index(‘编号’) 指明要用的列作为行索列
df.rename(index&#x3D;&#123;‘订单编号’:’新订单编号’,’客户姓名’:’新客户姓名’&#125;) 对行索引进行重新命名
df.rename(columns&#x3D;&#123;1:’一’,2:’二’&#125;) 对列索引进行一次性重新命名所有列名
如果你需要做的仅仅是将空格换成下划线，那么更好的办法是使用str.replace()方法，这是因为你都不需要输入所有的列名：
df.columns &#x3D; df.columns.str.replace(   ,  _ )
df.reset_index() 默认将全部index转化为column,
df.reset_index(level&#x3D;0) 将0级索引转化为column
df.reset_index(drop&#x3D;True) 删除原有索引</code></pre></li>
<li><p>多列合并为一行<br>df = pd.DataFrame({‘id_part’:[‘a’,’b’,’c’,’d’], ‘pred’:[0.1,0.2,0.3,0.4], ‘pred_class’:[‘women’,’man’,’cat’,’dog’], ‘v_id’:[‘d1’,’d2’,’d3’,’d1’]})<br>df.groupby([‘v_id’]).agg({‘pred_class’: [‘, ‘.join],’pred’: lambda x: list(x),’id_part’: ‘first’}).reset_index()</p>
</li>
<li><p>字符串转换为数值<br>df = pd.DataFrame({‘列1’:[‘1.1’,’2.2’,’3.3’],’列2’:[‘4.4’,’5.5’,’6.6’],’列3’:[‘7.7’,’8.8’,’-‘]})<br>df.astype({‘列1’:’float’,’列2’:’float’}).dtypes<br>用这种方式转换第三列会出错，因为这列里包含一个代表 0 的下划线，pandas 无法自动判断这个下划线。为了解决这个问题，可以使用 to_numeric() 函数来处理第三列，让 pandas 把任意无效输入转为 NaN。<br>df = df.apply(pd.to_numeric, errors=’coerce’).fillna(0)</p>
</li>
<li><p>优化 DataFrame 对内存的占用<br>方法一：只读取切实所需的列，使用usecols参数<br>cols = [‘beer_servings’,’continent’]<br>small_drinks = pd.read_csv(‘data/drinks.csv’, usecols=cols)<br>方法二：把包含类别型数据的 object 列转换为 Category 数据类型，通过指定 dtype 参数实现。<br>dtypes ={‘continent’:’category’}<br>smaller_drinks = pd.read_csv(‘data/drinks.csv’,usecols=cols, dtype=dtypes)</p>
</li>
<li><p>把字符串分割为多列<br>df = pd.DataFrame({‘姓名’:[‘张 三’,’李 四’,’王 五’],’所在地’:[‘北京-东城区’,’上海-黄浦区’,’广州-白云区’]})<br>df.姓名.str.split(‘ ‘, expand=True)</p>
</li>
<li><p>把 Series 里的列表转换为 DataFrame<br>df = pd.DataFrame({‘列1’:[‘a’,’b’,’c’],’列2’:[[10,20], [20,30], [30,40]]})<br>df_new = df.列2.apply(pd.Series)<br>pd.concat([df,df_new], axis=’columns’)</p>
</li>
<li><p>DataFrame迭代：<br>iterrows():将DataFrame迭代为(insex, Series)对。<br>iteritems():将DataFrame迭代为(列名, Series)对。<br>itertuples(): 将DataFrame迭代为元组。<br>for row in df.itertuples():<br>  print(row)<br>  print(‘—————-‘)<br>  print(getattr(row,’col1’), getattr(row,’col2’))<br>getattr() 函数用于返回一个对象属性值。</p>
</li>
</ul>
<h3 id="四、数据选择"><a href="#四、数据选择" class="headerlink" title="四、数据选择"></a>四、数据选择</h3><ul>
<li><p>Query是pandas的过滤查询函数，使用布尔表达式来查询DataFrame的列，就是说按照列的规则进行过滤操作。<br>pandas.DataFrame.query(self, expr, inplace = False, **kwargs)<br>expr：要评估的查询字符串；<br>inplace=False：查询是应该修改数据还是返回修改后的副本<br>kwargs：dict关键字参数<br>比如要查列<code>value_1</code>&lt;<code>value_2</code>的行记录：df.query(‘value_1 &lt; value_2’)<br>查询列<code>year</code>&gt;=2016的行记录：df.query(‘year &gt;= 2016 ‘)</p>
</li>
<li><p>Insert用于在DataFrame的指定位置中插入新的数据列。默认情况下新列是添加到末尾的，但可以更改位置参数，将新列添加到任何位置。<br>Dataframe.insert(loc, column, value, allow_duplicates=False)<br>loc: int型，表示插入位置在第几列；若在第一列插入数据，则 loc=0<br>column: 给插入的列取名，如 column=’新的一列’<br>value：新列的值，数字、array、series等都可以<br>allow_duplicates: 是否允许列名重复，选择Ture表示允许新的列名与已存在的列名重复<br>在第三列的位置插入新列：df.insert(2, ‘new_col’, new_col)</p>
</li>
<li><p>DataFrame首行插入行</p>
<pre class="line-numbers language-none"><code class="language-none">df.loc[-1] &#x3D; [10, 20, 30]  # 增加一行
df.index &#x3D; df.index + 1  # 把index的每一项增加1
df &#x3D; df.sort_index()  #重新排序一下</code></pre></li>
<li><p>Cumsum是pandas的累加函数，用来求列的累加值。 用法：<br>DataFrame.cumsum(axis=None, skipna=True, args, kwargs)<br>axis：index或者轴的名字<br>skipna：排除NA/null值<br>df中的group列有A、B、C三组，year列有多个年份。我们只知道当年度的值value_1、value_2，现在求group分组下的累计值，比如A、2014之前的累计值，可以用cumsum函数来实现。<br>当然仅用cumsum函数没办法对groups (A, B, C)进行区分，所以需要结合分组函数groupby分别对(A, B, C)进行值的累加。<br>df[‘cumsum_2’] = df[[‘value_2’,’group’]].groupby(‘group’).cumsum()</p>
</li>
<li><p>Sample用于从DataFrame中随机选取若干个行或列。 用法：<br>DataFrame.sample(n=None, frac=None, replace=False, weights=None, random_state=None, axis=None)<br>n：要抽取的行数<br>frac：抽取行的比例 例如frac=0.8，就是抽取其中80%<br>replace：是否为有放回抽样， True:有放回抽样 False:未放回抽样<br>weights：字符索引或概率数组<br>random_state ：随机数发生器种子<br>axis：选择抽取数据的行还是列 axis=0:抽取行 axis=1:抽取列<br>从df中随机抽取5行：df.sample(n=5)<br>从df随机抽取60%的行，并且设置随机数种子，每次能抽取到一样的样本：df.sample(frac=0.6,random_state=2)</p>
</li>
<li><p>Where用来根据条件替换行或列中的值。如果满足条件，保持原来的值，不满足条件则替换为其他值。默认替换为NaN，也可以指定特殊值。<br>DataFrame.where(cond, other=nan, inplace=False, axis=None, level=None, errors=’raise’, try_cast=False, raise_on_error=None)<br>cond：布尔条件，如果 cond 为真，保持原来的值，否则替换为other<br>other：替换的特殊值<br>inplace：inplace为真则在原数据上操作，为False则在原数据的copy上操作<br>axis：行或列<br>将df中列value_1里小于5的值替换为0：df[‘value_1’].where(df[‘value_1’] &gt; 5 , 0)</p>
</li>
<li><p>得到DataFrame中重复的数据</p>
<pre class="line-numbers language-none"><code class="language-none">data&#x3D;&#123;&#39;one&#39;:[1,1,2,2,1,2,2],&#39;two&#39;:[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;]&#125;
frame&#x3D;pd.DataFrame(data)
print(&quot;原始数据&quot;)
print(frame)
data1 &#x3D; frame.drop_duplicates(subset&#x3D;[&#39;two&#39;],keep&#x3D;&#39;first&#39;)
print(&quot;去重后的数据&quot;)
print(data1)
a &#x3D; frame.drop_duplicates(subset&#x3D;[&#39;two&#39;],keep&#x3D;&#39;last&#39;)
b &#x3D; frame.drop_duplicates(subset&#x3D;[&#39;two&#39;],keep&#x3D;False)
c&#x3D;a.append(b).drop_duplicates(subset&#x3D;[&#39;two&#39;],keep&#x3D;False)
print(&quot;重复的数据&quot;)
print(c)</code></pre></li>
<li><p>索引切片</p>
<pre class="line-numbers language-none"><code class="language-none">df[[‘ID’,’姓名’]] 多个列名要装入list
df.iloc[[1,3],[2,4]] 用行列编号选择数据
df.iloc[1,1] 选取表中的第3行2列数据，第一行默认为列索引
df.iloc[:,0:4] #获取第1列到第4列的值
df.loc[‘一’] #loc用行名选取的行数据，格式是Series，但可以用列表形式访问
df.loc[‘一’][0] 或 df.loc[‘一’][‘序号’]
df.iloc[1]#iloc用行编号选取行数据
df.iloc[[1,3]]#多行编号选取行数据，要用list封装，不然变成行列选取
df.iloc[1:3]#选择第二行和第四行
df[df[‘年龄’]&lt;45] #加判断条件返回符合条件的全部数据，不局限年龄列
df[(df[‘年龄’]&lt;45)&amp;(df[‘ID’]&lt;4)] #判断多条件选择数据
df.iloc[[1,3],[2,4]] 相当于df.loc[[‘一’,’二’],[‘年龄’,’ID’]] #loc是名，iloc是编号
df[df[‘年龄’]&lt;45][[‘年龄’,’ID’]]#先通过年龄条件选择行，再通过不同索引指定列
df.iloc[1:3,2:4]#切片索引</code></pre></li>
<li><p>pandas 筛选时间日期数据</p>
<p>这里筛选2020年5月的数据为例：<br>首先将日期格式化：</p>
<pre class="line-numbers language-none"><code class="language-none">data[&#39;日期&#39;]&#x3D;data[&quot;日期&quot;].values.astype(&#39;datetime64&#39;)  #如果已为日期格式则此步骤可省略
import datetime
s_date &#x3D; datetime.datetime.strptime(&#39;2020-04-30&#39;, &#39;%Y-%m-%d&#39;).date()  #起始日期
e_date &#x3D; datetime.datetime.strptime(&#39;2020-06-01&#39;, &#39;%Y-%m-%d&#39;).date()  #结束日期</code></pre>
<p>第一种方法，用逻辑运算符号’&gt;’ ‘&lt;’和’&amp;’：</p>
<p>Pandasdatetime64[ns]不能直接与datetime.date相比，需要用pd.Timestamp进行转化</p>
<pre class="line-numbers language-none"><code class="language-none">data[(data.日期&gt;pd.Timestamp(s_date))&amp;(data.日期&lt;pd.Timestamp(e_date))]</code></pre>
<p>第二种，用比较函数’gt’’lt’和’&amp;’:</p>
<pre class="line-numbers language-none"><code class="language-none">data[(data[&#39;日期&#39;].lt(pd.Timestamp(e_date)))&amp;(data[&#39;日期&#39;].gt(pd.Timestamp(s_date)))]</code></pre>
<p>第三种，用apply函数实现:</p>
<pre class="line-numbers language-none"><code class="language-none">id_a&#x3D;data.日期.apply(lambda x: x.year &#x3D;&#x3D;2020  and x.month&#x3D;&#x3D;5)
data[id_a]</code></pre>
<p>第四种，用between函数实现:</p>
<pre class="line-numbers language-none"><code class="language-none">id_b&#x3D;data.日期.between(pd.Timestamp(s_date),pd.Timestamp(e_date))
data[id_b]</code></pre></li>
<li><p>行序、列序反转 ：行序反转最直接的办法是使用loc函数并传递::-1，跟Python中列表反转时使用的切片符号一致<br>df.loc[::-1].reset_index(drop=True)<br>列序反转就比较容易了，只需要如下操作：df.loc[:, ::-1]</p>
</li>
<li><p>分组里最大值所在的行方法<br>分为分组中有重复值和无重复值两种。无重复值的情况。<br>df = pd.DataFrame({‘Sp’:[‘a’,’b’,’c’,’d’,’e’,’f’], ‘Mt’:[‘s1’, ‘s1’, ‘s2’,’s2’,’s2’,’s3’], ‘Value’:[1,2,3,4,5,6], ‘Count’:[3,2,5,10,10,6]})<br>df.iloc[df.groupby([‘Mt’]).apply(lambda x: x[‘Count’].idxmax())]<br>先按Mt列进行分组，然后对分组之后的数据框使用idxmax函数取出Count最大值所在的列，再用iloc位置索引将行取出。有重复值的情况<br>df[“rank”] = df.groupby(“ID”)[“score”].rank(method=”min”, ascending=False).astype(np.int64)<br>df[df[“rank”] == 1][[“ID”, “class”]]<br>对ID进行分组之后再对分数应用rank函数，分数相同的情况会赋予相同的排名，然后取出排名为1的数据。</p>
</li>
<li><p>选择特定类型的列<br>drinks = pd.read_csv(‘data/drinks.csv’)<br>选择所有数值型的列<br>drinks.select_dtypes(include=[‘number’]).head()<br>选择所有字符型的列<br>drinks.select_dtypes(include=[‘object’]).head()<br>drinks.select_dtypes(include=[‘number’,’object’,’category’,’datetime’]).head()<br>用 exclude 关键字排除指定的数据类型<br>drinks.select_dtypes(exclude=[‘number’]).head()</p>
</li>
<li><p>根据最大的类别筛选 DataFrame<br>movies = pd.read_csv(‘data/imdb_1000.csv’)<br>counts = movies.genre.value_counts()<br>movies[movies.genre.isin(counts.nlargest(3).index)].head()</p>
</li>
<li><p>基于字符串的长度来筛选数据<br>df[df.col1.str.len() &gt; 20].head()</p>
</li>
<li><p>标注重点<br>df_new.style.highlight_max(axis = 0, color = “yellow”)</p>
</li>
</ul>
<h3 id="五、数值操作"><a href="#五、数值操作" class="headerlink" title="五、数值操作"></a>五、数值操作</h3><pre class="line-numbers language-none"><code class="language-none">df[‘年龄’].replace(100,33)#对年龄列中的100替换成33
df.replace(np.NaN,0)#相当于fillna(),其中np.NaN是python中缺省值的表示方式
df.replace([A,B],C)#多对一替换，A、B替换成C
df.replace(&#123;‘A’:’a’,‘B’:’b’,‘C’:’c’&#125;)#多对多替换
df.sort_values(by&#x3D;[&#39;申请单编号&#39;],ascending&#x3D;False)#申请单编号列降序排列，Ture升序排列（默认）
df.sort_values(by&#x3D;[&#39;申请单编号&#39;],na_position&#x3D;’first’)#申请单编号列升序排列，缺失值排在第一位
默认缺失值在最后一位last
df &#x3D; pd.DataFrame([[&#39;A&#39;,1],[&#39;A&#39;,3],[&#39;A&#39;,2],[&#39;B&#39;,5],[&#39;B&#39;,9]], columns &#x3D; [&#39;name&#39;,&#39;score&#39;])
df.sort_values([&#39;name&#39;,&#39;score&#39;], ascending &#x3D; [True,False])#多列排序
df.groupby(&#39;name&#39;).apply(lambda x: x.sort_values(&#39;score&#39;,ascending&#x3D;False)).reset_index(drop&#x3D;True)</code></pre>
<ul>
<li>Pct_change是一个统计函数，用于表示当前元素与前面元素的相差百分比，两元素的区间可以调整。<br>比如说给定三个元素[2,3,6]，计算相差百分比后得到[NaN, 0.5, 1.0]，从第一个元素到第二个元素增加50％，从第二个元素到第三个元素增加100％。<br>DataFrame.pct_change(periods=1, fill_method=‘pad’, limit=None, freq=None, **kwargs)<br>periods：间隔区间，即步长<br>fill_method：处理空值的方法<br>对df的value_1列进行增长率的计算：df.value_1.pct_change()</li>
</ul>
<ul>
<li> pandas 进行组内排序、单组排序、标号<pre class="line-numbers language-none"><code class="language-none">df[‘销量’].rank(method&#x3D;’first’)#销量排名（不是排序），method有first\min\max\average
组内进行排序(按user_id分组后对product_id排序)
data1[&#39;group_sort&#39;]&#x3D;data1[&#39;product_id&#39;].groupby(data1[&#39;user_id&#39;]).rank(ascending&#x3D;1,method&#x3D;&#39;first&#39;)</code></pre></li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">df.drop([‘销量’,’ID’],axis&#x3D;1)#删除列,直接是列名,inpace&#x3D;True是保留修改哦
df.drop(df.columns[[4,5]],axis&#x3D;1)#删除列,是编号
df.drop(colums&#x3D;[‘销量’,’ID’])#此种方式删除列，可以不写axis&#x3D;1
df.drop([‘a’,’b’],axis&#x3D;0)#删除行,直接是列名
df.drop(df.index[[4,5]],axis&#x3D;0)#删除行,是编号
df.drop(index&#x3D;[‘a’,’b’])#此种方式删除行，可以不写axis&#x3D;0
df[‘ID’].value_counts()#对ID列中数据出现的次数进行统计
df[‘ID’].value_counts(normalize&#x3D;Ture,sort&#x3D;False)#对ID列中数据出现的次数占比进行统计，并降序排序
df[‘ID’].unique()#获取列的唯一值
df[‘年龄’].isin([‘a’,11])#查看这列中是否包含a或11
pd.cut(df[‘ID’],bins&#x3D;[0,3,6,10])#用bins指明切分区间
pd.qcut(df[‘ID’],3)#ID列切分成3个部分，每部分数据个数尽量一致
df.insert(2,’商品’,[‘书’,’笔’,’计算器’])#插入第三列
df[’商品’]&#x3D;[‘书’,’笔’,’计算器’])#插新列，在表的最后面
df.T行列互换
df.tack()#把表格型数据转化成树形数据
df.set_index([‘ID’,’姓名’]).stack().reset_index()#宽表转换成长表，先将共同列设置成行索引，再对其他列
进行转化成树形数据，再重置行索引</code></pre>
<ul>
<li><p>堆叠：pd.DataFrame.stack(self, level=-1, dropna=True)，level默认为-1是将最内层col堆叠为索引的最内层，为0是将最外层col堆叠为索引的最内层，从最外层开始依次的level值为0，1，2…的顺序来指定对应col。当然直接指定索引名称或许是更好的选择。</p>
</li>
<li><p>反堆叠、拆堆：pd.DataFrame.unstack(self, level=-1, fill_value=None)，默认将最内层的索引拆堆到列的最内层，其他同理stack()；</p>
</li>
<li><p>df.melt(id_vars=[‘ID’,’姓名’],var_name=’year’,value_name=’sale’)<br>id_var参数指明宽表转换成长表时保持不变的列，var_name参数表示原来的列索引转化为行索引对应的列名，value_name表示新索引对应值的列名<br>df[‘C1’].apply(lambda x:x+1)#相当于map(),只是需要和lambda配合<br>df.applymap(lambda x:x+1),对表中的所有数据执行相同函数运算</p>
</li>
<li><p>apply搭配匿名函数lambda的神奇用法：<br>df[‘数据3’] = df.apply(lambda x:(x.数据1-x.数据2)/x.上月 if x.col3!=0 else 0 ,axis=1)</p>
</li>
<li><p>删除包含特定字符串所在的<br>行：df[‘b’].values.astype(‘str’) 先转为字符串格式最好；<br>df[df[‘b’].str.contains(‘exp’,na=False)]</p>
</li>
<li><p>计算变量缺失率</p>
<pre class="line-numbers language-none"><code class="language-none">def missing_cal(df):
    &quot;&quot;&quot;
    df :数据集
    return：每个变量的缺失率
    &quot;&quot;&quot;
    missing_series &#x3D; df.isnull().sum()&#x2F;df.shape[0]
    missing_df &#x3D; pd.DataFrame(missing_series).reset_index()
    missing_df &#x3D; missing_df.rename(columns&#x3D;&#123;&#39;index&#39;:&#39;col&#39;,
    0:&#39;missing_pct&#39;&#125;)
    missing_df &#x3D; 	missing_df.sort_values(&#39;missing_pct&#39;,ascending&#x3D;False).reset_index(drop&#x3D;True)
    return missing_df
missing_cal(df)
如果需要计算样本的缺失率分布，只要加上参数axis&#x3D;1。</code></pre>
<h3 id="六、数据运算"><a href="#六、数据运算" class="headerlink" title="六、数据运算"></a>六、数据运算</h3><pre class="line-numbers language-none"><code class="language-none">df[‘ID’]+Df[‘ID’]#可进行加减乘除
df[‘ID’]&gt;Df[‘ID’]#可进行&gt; &lt; &#x3D;&#x3D; !&#x3D;等比较运算
df.nunique()#统计每列不重复值的个数
df.count()#统计每列的非空值的个数
df.count(axis&#x3D;1)#统计每行的非空值的个数
df[‘ID’].count()#统计指定列的非空值的个数
df.sum(axis&#x3D;1)#每列&#x2F;行求和结果
df.mean(axis&#x3D;1)#每列&#x2F;行求均值
df.max(axis&#x3D;1)#每列&#x2F;行求最大值
df.min(axis&#x3D;1)#每列&#x2F;行求最小值
df.median(axis&#x3D;1)#每列&#x2F;行求中间值
df.mode(axis&#x3D;1)#每列&#x2F;行中出现最多的值
df.var(axis&#x3D;1)#每列&#x2F;行求方差
df.std(axis&#x3D;1)#每列&#x2F;行求标准差
df.quantile(0.25)#求1&#x2F;4分位数，可以0.5、0.75等分位数
df.corr()#求整个DataFrame表中的相关性</code></pre>
<h3 id="七、时间序列"><a href="#七、时间序列" class="headerlink" title="七、时间序列"></a>七、时间序列</h3><pre class="line-numbers language-none"><code class="language-none">from datetime import datetime
datatime.now()#返回现在的时间年月日时分秒
datatime.now().year#返回年，可以.month\.day
datatime.now().weekday()-1#返回周几
datatime.now().isocalendar()#返回周数
（2018，41，7）#2018年的第41周第7天
datatime.now().date()#只返回年月日
datatime.now().time()#只返回时间
datatime.now().strftime(‘%Y-%m-%d %H:%M:%S’)#返回2020-03-13 09:09:12
pd.to_datetime([&#39;201221&#39;],format &#x3D; &quot;%Y%m%d&quot;)#返回DatetimeIndex([&#39;2012-02-01&#39;], dtype&#x3D;&#39;datetime64[ns]&#39;, freq&#x3D;None)
pd.to_datetime(&#39;201221&#39;,format &#x3D; &quot;%Y%m%d&quot;)#不加列表，返回Timestamp(&#39;2012-02-01 00:00:00&#39;)，需要省去时分秒可以在后面加.strftime(&quot;%Y-%m-%d&quot;)
from dateutil.parser import parse
parse(str_time)#将字符串的时间转化成为时间格式
pd.Datetimeindex([‘2020-02-03’,2020-03-05’])#设置时间索引
data[‘2018’]#获取2018年的数据
data[‘2018-01’]#获取2018年1月的数据
data[‘2018-01-05’:‘2018-01-15’]#获取这个时段的数据
非时间索引的表格处理
df[df[‘成交时间’]&#x3D;&#x3D;datetime(2018,08,05)]
df[df[‘成交时间’]&gt;datetime(2018,08,05)]
df[(df[‘成交时间’]&gt;datetime(2018,08,05))&amp;(df[‘成交时间’] &lt;datetime(2018,08,15))]
cha&#x3D;datatime(2018,5,21,19,50)-datatime(2018,5,18,17,50)
cha.days#返回天的时间差
cha.seconds#返回秒的时间差
cha.seconds&#x2F;3600#返回小时的时间差
datatime(2018,5,21,19,50)+timedelta(days&#x3D;1)#往后移一天
datatime(2018,5,21,19,50)+timedelta(seconds&#x3D;20)#往后移20秒
datatime(2018,5,21,19,50)-timedelta(days&#x3D;1)#往前移一天</code></pre>
<p>日期时间类型接口一览表</p>
<pre class="line-numbers language-none"><code class="language-none">df &#x3D; generate_sample_data_datetime().reset_index()
df &#x3D; df.sample(500)
df[&quot;Year&quot;] &#x3D; df[&quot;index&quot;].dt.year
df[&quot;Month&quot;] &#x3D; df[&quot;index&quot;].dt.month
df[&quot;Day&quot;] &#x3D; df[&quot;index&quot;].dt.day
df[&quot;Hour&quot;] &#x3D; df[&quot;index&quot;].dt.hour
df[&quot;Minute&quot;] &#x3D; df[&quot;index&quot;].dt.minute
df[&quot;Second&quot;] &#x3D; df[&quot;index&quot;].dt.second
df[&quot;Nanosecond&quot;] &#x3D; df[&quot;index&quot;].dt.nanosecond
df[&quot;Date&quot;] &#x3D; df[&quot;index&quot;].dt.date
df[&quot;Time&quot;] &#x3D; df[&quot;index&quot;].dt.time
df[&quot;Time_Time_Zone&quot;] &#x3D; df[&quot;index&quot;].dt.timetz
df[&quot;Day_Of_Year&quot;] &#x3D; df[&quot;index&quot;].dt.dayofyear
df[&quot;Week_Of_Year&quot;] &#x3D; df[&quot;index&quot;].dt.weekofyear
df[&quot;Week&quot;] &#x3D; df[&quot;index&quot;].dt.week
df[&quot;Day_Of_week&quot;] &#x3D; df[&quot;index&quot;].dt.dayofweek
df[&quot;Week_Day&quot;] &#x3D; df[&quot;index&quot;].dt.weekday
df[&quot;Week_Day_Name&quot;] &#x3D; df[&quot;index&quot;].dt.weekday_name
df[&quot;Quarter&quot;] &#x3D; df[&quot;index&quot;].dt.quarter
df[&quot;Days_In_Month&quot;] &#x3D; df[&quot;index&quot;].dt.days_in_month
df[&quot;Is_Month_Start&quot;] &#x3D; df[&quot;index&quot;].dt.is_month_start
df[&quot;Is_Month_End&quot;] &#x3D; df[&quot;index&quot;].dt.is_month_end
df[&quot;Is_Quarter_Start&quot;] &#x3D; df[&quot;index&quot;].dt.is_quarter_start
df[&quot;Is_Quarter_End&quot;] &#x3D; df[&quot;index&quot;].dt.is_quarter_end
df[&quot;Is_Leap_Year&quot;] &#x3D; df[&quot;index&quot;].dt.is_leap_year</code></pre>
<h3 id="八、数据透视表"><a href="#八、数据透视表" class="headerlink" title="八、数据透视表"></a>八、数据透视表</h3><pre class="line-numbers language-none"><code class="language-none">df.groupby(‘客户分类’).count()#客户分类后求数运算
df.groupby(‘客户分类’).sum()#客户分类后求和运算
df.groupby(‘客户分类’,’区域分类’).sum()#多列分类后求和运算
df.groupby(‘客户分类’,’区域分类’)[‘ID’].sum()#多列分类后ID求和运算
df[‘ID’]#DataFrame取出一列就是Series类型
df.groupby(df[‘ID’]).sum() 相当于 df.groupby(‘ID’).sum（）
df.groupby(‘客户分类’).aggregate([‘sum’,’count’]# aggregate可实现多种汇总方式
df.groupby(‘客户分类’).aggregate(&#123;‘ID’：‘count’,’销量’： ‘sum’&#125;)</code></pre></li>
<li><p>用多个函数聚合<br>df.groupby(‘order_id’).item_price.agg([‘sum’,’count’]).head()</p>
</li>
<li><p>aggregate可针对不同列做不同的汇总运算<br>df.groupby(‘客户分类’).sum().reset_index()#分组汇总后再重置索引，变为标准DataFrame<br>pd.pivot_table(data,values,index,columms,aggfunc,fill_value,margins,dropna,margins_name)<br>数据透视表，data:数据表df,values:值，index:行索引，columns:列索引，aggfunc:values的计算类型，fill_value:对空值的填充方式；margins:是否有合计列；margins_name:合计列的列名<br>pd.pivot_table(df,values=[’ID’,‘销量’],index=’客户分类’,columms=‘区域’,aggfunc={‘ID’：‘count’,’销量’：‘sum’}),fill_value=0,margins=Ture,dropna=None,margins_name=’总计’)</p>
</li>
<li><p>分组聚合 dict(list(df.groupby(‘key1’)))<br>通过字典或Series进行分组<br>people = pd.DataFrame(np.random.randn(5, 5),columns=[‘a’, ‘b’, ‘c’, ‘d’, ‘e’],index=[‘Joe’, ‘Steve’, ‘Wes’, ‘Jim’, ‘Travis’])<br>mapping = {‘a’:’red’, ‘b’:’red’, ‘c’:’blue’, ‘d’:’blue’, ‘e’:’red’, ‘f’:’orange’}<br>by_column = people.groupby(mapping, axis=1)<br>by_column.sum()</p>
</li>
</ul>
<h3 id="九、多表格拼接"><a href="#九、多表格拼接" class="headerlink" title="九、多表格拼接"></a>九、多表格拼接</h3><pre class="line-numbers language-none"><code class="language-none">pd.merge(df1,df2)#默认自动寻找两个表中的公共列进行拼接
pd.merge(df1,df2,on&#x3D;“学号“)#on来指定连接列，连接列要是公共列
pd.merge(df1,df2,on&#x3D;[‘学号’,’姓名’]#on来指定连接列，连接列要是公共列
pd.merge(df1,df2,left_on&#x3D;‘学号’right_on&#x3D;’编号’) #由公共列，但类名不同时用左右键指定 
pd.merge(df1,df2,left_index&#x3D;‘学号’right_index&#x3D;’编号’)#两表公共列都是索引列时
pd.merge(df1,df2,left_index&#x3D;‘学号’right_on&#x3D;’编号’)#公共列一个时索引列一个时普通列 
pd.merge(df1,df2,on&#x3D;’学号’,how&#x3D;’inner’)#返回公共列中对应的公共值拼接（内连接）
pd.merge(df1,df2,on&#x3D;’学号’,how&#x3D;’left’)#返回公共列中对应的左表值（左连接）
pd.merge(df1,df2,on&#x3D;’学号’,how&#x3D;’right’)#返回公共列中对应的右表值（右连接）
pd.merge(df1,df2,on&#x3D;’学号’,how&#x3D;’outer’)#返回公共列中对应的所有值（外连接）
pd.concat([df1,df2])#两个结构相同的表纵向连接，保留原索引值
pd.concat([df1,df2]，ignore_index&#x3D;True)#两个结构相同的表纵向连接，重新设置索引值
pd.concat([df1,df2]，ignore_index&#x3D;True).drop_duplicates()#拼接后去掉重复值</code></pre>

<h3 id="十、导出文件"><a href="#十、导出文件" class="headerlink" title="十、导出文件"></a>十、导出文件</h3><p>df.to_excel(excel_writer=r’C:\users\zhoulifu\Desktop\测试.xlsx’,sheet_name=’文档’，index=False,columns=[‘ID’,’销量’,‘姓名’],encoding=’utf-8’,na_rep=0)</p>
<ul>
<li>excel_writer参数指定文件路径，导出时去掉索引，设置导出的列，指定文件编码，na_rep缺失值填充<br>writer=pd.ExcelWriter(excelpath,engine=’xlsxwirter’)<h3 id="导出多个文件至一个文件的多个sheet；"><a href="#导出多个文件至一个文件的多个sheet；" class="headerlink" title="导出多个文件至一个文件的多个sheet；"></a>导出多个文件至一个文件的多个sheet；</h3></li>
<li>方法1：<pre class="line-numbers language-none"><code class="language-none">from shutil import copyfile

template &#x3D; r&quot;test.xlsx&quot;
out_xl &#x3D; r&quot;out.xlsx&quot;
copyfile(template, out_xl)

with pd.ExcelWriter(out_xl,engine&#x3D;&#39;openpyxl&#39;,mode&#x3D;&#39;a&#39;,if_sheet_exists&#x3D;&#39;replace&#39;) as writer:
    #用openpyxl不会删除excel表中原有sheet，更保险！文件已存在需要替换掉就加if_sheet_exists&#x3D;&#39;replace&#39;，表名已存在的话就替换，不存在是新增的话，不要加这个参数，否则会报错
    df1.to_excel(writer,sheet_name&#x3D;&#39;表一&#39;,index&#x3D; False)
#writer.save()
#writer.close()</code></pre></li>
<li>方法2：这种方式不会报数据错误<pre class="line-numbers language-none"><code class="language-none">df &#x3D; pd.read_excel(path,sheet_name&#x3D;&#39;test3&#39;)
#写入到原Excel表中避免清空其他数据
book &#x3D; openpyxl.load_workbook(path)   #读取你要写入的workbook
#和pd.read_excel() 用于将Dataframe写入excel。xls用xlwt。xlsx用openpyxl
with pd.ExcelWriter(path,engine&#x3D;&#39;openpyxl&#39;) as writer:
    ##此时的writer里还只是读写器. 然后将上面读取的book复制给writer
    writer.book &#x3D; book
    #转化为字典的形式
    writer.sheets &#x3D; dict((ws.title, ws) for ws in book.worksheets)#返回一个字典，sheet名和sheet对象组成的键值对
    #将data写入writer，这里有时候需要对多个变量实现循环写入,可以使用for循环+eval()
    df.to_excel(writer,sheet_name&#x3D;&quot;测试&quot;,index&#x3D;False)
#writer.save()
#writer.close()</code></pre></li>
<li>to_json<pre class="line-numbers language-none"><code class="language-none">data &#x3D; df([[&#39;a&#39;, &#39;b&#39;], [&#39;c&#39;, &#39;d&#39;]], index&#x3D;[&#39;row 1&#39;, &#39;row 2&#39;], columns&#x3D;[&#39;col 1&#39;, &#39;col 2&#39;])
json_columns &#x3D; data.to_json(orient &#x3D; &quot;columns&quot;) # 返回结果：
 &#39;&#123;&quot;col 1&quot;:&#123;&quot;row 1&quot;:&quot;a&quot;,&quot;row 2&quot;:&quot;c&quot;&#125;,&quot;col 2&quot;:&#123;&quot;row 1&quot;:&quot;b&quot;,&quot;row 2&quot;:&quot;d&quot;&#125;&#125;&#39;
json_split &#x3D; data.to_json(orient &#x3D; &quot;split&quot;)  # 返回结果：
 &#39;&#123;&quot;columns&quot;:[&quot;col 1&quot;,&quot;col 2&quot;],&quot;index&quot;:[&quot;row 1&quot;,&quot;row 2&quot;],&quot;data&quot;:[[&quot;a&quot;,&quot;b&quot;],[&quot;c&quot;,&quot;d&quot;]]&#125;&#39;
json_records &#x3D; data.to_json(orient &#x3D; &quot;records&quot;)  # 返回结果：
 &#39;[&#123;&quot;col 1&quot;:&quot;a&quot;,&quot;col 2&quot;:&quot;b&quot;&#125;,&#123;&quot;col 1&quot;:&quot;c&quot;,&quot;col 2&quot;:&quot;d&quot;&#125;]&#39;
json_index &#x3D; data.to_json(orient &#x3D; &quot;index&quot;)  # 返回结果：
&#39;&#123;&quot;row 1&quot;:&#123;&quot;col 1&quot;:&quot;a&quot;,&quot;col 2&quot;:&quot;b&quot;&#125;,&quot;row 2&quot;:&#123;&quot;col 1&quot;:&quot;c&quot;,&quot;col 2&quot;:&quot;d&quot;&#125;&#125;&#39;
json_values &#x3D; data.to_json(orient &#x3D; &quot;values&quot;)  # 返回结果： 
&#39;[[&quot;a&quot;,&quot;b&quot;],[&quot;c&quot;,&quot;d&quot;]]&#39;</code></pre>
• format()函数，与lambda函数配合，可以设置：四舍五入保留小数位、转化为百分数、添加千位分隔符等<br>保留1位小数：df[“A”].map(lambda x: format(x, ‘.1f’))<br>设置百分数，并保留2位小数：df[“A”].map(lambda x: format(x, ‘.2%’))<br>设置千位分隔，并保留3位小数：df[“A”].map(lambda x: format(x, ‘,.3f’))</li>
</ul>

        </div>

        

        
            <div class="article-nav">
                
                    <div class="article-prev">
                        <a class="prev"
                           rel="prev"
                           href="/post/requests%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3.html"
                        >
                            <span class="left arrow-icon flex-center">
                              <i class="fas fa-chevron-left"></i>
                            </span>
                            <span class="title flex-center">
                                <span class="post-nav-title-item">python中requests使用中文乱码的解决方案</span>
                                <span class="post-nav-item">上一篇</span>
                            </span>
                        </a>
                    </div>
                
                
                    <div class="article-next">
                        <a class="next"
                           rel="next"
                           href="/post/python%E5%8A%9E%E5%85%AC%E8%87%AA%E5%8A%A8%E5%8C%96%EF%BC%9Apdf%E5%92%8Cword.html"
                        >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">python办公自动化：pdf和word</span>
                                <span class="post-nav-item">下一篇</span>
                            </span>
                            <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        

        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
              <span>2020</span>
              -
            
            2022&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">WenGe Zhang</a>
        </div>
        
            <script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                    <span id="busuanzi_container_site_uv">
                        访问人数&nbsp;<span id="busuanzi_value_site_uv"></span>&ensp;
                    </span>
                
                
                    <span id="busuanzi_container_site_pv">
                        总访问量&nbsp;<span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="theme-info info-item">
            由 <a target="_blank" href="https://hexo.io">Hexo</a> 驱动&nbsp;|&nbsp;主题&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.4.3</a>
        </div>
        
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item page-aside-toggle">
                <i class="fas fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-expand-width flex-center">
            <i class="fas fa-arrows-alt-h"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        

        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="arrow-up fas fa-arrow-up"></i>
                <span class="percent"></span>
            </li>
        
    </ul>
</div>

    </div>

    
        <aside class="page-aside">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E3%80%81Pandas%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">1.</span> <span class="nav-text">一、Pandas数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE"><span class="nav-number">2.</span> <span class="nav-text">二、读取数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E6%95%B0%E6%8D%AE%E9%A2%84%E5%A4%84%E7%90%86"><span class="nav-number">3.</span> <span class="nav-text">三、数据预处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9B%E3%80%81%E6%95%B0%E6%8D%AE%E9%80%89%E6%8B%A9"><span class="nav-number">4.</span> <span class="nav-text">四、数据选择</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%94%E3%80%81%E6%95%B0%E5%80%BC%E6%93%8D%E4%BD%9C"><span class="nav-number">5.</span> <span class="nav-text">五、数值操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%AD%E3%80%81%E6%95%B0%E6%8D%AE%E8%BF%90%E7%AE%97"><span class="nav-number">6.</span> <span class="nav-text">六、数据运算</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%83%E3%80%81%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97"><span class="nav-number">7.</span> <span class="nav-text">七、时间序列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%AB%E3%80%81%E6%95%B0%E6%8D%AE%E9%80%8F%E8%A7%86%E8%A1%A8"><span class="nav-number">8.</span> <span class="nav-text">八、数据透视表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B9%9D%E3%80%81%E5%A4%9A%E8%A1%A8%E6%A0%BC%E6%8B%BC%E6%8E%A5"><span class="nav-number">9.</span> <span class="nav-text">九、多表格拼接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%81%E3%80%81%E5%AF%BC%E5%87%BA%E6%96%87%E4%BB%B6"><span class="nav-number">10.</span> <span class="nav-text">十、导出文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%BC%E5%87%BA%E5%A4%9A%E4%B8%AA%E6%96%87%E4%BB%B6%E8%87%B3%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6%E7%9A%84%E5%A4%9A%E4%B8%AAsheet%EF%BC%9B"><span class="nav-number">11.</span> <span class="nav-text">导出多个文件至一个文件的多个sheet；</span></a></li></ol>
    </div>
</div>
        </aside>
    

    <div class="image-viewer-container">
    <img src="">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="搜索..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="popup-btn-close">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

</main>



<script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/utils.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/main.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/header-shrink.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/back2top.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/dark-light-toggle.js"></script>


    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/local-search.js"></script>



    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/code-copy.js"></script>



    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/lazyload.js"></script>


<div class="post-scripts pjax">
    
        <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/left-side-toggle.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/libs/anime.min.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/toc.js"></script>
    
</div>


    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/libs/pjax.min.js"></script>
<script>
    window.addEventListener('DOMContentLoaded', () => {
        window.pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax'
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
            // scrollTo: true,
        });

        document.addEventListener('pjax:send', () => {
            KEEP.utils.pjaxProgressBarStart();
        });

        document.addEventListener('pjax:complete', () => {
            KEEP.utils.pjaxProgressBarEnd();
            window.pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
            KEEP.refresh();
        });
    });
</script>



</body>
</html>
