<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Python数据分析 :pandas数据读取、预处理、筛选、计算，时间序列、透视、拼接、导出</title>
    <url>//post/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%EF%BC%9Apandas%E6%95%B0%E6%8D%AE%E8%AF%BB%E5%8F%96%E3%80%81%E9%A2%84%E5%A4%84%E7%90%86%E3%80%81%E7%AD%9B%E9%80%89%E3%80%81%E8%AE%A1%E7%AE%97%EF%BC%8C%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E3%80%81%E9%80%8F%E8%A7%86%E3%80%81%E6%8B%BC%E6%8E%A5%E3%80%81%E5%AF%BC%E5%87%BA.html</url>
    <content><![CDATA[<h3 id="一、Pandas数据结构"><a href="#一、Pandas数据结构" class="headerlink" title="一、Pandas数据结构"></a>一、Pandas数据结构</h3><pre class="line-numbers language-none"><code class="language-none">S1&#x3D;pd.Series([‘a’,’b’,’c’]) series是一组数据与一组索引（行索引）组成的数据结构
S1&#x3D;pd.Series([‘a’,’b’,’c’],index&#x3D;(1,3,4)) 指定索引
S1&#x3D;pd.Series(&#123;1:‘a’,2:’b’,3:’c’&#125;) 用字典形式指定索引
S1.index() 返回索引
S1.values() 返回值
Df&#x3D;pd.DataFrame([‘a’,’b’,’c’]) dataframe是一组数据与两组索引（行列索引）组成的数据结构
Df&#x3D;pd.DataFrame([[a,A],[b,B],[c,C]],columns&#x3D;[‘小写’,’大写’]，index&#x3D;[‘一’,’二’,’三’])
Columms 为列索引，index为行索引
pip install -i [https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple](https:&#x2F;&#x2F;link.zhihu.com&#x2F;?target&#x3D;https%3A&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple) pyspider 清华镜像</code></pre>
<ul>
<li>查找某个包 anaconda search -t conda tensorflow<br>下载某个包 anaconda show package<br>data={‘小写’:[‘a’,’b’,’c’],’大写’:[‘A’,’B’,’C’]} 传入字典<br>Df=Pd.DataFrame(data)<br>Df.index() df.columns()</li>
<li>建立分层索引的dataframe：pd.MultiIndex.from_arrays([[,,]],name=[,,]）</li>
</ul>
<h3 id="二、读取数据"><a href="#二、读取数据" class="headerlink" title="二、读取数据"></a>二、读取数据</h3><pre class="line-numbers language-none"><code class="language-none">df&#x3D;pd.read_excel(r’C:\user\...xlsx’,sheet_name&#x3D;’sheet1’) 或
pd.read_excel(r’C:\user\...xlsx’,sheet_name&#x3D;0) 读取excel表
pd.read_excel(r’C:\user\...xlsx’,index_col&#x3D;0,header&#x3D;0)
index_col指定行索引，header指定列索引
pd.read_excel(r’C:\user\...xlsx’,usecols&#x3D;[0,1]) 导入指定列,不能有index_col和header
pd.read_tablel(r’C:\user\...txt’，sep&#x3D;’ ’) 导入txt文件,sep指定分隔符是什么
df.head(2) 展示前两行，默认展示前5行
df.shape 显示数据几行几列，不包含行和列索引
df.info()可查看表中数据的类型
df.describe() 可获得表中数值类型指端的分布值（和、平均值、方差等）</code></pre>
<ul>
<li>获取Excel文件下所有的sheet名称<pre class="line-numbers language-none"><code class="language-none"># 读取所有Sheet
df &#x3D; pd.read_excel(&#39;456.xlsx&#39;, sheet_name&#x3D;None)
# 第一种
for i in df.keys():
    print(i)
# 第二种
df &#x3D; pd.read_excel(&#39;456.xlsx&#39;, sheet_name&#x3D;None)
print(list(df))</code></pre></li>
</ul>
<h3 id="三、数据预处理"><a href="#三、数据预处理" class="headerlink" title="三、数据预处理"></a>三、数据预处理</h3><ul>
<li><p>多个Series合并成DataFrame：pd.DataFrame(list(zip(series_1, series_2)))</p>
</li>
<li><p>python在字符串前面加0：str(1).zfill(2)</p>
<pre class="line-numbers language-none"><code class="language-none">df.info() 可显示表中哪个数据为空
df.isnull() 方法可以判断哪个值是缺失值，如果缺失返回True，否则为False
df.dropna() 默认删除含缺失值的行
df.dropna(how&#x3D;’all’) 删除全为空值的行，不全为空值的行不会删除
df.fillna(0) 用0填充所有空值
df.fillna(&#123;‘性别’:’男’,’年龄’:’30’&#125;) 对性别列中空值填充男，年龄填充30</code></pre></li>
<li><p>通过随机选择非缺失值来填充缺失值<br>foo[‘A’].apply(lambda x: np.random.choice(<br>[x for x in range(min(foo[‘A’]),max(foo[‘A’])]) if (np.isnan(x)) else x)</p>
</li>
<li><p>按一列数据填充另一列数据中的缺失值<br>df_real[‘净含量’] = df_real[‘净含量’].fillna(df_real[‘净含量_y’])</p>
</li>
<li><p>df1.combine_first(df2)：将df2的非缺失值填充df1中的缺失（dataframe根据列名和索引）值；<br>ser1.combine_first(ser2)：用ser2的非缺失值填充ser1中的缺失值（series根据索引）</p>
</li>
<li><p>按指定的字符合并多列：df[‘A’].str.cat([df[‘B’], df[‘C’]], sep=’-‘)</p>
<pre class="line-numbers language-none"><code class="language-none">df.drop_duplicates(inplace&#x3D;True) 默认对所有值进行重复值检查，保留第一行的值，inplace&#x3D;True表示直接在原来的DataFrame上删除重复项，而默认值False表示生成一个副本。
df.drop_duplicates(subset&#x3D;’性别’) 对性别列中重复值查询保留第一行
df.drop_duplicates(subset&#x3D;[’性别’,’公司’]，keep&#x3D;’last’) 对性别和公司两列查重
keep设置默认为first（保留第一个），可设置为last（保留最后一个） 或False(都不保留)
df[‘ID’].dtype 查看ID列的数据类型
df[‘ID’].astype(‘float’) 将ID列的数据类型转换为float类型
数据类型：int、float、object、string、unicode、datetime
df[‘ID’][1] ID列的第二个数据
df.columns&#x3D;[‘大写’,’小写’,’中文’] 为无索引表添加列索引
df.index&#x3D;[1,2,3] 添加行索引
df.set_index(‘编号’) 指明要用的列作为行索列
df.rename(index&#x3D;&#123;‘订单编号’:’新订单编号’,’客户姓名’:’新客户姓名’&#125;) 对行索引进行重新命名
df.rename(columns&#x3D;&#123;1:’一’,2:’二’&#125;) 对列索引进行一次性重新命名所有列名
如果你需要做的仅仅是将空格换成下划线，那么更好的办法是使用str.replace()方法，这是因为你都不需要输入所有的列名：
df.columns &#x3D; df.columns.str.replace(   ,  _ )
df.reset_index() 默认将全部index转化为column,
df.reset_index(level&#x3D;0) 将0级索引转化为column
df.reset_index(drop&#x3D;True) 删除原有索引</code></pre></li>
<li><p>多列合并为一行<br>df = pd.DataFrame({‘id_part’:[‘a’,’b’,’c’,’d’], ‘pred’:[0.1,0.2,0.3,0.4], ‘pred_class’:[‘women’,’man’,’cat’,’dog’], ‘v_id’:[‘d1’,’d2’,’d3’,’d1’]})<br>df.groupby([‘v_id’]).agg({‘pred_class’: [‘, ‘.join],’pred’: lambda x: list(x),’id_part’: ‘first’}).reset_index()</p>
</li>
<li><p>【某个字段按逗号分隔，并递增拆为多行】<br>df[“PackageNameCN”] = df[“PackageNameCN”].str.split(‘，’)<br>df = df.explode(“PackageNameCN”,ignore_index=True)</p>
</li>
<li><p>字符串转换为数值<br>df = pd.DataFrame({‘列1’:[‘1.1’,’2.2’,’3.3’],’列2’:[‘4.4’,’5.5’,’6.6’],’列3’:[‘7.7’,’8.8’,’-‘]})<br>df.astype({‘列1’:’float’,’列2’:’float’}).dtypes<br>用这种方式转换第三列会出错，因为这列里包含一个代表 0 的下划线，pandas 无法自动判断这个下划线。为了解决这个问题，可以使用 to_numeric() 函数来处理第三列，让 pandas 把任意无效输入转为 NaN。<br>df = df.apply(pd.to_numeric, errors=’coerce’).fillna(0)</p>
</li>
<li><p>优化 DataFrame 对内存的占用<br>方法一：只读取切实所需的列，使用usecols参数<br>cols = [‘beer_servings’,’continent’]<br>small_drinks = pd.read_csv(‘data/drinks.csv’, usecols=cols)<br>方法二：把包含类别型数据的 object 列转换为 Category 数据类型，通过指定 dtype 参数实现。<br>dtypes ={‘continent’:’category’}<br>smaller_drinks = pd.read_csv(‘data/drinks.csv’,usecols=cols, dtype=dtypes)</p>
</li>
<li><p>把字符串分割为多列<br>df = pd.DataFrame({‘姓名’:[‘张 三’,’李 四’,’王 五’],’所在地’:[‘北京-东城区’,’上海-黄浦区’,’广州-白云区’]})<br>df.姓名.str.split(‘ ‘, expand=True)</p>
</li>
<li><p>把 Series 里的列表转换为 DataFrame<br>df = pd.DataFrame({‘列1’:[‘a’,’b’,’c’],’列2’:[[10,20], [20,30], [30,40]]})<br>df_new = df.列2.apply(pd.Series)<br>pd.concat([df,df_new], axis=’columns’)</p>
</li>
<li><p>DataFrame迭代：<br>iterrows():将DataFrame迭代为(insex, Series)对。<br>iteritems():将DataFrame迭代为(列名, Series)对。<br>itertuples(): 将DataFrame迭代为元组。<br>for row in df.itertuples():<br>  print(row)<br>  print(‘—————-‘)<br>  print(getattr(row,’col1’), getattr(row,’col2’))<br>getattr() 函数用于返回一个对象属性值。</p>
</li>
</ul>
<h3 id="四、数据选择"><a href="#四、数据选择" class="headerlink" title="四、数据选择"></a>四、数据选择</h3><ul>
<li><p>Query是pandas的过滤查询函数，使用布尔表达式来查询DataFrame的列，就是说按照列的规则进行过滤操作。<br>pandas.DataFrame.query(self, expr, inplace = False, **kwargs)<br>expr：要评估的查询字符串；<br>inplace=False：查询是应该修改数据还是返回修改后的副本<br>kwargs：dict关键字参数<br>比如要查列<code>value_1</code>&lt;<code>value_2</code>的行记录：df.query(‘value_1 &lt; value_2’)<br>查询列<code>year</code>&gt;=2016的行记录：df.query(‘year &gt;= 2016 ‘)</p>
</li>
<li><p>Insert用于在DataFrame的指定位置中插入新的数据列。默认情况下新列是添加到末尾的，但可以更改位置参数，将新列添加到任何位置。<br>Dataframe.insert(loc, column, value, allow_duplicates=False)<br>loc: int型，表示插入位置在第几列；若在第一列插入数据，则 loc=0<br>column: 给插入的列取名，如 column=’新的一列’<br>value：新列的值，数字、array、series等都可以<br>allow_duplicates: 是否允许列名重复，选择Ture表示允许新的列名与已存在的列名重复<br>在第三列的位置插入新列：df.insert(2, ‘new_col’, new_col)</p>
</li>
<li><p>DataFrame首行插入行</p>
<pre class="line-numbers language-none"><code class="language-none">df.loc[-1] &#x3D; [10, 20, 30]  # 增加一行
df.index &#x3D; df.index + 1  # 把index的每一项增加1
df &#x3D; df.sort_index()  #重新排序一下</code></pre></li>
<li><p>Cumsum是pandas的累加函数，用来求列的累加值。 用法：<br>DataFrame.cumsum(axis=None, skipna=True, args, kwargs)<br>axis：index或者轴的名字<br>skipna：排除NA/null值<br>df中的group列有A、B、C三组，year列有多个年份。我们只知道当年度的值value_1、value_2，现在求group分组下的累计值，比如A、2014之前的累计值，可以用cumsum函数来实现。<br>当然仅用cumsum函数没办法对groups (A, B, C)进行区分，所以需要结合分组函数groupby分别对(A, B, C)进行值的累加。<br>df[‘cumsum_2’] = df[[‘value_2’,’group’]].groupby(‘group’).cumsum()</p>
</li>
<li><p>Sample用于从DataFrame中随机选取若干个行或列。 用法：<br>DataFrame.sample(n=None, frac=None, replace=False, weights=None, random_state=None, axis=None)<br>n：要抽取的行数<br>frac：抽取行的比例 例如frac=0.8，就是抽取其中80%<br>replace：是否为有放回抽样， True:有放回抽样 False:未放回抽样<br>weights：字符索引或概率数组<br>random_state ：随机数发生器种子<br>axis：选择抽取数据的行还是列 axis=0:抽取行 axis=1:抽取列<br>从df中随机抽取5行：df.sample(n=5)<br>从df随机抽取60%的行，并且设置随机数种子，每次能抽取到一样的样本：df.sample(frac=0.6,random_state=2)</p>
</li>
<li><p>Where用来根据条件替换行或列中的值。如果满足条件，保持原来的值，不满足条件则替换为其他值。默认替换为NaN，也可以指定特殊值。<br>DataFrame.where(cond, other=nan, inplace=False, axis=None, level=None, errors=’raise’, try_cast=False, raise_on_error=None)<br>cond：布尔条件，如果 cond 为真，保持原来的值，否则替换为other<br>other：替换的特殊值<br>inplace：inplace为真则在原数据上操作，为False则在原数据的copy上操作<br>axis：行或列<br>将df中列value_1里小于5的值替换为0：df[‘value_1’].where(df[‘value_1’] &gt; 5 , 0)</p>
</li>
<li><p>得到DataFrame中重复的数据</p>
<pre class="line-numbers language-none"><code class="language-none">data&#x3D;&#123;&#39;one&#39;:[1,1,2,2,1,2,2],&#39;two&#39;:[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;]&#125;
frame&#x3D;pd.DataFrame(data)
print(&quot;原始数据&quot;)
print(frame)
data1 &#x3D; frame.drop_duplicates(subset&#x3D;[&#39;two&#39;],keep&#x3D;&#39;first&#39;)
print(&quot;去重后的数据&quot;)
print(data1)
a &#x3D; frame.drop_duplicates(subset&#x3D;[&#39;two&#39;],keep&#x3D;&#39;last&#39;)
b &#x3D; frame.drop_duplicates(subset&#x3D;[&#39;two&#39;],keep&#x3D;False)
c&#x3D;a.append(b).drop_duplicates(subset&#x3D;[&#39;two&#39;],keep&#x3D;False)
print(&quot;重复的数据&quot;)
print(c)</code></pre></li>
<li><p>索引切片</p>
<pre class="line-numbers language-none"><code class="language-none">df[[‘ID’,’姓名’]] 多个列名要装入list
df.iloc[[1,3],[2,4]] 用行列编号选择数据
df.iloc[1,1] 选取表中的第3行2列数据，第一行默认为列索引
df.iloc[:,0:4] #获取第1列到第4列的值
df.loc[‘一’] #loc用行名选取的行数据，格式是Series，但可以用列表形式访问
df.loc[‘一’][0] 或 df.loc[‘一’][‘序号’]
df.iloc[1]#iloc用行编号选取行数据
df.iloc[[1,3]]#多行编号选取行数据，要用list封装，不然变成行列选取
df.iloc[1:3]#选择第二行和第四行
df[df[‘年龄’]&lt;45] #加判断条件返回符合条件的全部数据，不局限年龄列
df[(df[‘年龄’]&lt;45)&amp;(df[‘ID’]&lt;4)] #判断多条件选择数据
df.iloc[[1,3],[2,4]] 相当于df.loc[[‘一’,’二’],[‘年龄’,’ID’]] #loc是名，iloc是编号
df[df[‘年龄’]&lt;45][[‘年龄’,’ID’]]#先通过年龄条件选择行，再通过不同索引指定列
df.iloc[1:3,2:4]#切片索引</code></pre></li>
<li><p>pandas 筛选时间日期数据</p>
<p>这里筛选2020年5月的数据为例：<br>首先将日期格式化：</p>
<pre class="line-numbers language-none"><code class="language-none">data[&#39;日期&#39;]&#x3D;data[&quot;日期&quot;].values.astype(&#39;datetime64&#39;)  #如果已为日期格式则此步骤可省略
import datetime
s_date &#x3D; datetime.datetime.strptime(&#39;2020-04-30&#39;, &#39;%Y-%m-%d&#39;).date()  #起始日期
e_date &#x3D; datetime.datetime.strptime(&#39;2020-06-01&#39;, &#39;%Y-%m-%d&#39;).date()  #结束日期</code></pre>
<p>第一种方法，用逻辑运算符号’&gt;’ ‘&lt;’和’&amp;’：</p>
<p>Pandasdatetime64[ns]不能直接与datetime.date相比，需要用pd.Timestamp进行转化</p>
<pre class="line-numbers language-none"><code class="language-none">data[(data.日期&gt;pd.Timestamp(s_date))&amp;(data.日期&lt;pd.Timestamp(e_date))]</code></pre>
<p>第二种，用比较函数’gt’’lt’和’&amp;’:</p>
<pre class="line-numbers language-none"><code class="language-none">data[(data[&#39;日期&#39;].lt(pd.Timestamp(e_date)))&amp;(data[&#39;日期&#39;].gt(pd.Timestamp(s_date)))]</code></pre>
<p>第三种，用apply函数实现:</p>
<pre class="line-numbers language-none"><code class="language-none">id_a&#x3D;data.日期.apply(lambda x: x.year &#x3D;&#x3D;2020  and x.month&#x3D;&#x3D;5)
data[id_a]</code></pre>
<p>第四种，用between函数实现:</p>
<pre class="line-numbers language-none"><code class="language-none">id_b&#x3D;data.日期.between(pd.Timestamp(s_date),pd.Timestamp(e_date))
data[id_b]</code></pre></li>
<li><p>行序、列序反转 ：行序反转最直接的办法是使用loc函数并传递::-1，跟Python中列表反转时使用的切片符号一致<br>df.loc[::-1].reset_index(drop=True)<br>列序反转就比较容易了，只需要如下操作：df.loc[:, ::-1]</p>
</li>
<li><p>分组里最大值所在的行方法<br>分为分组中有重复值和无重复值两种。无重复值的情况。<br>df = pd.DataFrame({‘Sp’:[‘a’,’b’,’c’,’d’,’e’,’f’], ‘Mt’:[‘s1’, ‘s1’, ‘s2’,’s2’,’s2’,’s3’], ‘Value’:[1,2,3,4,5,6], ‘Count’:[3,2,5,10,10,6]})<br>df.iloc[df.groupby([‘Mt’]).apply(lambda x: x[‘Count’].idxmax())]<br>先按Mt列进行分组，然后对分组之后的数据框使用idxmax函数取出Count最大值所在的列，再用iloc位置索引将行取出。有重复值的情况<br>df[“rank”] = df.groupby(“ID”)[“score”].rank(method=”min”, ascending=False).astype(np.int64)<br>df[df[“rank”] == 1][[“ID”, “class”]]<br>对ID进行分组之后再对分数应用rank函数，分数相同的情况会赋予相同的排名，然后取出排名为1的数据。</p>
</li>
<li><p>选择特定类型的列<br>drinks = pd.read_csv(‘data/drinks.csv’)<br>选择所有数值型的列<br>drinks.select_dtypes(include=[‘number’]).head()<br>选择所有字符型的列<br>drinks.select_dtypes(include=[‘object’]).head()<br>drinks.select_dtypes(include=[‘number’,’object’,’category’,’datetime’]).head()<br>用 exclude 关键字排除指定的数据类型<br>drinks.select_dtypes(exclude=[‘number’]).head()</p>
</li>
<li><p>根据最大的类别筛选 DataFrame<br>movies = pd.read_csv(‘data/imdb_1000.csv’)<br>counts = movies.genre.value_counts()<br>movies[movies.genre.isin(counts.nlargest(3).index)].head()</p>
</li>
<li><p>基于字符串的长度来筛选数据<br>df[df.col1.str.len() &gt; 20].head()</p>
</li>
<li><p>标注重点<br>df_new.style.highlight_max(axis = 0, color = “yellow”)</p>
</li>
</ul>
<h3 id="五、数值操作"><a href="#五、数值操作" class="headerlink" title="五、数值操作"></a>五、数值操作</h3><pre class="line-numbers language-none"><code class="language-none">df[‘年龄’].replace(100,33)#对年龄列中的100替换成33
df.replace(np.NaN,0)#相当于fillna(),其中np.NaN是python中缺省值的表示方式
df.replace([A,B],C)#多对一替换，A、B替换成C
df.replace(&#123;‘A’:’a’,‘B’:’b’,‘C’:’c’&#125;)#多对多替换
df.sort_values(by&#x3D;[&#39;申请单编号&#39;],ascending&#x3D;False)#申请单编号列降序排列，Ture升序排列（默认）
df.sort_values(by&#x3D;[&#39;申请单编号&#39;],na_position&#x3D;’first’)#申请单编号列升序排列，缺失值排在第一位
默认缺失值在最后一位last
df &#x3D; pd.DataFrame([[&#39;A&#39;,1],[&#39;A&#39;,3],[&#39;A&#39;,2],[&#39;B&#39;,5],[&#39;B&#39;,9]], columns &#x3D; [&#39;name&#39;,&#39;score&#39;])
df.sort_values([&#39;name&#39;,&#39;score&#39;], ascending &#x3D; [True,False])#多列排序
df.groupby(&#39;name&#39;).apply(lambda x: x.sort_values(&#39;score&#39;,ascending&#x3D;False)).reset_index(drop&#x3D;True)</code></pre>
<ul>
<li>Pct_change是一个统计函数，用于表示当前元素与前面元素的相差百分比，两元素的区间可以调整。<br>比如说给定三个元素[2,3,6]，计算相差百分比后得到[NaN, 0.5, 1.0]，从第一个元素到第二个元素增加50％，从第二个元素到第三个元素增加100％。<br>DataFrame.pct_change(periods=1, fill_method=‘pad’, limit=None, freq=None, **kwargs)<br>periods：间隔区间，即步长<br>fill_method：处理空值的方法<br>对df的value_1列进行增长率的计算：df.value_1.pct_change()</li>
</ul>
<ul>
<li> pandas 进行组内排序、单组排序、标号<pre class="line-numbers language-none"><code class="language-none">df[‘销量’].rank(method&#x3D;’first’)#销量排名（不是排序），method有first\min\max\average
组内进行排序(按user_id分组后对product_id排序)
data1[&#39;group_sort&#39;]&#x3D;data1[&#39;product_id&#39;].groupby(data1[&#39;user_id&#39;]).rank(ascending&#x3D;1,method&#x3D;&#39;first&#39;)</code></pre></li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">df.drop([‘销量’,’ID’],axis&#x3D;1)#删除列,直接是列名,inpace&#x3D;True是保留修改哦
df.drop(df.columns[[4,5]],axis&#x3D;1)#删除列,是编号
df.drop(colums&#x3D;[‘销量’,’ID’])#此种方式删除列，可以不写axis&#x3D;1
df.drop([‘a’,’b’],axis&#x3D;0)#删除行,直接是列名
df.drop(df.index[[4,5]],axis&#x3D;0)#删除行,是编号
df.drop(index&#x3D;[‘a’,’b’])#此种方式删除行，可以不写axis&#x3D;0
df[‘ID’].value_counts()#对ID列中数据出现的次数进行统计
df[‘ID’].value_counts(normalize&#x3D;Ture,sort&#x3D;False)#对ID列中数据出现的次数占比进行统计，并降序排序
df[‘ID’].unique()#获取列的唯一值
df[‘年龄’].isin([‘a’,11])#查看这列中是否包含a或11
pd.cut(df[‘ID’],bins&#x3D;[0,3,6,10])#用bins指明切分区间
pd.qcut(df[‘ID’],3)#ID列切分成3个部分，每部分数据个数尽量一致
df.insert(2,’商品’,[‘书’,’笔’,’计算器’])#插入第三列
df[’商品’]&#x3D;[‘书’,’笔’,’计算器’])#插新列，在表的最后面
df.T行列互换
df.tack()#把表格型数据转化成树形数据
df.set_index([‘ID’,’姓名’]).stack().reset_index()#宽表转换成长表，先将共同列设置成行索引，再对其他列
进行转化成树形数据，再重置行索引</code></pre>
<ul>
<li><p>堆叠：pd.DataFrame.stack(self, level=-1, dropna=True)，level默认为-1是将最内层col堆叠为索引的最内层，为0是将最外层col堆叠为索引的最内层，从最外层开始依次的level值为0，1，2…的顺序来指定对应col。当然直接指定索引名称或许是更好的选择。</p>
</li>
<li><p>反堆叠、拆堆：pd.DataFrame.unstack(self, level=-1, fill_value=None)，默认将最内层的索引拆堆到列的最内层，其他同理stack()；</p>
</li>
<li><p>df.melt(id_vars=[‘ID’,’姓名’],var_name=’year’,value_name=’sale’)<br>id_var参数指明宽表转换成长表时保持不变的列，var_name参数表示原来的列索引转化为行索引对应的列名，value_name表示新索引对应值的列名<br>df[‘C1’].apply(lambda x:x+1)#相当于map(),只是需要和lambda配合<br>df.applymap(lambda x:x+1),对表中的所有数据执行相同函数运算</p>
</li>
<li><p>apply搭配匿名函数lambda的神奇用法：<br>df[‘数据3’] = df.apply(lambda x:(x.数据1-x.数据2)/x.上月 if x.col3!=0 else 0 ,axis=1)</p>
</li>
<li><p>删除包含特定字符串所在的<br>行：df[‘b’].values.astype(‘str’) 先转为字符串格式最好；<br>df[df[‘b’].str.contains(‘exp’,na=False)]</p>
</li>
<li><p>计算变量缺失率</p>
<pre class="line-numbers language-none"><code class="language-none">def missing_cal(df):
    &quot;&quot;&quot;
    df :数据集
    return：每个变量的缺失率
    &quot;&quot;&quot;
    missing_series &#x3D; df.isnull().sum()&#x2F;df.shape[0]
    missing_df &#x3D; pd.DataFrame(missing_series).reset_index()
    missing_df &#x3D; missing_df.rename(columns&#x3D;&#123;&#39;index&#39;:&#39;col&#39;,
    0:&#39;missing_pct&#39;&#125;)
    missing_df &#x3D; 	missing_df.sort_values(&#39;missing_pct&#39;,ascending&#x3D;False).reset_index(drop&#x3D;True)
    return missing_df
missing_cal(df)
如果需要计算样本的缺失率分布，只要加上参数axis&#x3D;1。</code></pre>
<h3 id="六、数据运算"><a href="#六、数据运算" class="headerlink" title="六、数据运算"></a>六、数据运算</h3><pre class="line-numbers language-none"><code class="language-none">df[‘ID’]+Df[‘ID’]#可进行加减乘除
df[‘ID’]&gt;Df[‘ID’]#可进行&gt; &lt; &#x3D;&#x3D; !&#x3D;等比较运算
df.nunique()#统计每列不重复值的个数
df.count()#统计每列的非空值的个数
df.count(axis&#x3D;1)#统计每行的非空值的个数
df[‘ID’].count()#统计指定列的非空值的个数
df.sum(axis&#x3D;1)#每列&#x2F;行求和结果
df.mean(axis&#x3D;1)#每列&#x2F;行求均值
df.max(axis&#x3D;1)#每列&#x2F;行求最大值
df.min(axis&#x3D;1)#每列&#x2F;行求最小值
df.median(axis&#x3D;1)#每列&#x2F;行求中间值
df.mode(axis&#x3D;1)#每列&#x2F;行中出现最多的值
df.var(axis&#x3D;1)#每列&#x2F;行求方差
df.std(axis&#x3D;1)#每列&#x2F;行求标准差
df.quantile(0.25)#求1&#x2F;4分位数，可以0.5、0.75等分位数
df.corr()#求整个DataFrame表中的相关性</code></pre>
<h3 id="七、时间序列"><a href="#七、时间序列" class="headerlink" title="七、时间序列"></a>七、时间序列</h3><pre class="line-numbers language-none"><code class="language-none">from datetime import datetime
datatime.now()#返回现在的时间年月日时分秒
datatime.now().year#返回年，可以.month\.day
datatime.now().weekday()-1#返回周几
datatime.now().isocalendar()#返回周数
（2018，41，7）#2018年的第41周第7天
datatime.now().date()#只返回年月日
datatime.now().time()#只返回时间
datatime.now().strftime(‘%Y-%m-%d %H:%M:%S’)#返回2020-03-13 09:09:12
pd.to_datetime([&#39;201221&#39;],format &#x3D; &quot;%Y%m%d&quot;)#返回DatetimeIndex([&#39;2012-02-01&#39;], dtype&#x3D;&#39;datetime64[ns]&#39;, freq&#x3D;None)
pd.to_datetime(&#39;201221&#39;,format &#x3D; &quot;%Y%m%d&quot;)#不加列表，返回Timestamp(&#39;2012-02-01 00:00:00&#39;)，需要省去时分秒可以在后面加.strftime(&quot;%Y-%m-%d&quot;)
from dateutil.parser import parse
parse(str_time)#将字符串的时间转化成为时间格式
pd.Datetimeindex([‘2020-02-03’,2020-03-05’])#设置时间索引
data[‘2018’]#获取2018年的数据
data[‘2018-01’]#获取2018年1月的数据
data[‘2018-01-05’:‘2018-01-15’]#获取这个时段的数据
非时间索引的表格处理
df[df[‘成交时间’]&#x3D;&#x3D;datetime(2018,08,05)]
df[df[‘成交时间’]&gt;datetime(2018,08,05)]
df[(df[‘成交时间’]&gt;datetime(2018,08,05))&amp;(df[‘成交时间’] &lt;datetime(2018,08,15))]
cha&#x3D;datatime(2018,5,21,19,50)-datatime(2018,5,18,17,50)
cha.days#返回天的时间差
cha.seconds#返回秒的时间差
cha.seconds&#x2F;3600#返回小时的时间差
datatime(2018,5,21,19,50)+timedelta(days&#x3D;1)#往后移一天
datatime(2018,5,21,19,50)+timedelta(seconds&#x3D;20)#往后移20秒
datatime(2018,5,21,19,50)-timedelta(days&#x3D;1)#往前移一天</code></pre>
<p>日期时间类型接口一览表</p>
<pre class="line-numbers language-none"><code class="language-none">df &#x3D; generate_sample_data_datetime().reset_index()
df &#x3D; df.sample(500)
df[&quot;Year&quot;] &#x3D; df[&quot;index&quot;].dt.year
df[&quot;Month&quot;] &#x3D; df[&quot;index&quot;].dt.month
df[&quot;Day&quot;] &#x3D; df[&quot;index&quot;].dt.day
df[&quot;Hour&quot;] &#x3D; df[&quot;index&quot;].dt.hour
df[&quot;Minute&quot;] &#x3D; df[&quot;index&quot;].dt.minute
df[&quot;Second&quot;] &#x3D; df[&quot;index&quot;].dt.second
df[&quot;Nanosecond&quot;] &#x3D; df[&quot;index&quot;].dt.nanosecond
df[&quot;Date&quot;] &#x3D; df[&quot;index&quot;].dt.date
df[&quot;Time&quot;] &#x3D; df[&quot;index&quot;].dt.time
df[&quot;Time_Time_Zone&quot;] &#x3D; df[&quot;index&quot;].dt.timetz
df[&quot;Day_Of_Year&quot;] &#x3D; df[&quot;index&quot;].dt.dayofyear
df[&quot;Week_Of_Year&quot;] &#x3D; df[&quot;index&quot;].dt.weekofyear
df[&quot;Week&quot;] &#x3D; df[&quot;index&quot;].dt.week
df[&quot;Day_Of_week&quot;] &#x3D; df[&quot;index&quot;].dt.dayofweek
df[&quot;Week_Day&quot;] &#x3D; df[&quot;index&quot;].dt.weekday
df[&quot;Week_Day_Name&quot;] &#x3D; df[&quot;index&quot;].dt.weekday_name
df[&quot;Quarter&quot;] &#x3D; df[&quot;index&quot;].dt.quarter
df[&quot;Days_In_Month&quot;] &#x3D; df[&quot;index&quot;].dt.days_in_month
df[&quot;Is_Month_Start&quot;] &#x3D; df[&quot;index&quot;].dt.is_month_start
df[&quot;Is_Month_End&quot;] &#x3D; df[&quot;index&quot;].dt.is_month_end
df[&quot;Is_Quarter_Start&quot;] &#x3D; df[&quot;index&quot;].dt.is_quarter_start
df[&quot;Is_Quarter_End&quot;] &#x3D; df[&quot;index&quot;].dt.is_quarter_end
df[&quot;Is_Leap_Year&quot;] &#x3D; df[&quot;index&quot;].dt.is_leap_year</code></pre>
<h3 id="八、数据透视表"><a href="#八、数据透视表" class="headerlink" title="八、数据透视表"></a>八、数据透视表</h3><pre class="line-numbers language-none"><code class="language-none">df.groupby(‘客户分类’).count()#客户分类后求数运算
df.groupby(‘客户分类’).sum()#客户分类后求和运算
df.groupby(‘客户分类’,’区域分类’).sum()#多列分类后求和运算
df.groupby(‘客户分类’,’区域分类’)[‘ID’].sum()#多列分类后ID求和运算
df[‘ID’]#DataFrame取出一列就是Series类型
df.groupby(df[‘ID’]).sum() 相当于 df.groupby(‘ID’).sum（）
df.groupby(‘客户分类’).aggregate([‘sum’,’count’]# aggregate可实现多种汇总方式
df.groupby(‘客户分类’).aggregate(&#123;‘ID’：‘count’,’销量’： ‘sum’&#125;)</code></pre></li>
<li><p>用多个函数聚合<br>df.groupby(‘order_id’).item_price.agg([‘sum’,’count’]).head()</p>
</li>
<li><p>aggregate可针对不同列做不同的汇总运算<br>df.groupby(‘客户分类’).sum().reset_index()#分组汇总后再重置索引，变为标准DataFrame<br>pd.pivot_table(data,values,index,columms,aggfunc,fill_value,margins,dropna,margins_name)<br>数据透视表，data:数据表df,values:值，index:行索引，columns:列索引，aggfunc:values的计算类型，fill_value:对空值的填充方式；margins:是否有合计列；margins_name:合计列的列名<br>pd.pivot_table(df,values=[’ID’,‘销量’],index=’客户分类’,columms=‘区域’,aggfunc={‘ID’：‘count’,’销量’：‘sum’}),fill_value=0,margins=Ture,dropna=None,margins_name=’总计’)</p>
</li>
<li><p>分组聚合 dict(list(df.groupby(‘key1’)))<br>通过字典或Series进行分组<br>people = pd.DataFrame(np.random.randn(5, 5),columns=[‘a’, ‘b’, ‘c’, ‘d’, ‘e’],index=[‘Joe’, ‘Steve’, ‘Wes’, ‘Jim’, ‘Travis’])<br>mapping = {‘a’:’red’, ‘b’:’red’, ‘c’:’blue’, ‘d’:’blue’, ‘e’:’red’, ‘f’:’orange’}<br>by_column = people.groupby(mapping, axis=1)<br>by_column.sum()</p>
</li>
</ul>
<h3 id="九、多表格拼接"><a href="#九、多表格拼接" class="headerlink" title="九、多表格拼接"></a>九、多表格拼接</h3><pre class="line-numbers language-none"><code class="language-none">pd.merge(df1,df2)#默认自动寻找两个表中的公共列进行拼接
pd.merge(df1,df2,on&#x3D;“学号“)#on来指定连接列，连接列要是公共列
pd.merge(df1,df2,on&#x3D;[‘学号’,’姓名’]#on来指定连接列，连接列要是公共列
pd.merge(df1,df2,left_on&#x3D;‘学号’right_on&#x3D;’编号’) #由公共列，但类名不同时用左右键指定 
pd.merge(df1,df2,left_index&#x3D;‘学号’right_index&#x3D;’编号’)#两表公共列都是索引列时
pd.merge(df1,df2,left_index&#x3D;‘学号’right_on&#x3D;’编号’)#公共列一个时索引列一个时普通列 
pd.merge(df1,df2,on&#x3D;’学号’,how&#x3D;’inner’)#返回公共列中对应的公共值拼接（内连接）
pd.merge(df1,df2,on&#x3D;’学号’,how&#x3D;’left’)#返回公共列中对应的左表值（左连接）
pd.merge(df1,df2,on&#x3D;’学号’,how&#x3D;’right’)#返回公共列中对应的右表值（右连接）
pd.merge(df1,df2,on&#x3D;’学号’,how&#x3D;’outer’)#返回公共列中对应的所有值（外连接）
pd.concat([df1,df2])#两个结构相同的表纵向连接，保留原索引值
pd.concat([df1,df2]，ignore_index&#x3D;True)#两个结构相同的表纵向连接，重新设置索引值
pd.concat([df1,df2]，ignore_index&#x3D;True).drop_duplicates()#拼接后去掉重复值</code></pre>

<h3 id="十、导出文件"><a href="#十、导出文件" class="headerlink" title="十、导出文件"></a>十、导出文件</h3><p>df.to_excel(excel_writer=r’C:\users\zhoulifu\Desktop\测试.xlsx’,sheet_name=’文档’，index=False,columns=[‘ID’,’销量’,‘姓名’],encoding=’utf-8’,na_rep=0)</p>
<ul>
<li>excel_writer参数指定文件路径，导出时去掉索引，设置导出的列，指定文件编码，na_rep缺失值填充<br>writer=pd.ExcelWriter(excelpath,engine=’xlsxwirter’)<h3 id="导出多个文件至一个文件的多个sheet；"><a href="#导出多个文件至一个文件的多个sheet；" class="headerlink" title="导出多个文件至一个文件的多个sheet；"></a>导出多个文件至一个文件的多个sheet；</h3></li>
<li>方法1：<pre class="line-numbers language-none"><code class="language-none">from shutil import copyfile

template &#x3D; r&quot;test.xlsx&quot;
out_xl &#x3D; r&quot;out.xlsx&quot;
copyfile(template, out_xl)

with pd.ExcelWriter(out_xl,engine&#x3D;&#39;openpyxl&#39;,mode&#x3D;&#39;a&#39;,if_sheet_exists&#x3D;&#39;replace&#39;) as writer:
    #用openpyxl不会删除excel表中原有sheet，更保险！文件已存在需要替换掉就加if_sheet_exists&#x3D;&#39;replace&#39;，表名已存在的话就替换，不存在是新增的话，不要加这个参数，否则会报错
    df1.to_excel(writer,sheet_name&#x3D;&#39;表一&#39;,index&#x3D; False)
#writer.save()
#writer.close()</code></pre></li>
<li>方法2：这种方式不会报数据错误<pre class="line-numbers language-none"><code class="language-none">df &#x3D; pd.read_excel(path,sheet_name&#x3D;&#39;test3&#39;)
#写入到原Excel表中避免清空其他数据
book &#x3D; openpyxl.load_workbook(path)   #读取你要写入的workbook
#和pd.read_excel() 用于将Dataframe写入excel。xls用xlwt。xlsx用openpyxl
with pd.ExcelWriter(path,engine&#x3D;&#39;openpyxl&#39;) as writer:
    ##此时的writer里还只是读写器. 然后将上面读取的book复制给writer
    writer.book &#x3D; book
    #转化为字典的形式
    writer.sheets &#x3D; dict((ws.title, ws) for ws in book.worksheets)#返回一个字典，sheet名和sheet对象组成的键值对
    #将data写入writer，这里有时候需要对多个变量实现循环写入,可以使用for循环+eval()
    df.to_excel(writer,sheet_name&#x3D;&quot;测试&quot;,index&#x3D;False)
#writer.save()
#writer.close()</code></pre></li>
<li>to_json<pre class="line-numbers language-none"><code class="language-none">data &#x3D; df([[&#39;a&#39;, &#39;b&#39;], [&#39;c&#39;, &#39;d&#39;]], index&#x3D;[&#39;row 1&#39;, &#39;row 2&#39;], columns&#x3D;[&#39;col 1&#39;, &#39;col 2&#39;])
json_columns &#x3D; data.to_json(orient &#x3D; &quot;columns&quot;) # 返回结果：
 &#39;&#123;&quot;col 1&quot;:&#123;&quot;row 1&quot;:&quot;a&quot;,&quot;row 2&quot;:&quot;c&quot;&#125;,&quot;col 2&quot;:&#123;&quot;row 1&quot;:&quot;b&quot;,&quot;row 2&quot;:&quot;d&quot;&#125;&#125;&#39;
json_split &#x3D; data.to_json(orient &#x3D; &quot;split&quot;)  # 返回结果：
 &#39;&#123;&quot;columns&quot;:[&quot;col 1&quot;,&quot;col 2&quot;],&quot;index&quot;:[&quot;row 1&quot;,&quot;row 2&quot;],&quot;data&quot;:[[&quot;a&quot;,&quot;b&quot;],[&quot;c&quot;,&quot;d&quot;]]&#125;&#39;
json_records &#x3D; data.to_json(orient &#x3D; &quot;records&quot;)  # 返回结果：
 &#39;[&#123;&quot;col 1&quot;:&quot;a&quot;,&quot;col 2&quot;:&quot;b&quot;&#125;,&#123;&quot;col 1&quot;:&quot;c&quot;,&quot;col 2&quot;:&quot;d&quot;&#125;]&#39;
json_index &#x3D; data.to_json(orient &#x3D; &quot;index&quot;)  # 返回结果：
&#39;&#123;&quot;row 1&quot;:&#123;&quot;col 1&quot;:&quot;a&quot;,&quot;col 2&quot;:&quot;b&quot;&#125;,&quot;row 2&quot;:&#123;&quot;col 1&quot;:&quot;c&quot;,&quot;col 2&quot;:&quot;d&quot;&#125;&#125;&#39;
json_values &#x3D; data.to_json(orient &#x3D; &quot;values&quot;)  # 返回结果： 
&#39;[[&quot;a&quot;,&quot;b&quot;],[&quot;c&quot;,&quot;d&quot;]]&#39;</code></pre>
• format()函数，与lambda函数配合，可以设置：四舍五入保留小数位、转化为百分数、添加千位分隔符等<br>保留1位小数：df[“A”].map(lambda x: format(x, ‘.1f’))<br>设置百分数，并保留2位小数：df[“A”].map(lambda x: format(x, ‘.2%’))<br>设置千位分隔，并保留3位小数：df[“A”].map(lambda x: format(x, ‘,.3f’))</li>
</ul>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql_tips</title>
    <url>//post/mysql-tips.html</url>
    <content><![CDATA[<ul>
<li><p>四个在工作后才知道的SQL密技</p>
<p><a href="https://zhuanlan.zhihu.com/p/412878736">https://zhuanlan.zhihu.com/p/412878736</a></p>
</li>
<li><p>mysql基础<br><a href="https://blog.csdn.net/weixin_45108087/article/details/102766281">https://blog.csdn.net/weixin_45108087/article/details/102766281</a></p>
</li>
<li><p>MYSQL中的COLLATE是什么？<br><a href="https://blog.csdn.net/weixin_34194317/article/details/92720517">https://blog.csdn.net/weixin_34194317/article/details/92720517</a></p>
</li>
<li><p>mysql中key 、primary key 、unique key 与index区别<br><a href="https://blog.csdn.net/nanaMasuda/article/details/52543177">https://blog.csdn.net/nanaMasuda/article/details/52543177</a></p>
</li>
<li><p>MySQL中REGEXP正则表达式<br><a href="https://blog.csdn.net/u011271894/article/details/79705869">https://blog.csdn.net/u011271894/article/details/79705869</a></p>
</li>
<li><p>mysql中distinct后面两个字段: 同时作用了两个字段，也就是必须得这两个字段都相同的才会被排除</p>
</li>
<li><p>MySql中把一个表的数据插入到另一个表中<br><a href="https://www.cnblogs.com/jiangxiaobo/p/7722691.html">https://www.cnblogs.com/jiangxiaobo/p/7722691.html</a></p>
</li>
<li><p>Mysql 根据一个表数据更新另外一个表<br><a href="https://www.cnblogs.com/wu628/p/4948833.html">https://www.cnblogs.com/wu628/p/4948833.html</a></p>
<pre class="line-numbers language-none"><code class="language-none">insert into table_2 (promotion_price,promotion) SELECT 字段1，字段2，...  FROM table_1 where table_1.id is not in (
select id from  table_2 );</code></pre></li>
<li><p>concat以及group_concat的用法<br><a href="https://baijiahao.baidu.com/s?id=1595349117525189591&amp;wfr=spider&amp;for=pc">https://baijiahao.baidu.com/s?id=1595349117525189591&amp;wfr=spider&amp;for=pc</a></p>
</li>
<li><p>字符串截取总结：left()、right()、substring()、substring_index()<br><a href="https://blog.csdn.net/wolinxuebin/article/details/7845917">https://blog.csdn.net/wolinxuebin/article/details/7845917</a></p>
</li>
<li><p>replace的用法<br><a href="https://www.cnblogs.com/to-creat/p/6516375.html">https://www.cnblogs.com/to-creat/p/6516375.html</a></p>
</li>
<li><p>mysql中join的用法<br><a href="https://www.cnblogs.com/beili/p/9140019.html">https://www.cnblogs.com/beili/p/9140019.html</a></p>
</li>
<li><p>MySQL计算日期的函数DATE_SUB(d,INTERVAL expr type)<br><a href="https://blog.csdn.net/sinat_34979528/article/details/54571316">https://blog.csdn.net/sinat_34979528/article/details/54571316</a></p>
</li>
<li><p>MySQL DATE_ADD() 函数<br><a href="https://www.w3school.com.cn/sql/func_date_add.asp">https://www.w3school.com.cn/sql/func_date_add.asp</a></p>
</li>
<li><p>sql中interval用法总结<br><a href="https://blog.csdn.net/weixin_42586373/article/details/107467914">https://blog.csdn.net/weixin_42586373/article/details/107467914</a></p>
</li>
<li><p>SQL中的cast()函数<br><a href="https://www.jianshu.com/p/e8ed290426b6">https://www.jianshu.com/p/e8ed290426b6</a></p>
</li>
<li><p>MySQL UNION 操作符<br><a href="https://www.runoob.com/mysql/mysql-union-operation.html">https://www.runoob.com/mysql/mysql-union-operation.html</a></p>
</li>
<li><p>ROW_NUMBER() OVER()函数用法详解 （分组排序 例子多）<br><a href="https://blog.csdn.net/qq_25221835/article/details/82762416">https://blog.csdn.net/qq_25221835/article/details/82762416</a></p>
</li>
<li><p>hive中regexp_extract的用法总结<br><a href="https://blog.csdn.net/jv_rookie/article/details/55211955">https://blog.csdn.net/jv_rookie/article/details/55211955</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>sql</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title>python关联分析（apriori算法）</title>
    <url>//post/python%E5%85%B3%E8%81%94%E5%88%86%E6%9E%90%EF%BC%88apriori%E7%AE%97%E6%B3%95%EF%BC%89.html</url>
    <content><![CDATA[<p>若两个或多个变量的取值之间存在某种规律性，就称为关联。关联规则是寻找在同一个事件中出现的不同项的相关性，比如在一次购买活动中所买不同商品的相关性。例如：“在购买计算机的顾客中，有30％的人也同时购买了打印机”。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhang18340082962/image-rick@master/image-rick/%E5%9B%BE%E7%89%87.60btv7guvhxc.png"></p>
<p>一个样本称为一个“事务”<br>每个事务由多个属性来确定，这里的属性称为“项”<br>多个项组成的集合称为“项集”<br>####由k个项构成的集合<br>{牛奶}、{啤酒}都是1-项集；<br>{牛奶，果冻}是2-项集；<br>{啤酒，面包，牛奶}是3-项集<br>####X==&gt;Y含义：<br>X和Y是项集<br>X称为规则前项（antecedent）<br>Y称为规则后项（consequent）<br>####支持度（support）：一个项集或者规则在所有事务中出现的频率，σ(X):表示项集X的支持度计数<br>项集X的支持度：s(X)=σ(X)/N<br>规则X==&gt;Y表示物品集X对物品集Y的支持度，也就是物品集X和物品集Y同时出现的概率<br>某天共有100个顾客到商场购买物品，其中有30个顾客同时购买了啤酒和尿布，那么上述的关联规则的支持度就是30％<br>####置信度（confidence）：确定Y在包含X的事务中出现的频繁程度。c(X → Y) = σ(X∪Y)/σ(X)<br>p（Y│X）＝p（XY）/p(X)。<br>置信度反应了关联规则的可信度—购买了项目集X中的商品的顾客同时也购买了Y中商品的可能性有多大<br>购买薯片的顾客中有50％的人购买了可乐,则置信度为50％</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhang18340082962/image-rick@master/image-rick/%E5%9B%BE%E7%89%87.4qn34mu3vvr4.png"></p>
<p>####(X , Y)==&gt;Z :<br>支持度:交易中包含{X 、 Y 、 Z}的可能性<br>置信度:包含{X 、 Y}的交易中也包含Z的条件概率<br>####设最小支持度为50%, 最小可信度为 50%, 则可得到 :<br>A==&gt;C (50%, 66.6%)<br>C==&gt;A (50%, 100%)</p>
<p>若关联规则X-&gt;Y的支持度和置信度分别大于或等于用户指定的最小支持率minsupport和最小置信度minconfidence，则称关联规则X-&gt;Y为强关联规则，否则称关联规则X-&gt;Y为弱关联规则。</p>
<p>####提升度（lift）：物品集A的出现对物品集B的出现概率发生了多大的变化<br>lift（A==&gt;B）=confidence（A==&gt;B）/support(B)=p(B|A)/p(B)<br>现在有** 1000 ** 个消费者，有** 500** 人购买了茶叶，其中有** 450人同时** 购买了咖啡，另** 50人** 没有。由于** confidence(茶叶=&gt;咖啡)=450/500=90%** ，由此可能会认为喜欢喝茶的人往往喜欢喝咖啡。但如果另外没有购买茶叶的** 500人** ，其中同样有** 450人** 购买了咖啡，同样是很高的** 置信度90%** ,由此，得到不爱喝茶的也爱喝咖啡。这样看来，其实是否购买咖啡，与有没有购买茶叶并没有关联，两者是相互独立的，其** 提升度90%/[(450+450)/1000]=1** 。<br>由此可见，lift正是弥补了confidence的这一缺陷，if lift=1,X与Y独立，X对Y出现的可能性没有提升作用，其值越大(lift&gt;1),则表明X对Y的提升程度越大，也表明关联性越强。<br>####Leverage 与 Conviction的作用和lift类似，都是值越大代表越关联<br>Leverage : P(A,B)-P(A)P(B)<br>Conviction:P(A)P(!B)/P(A,!B）<br>####所有指标的计算公式：<br><img src="https://cdn.jsdelivr.net/gh/zhang18340082962/image-rick@master/image-rick/%E5%9B%BE%E7%89%87.1iip63ea95vk.png"></p>
<p>接下来获取电影数据集中个电影类型之间的关联关系：<br>anaconda安装mlxtend包</p>
<pre class="line-numbers language-none"><code class="language-none">conda install -c conda-forge mlxtend</code></pre>
<pre class="line-numbers language-none"><code class="language-none">import pandas as pd
from mlxtend.frequent_patterns import apriori
from mlxtend.frequent_patterns import association_rules
movie_genres &#x3D; pd.DataFrame(data,columns&#x3D;[&#39;original_title&#39;,&#39;genres&#39;])
movies_ohe &#x3D; movie_genres.drop(&#39;genres&#39;,1).join(movie_genres.genres.str.get_dummies())
movies_ohe.shape#(10866, 21)
movies_ohe.set_index([&#39;original_title&#39;],inplace&#x3D;True)
frequent_itemsets_movies &#x3D; apriori(movies_ohe,use_colnames&#x3D;True, min_support&#x3D;0.025)
result &#x3D; [i for i in frequent_itemsets_movies.itemsets if len(i)&gt;1]
len(result)#37
rules_movies &#x3D;  association_rules(frequent_itemsets_movies, metric&#x3D;&#39;lift&#39;, min_threshold&#x3D;1.25)
rules_movies[(rules_movies.lift&gt;4)].sort_values(by&#x3D;[&#39;lift&#39;], ascending&#x3D;False)</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/zhang18340082962/image-rick@master/image-rick/%E5%9B%BE%E7%89%87.70uir8omojk0.png"></p>
<p>也挺符合常理哈。</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title>python-flask疫情数据可视化</title>
    <url>//post/python-flask%E7%96%AB%E6%83%85%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96.html</url>
    <content><![CDATA[<p>Flask是一个轻量级的web框架，看了<a href="https://www.bilibili.com/video/BV177411j7qJ">https://www.bilibili.com/video/BV177411j7qJ</a> 大佬的视频，做的一个疫情可视化项目,（电脑屏幕小看着有点拥挤。大屏展示还是挺好看的），热搜词云的数据找不到网站了，就弄了个表格；自己修改了一些部分，感兴趣的可以去康康视频，后续有时间再写点总结。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhang18340082962/image-rick@master/image-rick/%E5%9B%BE%E7%89%87.3zeoic47abi8.png"></p>
<h4 id="flask-前端部分"><a href="#flask-前端部分" class="headerlink" title="flask 前端部分"></a>flask 前端部分</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python">from flask import Flask,request,render_template,jsonify
import time
import utils
import pandas as pd
from yiqin_data import update_history,update_details
from selenium import webdriver
import threading
import webbrowser


app &#x3D; Flask(__name__)

@app.route(&#39;&#x2F;&#39;)
def index():
    task  &#x3D; pd.DataFrame(utils.get_r2_data(),columns &#x3D;[&#39;省份&#39;,&#39;现存&#39;,&#39;累计&#39;,&#39;相比上日&#39;,&#39;治愈占比&#39;,&#39;死亡占比&#39;])
    task[&#39;治愈占比&#39;] &#x3D; task[&#39;治愈占比&#39;].map(lambda x: format(x, &#39;.2%&#39;))
    task[&#39;死亡占比&#39;] &#x3D; task[&#39;死亡占比&#39;].map(lambda x: format(x, &#39;.2%&#39;))
    task &#x3D; task.to_html(index&#x3D;False,border&#x3D;0,max_cols&#x3D;8, max_rows&#x3D;7)
    return render_template(&quot;main.html&quot;, task&#x3D; task)

@app.route(&#39;&#x2F;time&#39;)
def gettime():
    time_str &#x3D; time.strftime(&quot;%Y&#123;&#125;%m&#123;&#125;%d&#123;&#125; %X&quot;)
    return time_str.format(&quot;年&quot;, &quot;月&quot;, &quot;日&quot;)

@app.route(&#39;&#x2F;c1&#39;, methods&#x3D;[&#39;get&#39;,&#39;post&#39;])
def get_c1_data():
    data &#x3D; utils.get_c1_data()
    return jsonify(&#123;&quot;cumulative&quot;: str(data[1]),&quot;current&quot;: str(data[2]), &quot;overseas&quot;: str(data[3]), &quot;death&quot;: str(data[4]),
                    &#39;新增确诊&#39;: str(data[5]), &#39;新增治愈&#39;: str(data[6]), &#39;新增境外&#39;: str(data[7]),&#39;新增死亡&#39;: str(data[8])&#125;)

@app.route(&quot;&#x2F;c2&quot;, methods&#x3D;[&#39;get&#39;,&#39;post&#39;])
def get_c2_data():
    res &#x3D; []
    for tup in utils.get_c2_data():
        res.append(&#123;&#39;name&#39;: tup[0],&#39;value&#39;: int(tup[1])&#125;)
    return jsonify(&#123;&#39;data&#39;: res&#125;)

@app.route(&quot;&#x2F;l1&quot;, methods&#x3D;[&#39;get&#39;,&#39;post&#39;])
def get_l1_data():
    data &#x3D; utils.get_l1_data()
    date, cumulative,current, overseas, death &#x3D; [], [], [], [], []
    for a, b, c, d, e in data[:]:
        date.append(pd.to_datetime(a,format &#x3D; &quot;%Y-%m-%d&quot;).strftime(&quot;%m-%d&quot;))
        cumulative.append(b)
        current.append(c)
        overseas.append(d)
        death.append(e)
    return jsonify(&#123;&quot;date&quot;: date[-100:], &quot;cumulative&quot;: cumulative[-100:], &quot;current&quot;: current[-100:],
                    &quot;overseas&quot;: overseas[-100:],&quot;death&quot;: death[-100:]&#125;)

@app.route(&quot;&#x2F;l2&quot;, methods&#x3D;[&#39;get&#39;,&#39;post&#39;])
def get_l2_data():
    data &#x3D; utils.get_l2_data()
    date, cumulative, current, overseas, death  &#x3D; [], [], [], [], []
    for a, b, c, d, e in data[:]:
        date.append(pd.to_datetime(a,format &#x3D; &quot;%Y-%m-%d&quot;).strftime(&quot;%m-%d&quot;))
        cumulative.append(b)
        current.append(c)
        overseas.append(d)
        death.append(e)
    return jsonify(&#123;&quot;date&quot;:date[-100:],&quot;cumulative&quot;:cumulative[-100:],&quot;current&quot;:current[-100:],
                    &quot;overseas&quot;:overseas[-100:],&quot;death&quot;:death[-100:]&#125;)

@app.route(&quot;&#x2F;r1&quot;, methods&#x3D;[&#39;get&#39;,&#39;post&#39;])
def get_r1_data():
    data &#x3D; utils.get_r1_data()
    city, confirm &#x3D; [], []
    for a, b in data:
        if a !&#x3D; &quot;地区待确认&quot; and  a !&#x3D;&quot;境外输入&quot;:
            city.append(a)
            confirm.append(int(b))
    return jsonify(&#123;&quot;city&quot;:city[0:5],&quot;confirm&quot;:confirm[0:5]&#125;)


# @app.route(&quot;&#x2F;r2&quot;, methods&#x3D;[&#39;get&#39;,&#39;post&#39;])
# def get_r2_data():
#     data &#x3D; utils.get_r2_data()
#     d &#x3D; []
#     for i in data:
#         k &#x3D; i[0].rstrip(string.digits) # 移除热搜数字,从右边
#         v &#x3D; i[0][len(k):] # 获取关键字
#         ks &#x3D; extract_tags(k) # 使用结巴提取关键字
#         for j in ks:
#             if not j.isdigit():
#                 d.append(&#123;&quot;name&quot;:j, &quot;value&quot;:v&#125;)
#
#     return jsonify(&#123;&quot;kws&quot;:d&#125;)

def start_web():
    try:
        browser &#x3D; webdriver.Chrome()
        browser.maximize_window()
        browser.get(f&#39;http:&#x2F;&#x2F;127.0.0.1:5000&#x2F;&#39;)
    except Exception as e:
        print(e)
        pass

def start_web2():
    webbrowser.open(&#39;http:&#x2F;&#x2F;127.0.0.1:5000&#x2F;&#39;)

def yiqing_run():
    # app.run(host&#x3D;&#39;0.0.0.0&#39;,port&#x3D;8638)    #debug&#x3D;True,host&#x3D;&#39;0.0.0.0&#39;,port&#x3D;
    app.run()

if __name__&#x3D;&#x3D;&quot;__main__&quot;:
    update_history()
    update_details()
    try:
        t1 &#x3D; threading.Thread(target&#x3D;yiqing_run, )
        t2 &#x3D; threading.Thread(target&#x3D;start_web2, )
        t1.start()
        time.sleep(1)
        t2.start()
    except Exception as e:
        print(e)
</code></pre>

<h4 id="mysql-后台数据部分"><a href="#mysql-后台数据部分" class="headerlink" title="mysql 后台数据部分"></a>mysql 后台数据部分</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python">import time
import pymysql
import string


# 连接数据库
def get_conn():
    conn &#x3D; pymysql.connect(
        host&#x3D;&quot;localhost&quot;,
        user&#x3D;&quot;&quot;,
        password&#x3D;&quot;&quot;,
        db&#x3D;&quot;supermanzwg&quot;,
        charset&#x3D;&quot;utf8&quot;,
        port&#x3D;3306,
    )
    # 创建游标：
    cursor &#x3D; conn.cursor()
    return conn, cursor

def close_conn(conn, cursor):
    if cursor:
        cursor.close()
    if conn:
        conn.close()

def query(sql, *args):
    &#39;&#39;&#39;
    :param sql:
    :param args:
    :return:返回结果，((),())形式
    &#39;&#39;&#39;
    conn, cursor&#x3D; get_conn()
    cursor.execute(sql)
    res &#x3D; cursor.fetchall() # 获取结果
    close_conn(conn, cursor)
    return res

def get_c1_data():
    sql &#x3D; &quot;&quot;&quot;
        select a.date,a.cumulative,a.current,a.Overseas,a.death,b.&#96;新增确诊&#96;,b.&#96;新增治愈&#96;,b.&#96;新增境外&#96;,b.&#96;新增死亡&#96; 
        from 
        (select date,cumulative,current,Overseas,death 
        from  &#96;history&#96; 
        order by date desc limit 1) a 
        inner join 
        (SELECT b.date 日期,(b.cumulative-a.cumulative) 新增确诊,
            -(a.cumulative-a.current-b.cumulative+b.current) 新增治愈,
            (b.Overseas-a.Overseas) 新增境外,
            (b.death-a.death) 新增死亡 
            FROM &#96;history&#96; a, &#96;history&#96; b 
            where a.date &#x3D; DATE_SUB(str_to_date(b.date,&#39;%Y-%m-%d&#39;),interval 1 day)
            order by 日期 desc limit 1) b
        where a.date &#x3D; b.&#96;日期&#96;; &quot;&quot;&quot;
    res &#x3D; query(sql)
    return res[0]

def get_c2_data():
    sql &#x3D; &quot;&quot;&quot;
    select 
    province,current
    from &#96;details&#96; 
    order by date  desc limit 34;&quot;&quot;&quot;
    res &#x3D; query(sql)
    return res

def get_l1_data():
    sql &#x3D; &quot;&quot;&quot;
    select *
    from 
    (select date,cumulative,current,Overseas,death 
        from  &#96;history&#96; 
        order by date desc limit 10) a
		order by a.date asc;&quot;&quot;&quot;
    res &#x3D; query(sql)
    return res

def get_l2_data():
    sql &#x3D; &quot;&quot;&quot;
    select *
    from 
    (SELECT b.date &#96;日期&#96;,(b.cumulative-a.cumulative) 新增确诊,
        -(a.cumulative-a.current-b.cumulative+b.current) 新增治愈,
        (b.Overseas-a.Overseas) 新增境外,
        (b.death-a.death) 新增死亡 
        FROM &#96;history&#96; a, &#96;history&#96; b 
        where a.date &#x3D; DATE_SUB(str_to_date(b.date,&#39;%Y-%m-%d&#39;),interval 1 day)
        group by b.date  order by b.date desc limit 10) c
		order by c.&#96;日期&#96; asc&quot;&quot;&quot;
    res &#x3D; query(sql)
    return res

def get_r1_data():
    # union_all 两块相加
    sql &#x3D;&quot;&quot;&quot;select 
    province,current 
    from  &#96;details&#96;
    where date &#x3D; (select max(date) max_date
    from &#96;details&#96;) 
    order by date,current  desc limit 5; &quot;&quot;&quot;
    res &#x3D; query(sql)
    return res

# 词云图没有
def get_r2_data():
    sql &#x3D; &quot;&quot;&quot;SELECT 
	province as &#96;省份&#96;,current as &#96;现存确诊&#96;,cumulative as &#96;累计确诊&#96;,
	by_yesterday as  &#96;相比上日&#96; ,round(heal&#x2F;cumulative,4) as &#96;治愈占比&#96;,round(death&#x2F;cumulative,4) as &#96;死亡占比&#96; 
    FROM &#96;details&#96;
    where date  &#x3D;(select max(date) from &#96;details&#96;) 
    order by current desc limit 7;&quot;&quot;&quot;
    res &#x3D; query(sql)
    return res
if __name__&#x3D;&#x3D;&#39;__main__&#39;:
    print(get_l2_data())
    pass</code></pre>

<h4 id="selenium数据抓取部分"><a href="#selenium数据抓取部分" class="headerlink" title="selenium数据抓取部分"></a>selenium数据抓取部分</h4><pre class="line-numbers language-none"><code class="language-none">https:&#x2F;&#x2F;python-selenium-zh.readthedocs.io&#x2F;zh_CN&#x2F;latest&#x2F;</code></pre>



<p>关于flask：<br><a href="https://www.cnblogs.com/songboriceboy/category/1867414.html">https://www.cnblogs.com/songboriceboy/category/1867414.html</a><br><a href="https://blog.csdn.net/u014793102/category_9285123.html?spm=1001.2014.3001.5482">https://blog.csdn.net/u014793102/category_9285123.html?spm=1001.2014.3001.5482</a></p>
<p>关于selenium：</p>
<p><a href="https://python-selenium-zh.readthedocs.io/zh_CN/latest/">https://python-selenium-zh.readthedocs.io/zh_CN/latest/</a></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title>python-学生信息管理系统（学的是思维）</title>
    <url>//post/python-%E5%AD%A6%E7%94%9F%E4%BF%A1%E6%81%AF%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%AD%A6%E7%9A%84%E6%98%AF%E6%80%9D%E7%BB%B4%EF%BC%89.html</url>
    <content><![CDATA[<h1 id="学生管理系统应具备的功能"><a href="#学生管理系统应具备的功能" class="headerlink" title="学生管理系统应具备的功能"></a>学生管理系统应具备的功能</h1><ul>
<li>添加学生及成绩信息</li>
<li>将学生信息保存到文件中</li>
<li>修改和删除学生信息</li>
<li>查询学生信息</li>
<li>根据学生成绩进行排序</li>
<li>统计学生的总分</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/zhang18340082962/image-rick@master/image-rick/image-20211219123240293.1zbrdjhj57ts.png"></p>
<h1 id="主程序"><a href="#主程序" class="headerlink" title="主程序"></a>主程序</h1><pre class="line-numbers language-none"><code class="language-none">import os
filename &#x3D; &#39;student.txt&#39;
def main():
    while True:
        menum()
        choice &#x3D; int(input(&quot;请选择:&quot;))
        if choice in [0,1,2,3,4,5,6,7]:
            if choice&#x3D;&#x3D;0:
                answer &#x3D; input(&quot;您确定要退出系统吗?y&#x2F;n&quot;)
                if answer &#x3D;&#x3D; &#39;y&#39; or answer &#x3D;&#x3D; &#39;Y&#39;:
                    print(&quot;谢谢您的使用！&quot;)
                    break #退出系统
                else:
                    continue
            elif choice&#x3D;&#x3D;1:
                insert()
            elif choice&#x3D;&#x3D;2:
                search()
            elif choice&#x3D;&#x3D;3:
                delete()
            elif choice&#x3D;&#x3D;4:
                modify()
            elif choice &#x3D;&#x3D;5:
                sort()
            elif choice &#x3D;&#x3D;6:
                total()
            elif choice&#x3D;&#x3D;7:
                show()
def menum():
    print(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;学生信息管理系统&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;)
    print(&quot;----------------------------------功能菜单-----------------------------------&quot;)
    print(&quot;\t\t\t\t\t\t1.录入学生信息&quot;)
    print(&quot;\t\t\t\t\t\t2.查找学生信息&quot;)
    print(&quot;\t\t\t\t\t\t3.删除学生信息&quot;)
    print(&quot;\t\t\t\t\t\t4.修改学生信息&quot;)
    print(&quot;\t\t\t\t\t\t5.排序&quot;)
    print(&quot;\t\t\t\t\t\t6.统计学生总人数&quot;)
    print(&quot;\t\t\t\t\t\t7.显示所有学生信息&quot;)
    print(&quot;\t\t\t\t\t\t0.退出&quot;)
    print(&quot;----------------------------------------------------------------------------&quot;)</code></pre>
<h1 id="保存数据"><a href="#保存数据" class="headerlink" title="保存数据"></a>保存数据</h1><pre class="line-numbers language-none"><code class="language-none">def save(lst):
    try:
        stu_txt &#x3D; open(filename,&#39;a&#39;,encoding&#x3D;&#39;utf-8&#39;)#以追加的模式进行打开
    except:
        stu_txt &#x3D; open(filename,&#39;w&#39;,encoding &#x3D; &#39;utf-8&#39;)
    for item in lst:
        stu_txt.write(str(item)+&#39;\n&#39;)
    stu_txt.close()</code></pre>
<h1 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h1><pre class="line-numbers language-none"><code class="language-none">
def insert():
    student_list &#x3D; []
    while True:
        id &#x3D; input(&#39;请输入ID(如1001):&#39;)
        if not id:
            break
        name &#x3D; input(&quot;请输入姓名:&quot;)
        if not name:
            break
        try:
            english_score &#x3D; int(input(&quot;请输入英语成绩:&quot;))
            python_score&#x3D; int(input(&quot;请输入Python成绩:&quot;))
            java_score &#x3D; int(input(&quot;请输入Java成绩:&quot;))
        except:
            print(&quot;输入无效，不是整数类型，请重新输入...&quot;)
            continue
        #将录入的学生信息保存到字典中
        student &#x3D; &#123;&#39;id&#39;:id,&#39;name&#39;:name,&#39;english&#39;:english_score,&#39;python&#39;:python_score,&#39;java&#39;:java_score&#125;
        #将学生信息添加到列表中
        student_list.append(student)
        answer &#x3D; input(&quot;是否将继续添加？y&#x2F;n\n&quot;)
        if answer&#x3D;&#x3D;&#39;y&#39;:
            continue
        else:
            break
    #调用save()函数
    save(student_list)
    print(&quot;学生信息录入完毕！！！&quot;)</code></pre>
<h1 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h1><pre class="line-numbers language-none"><code class="language-none">def search():
    student_query &#x3D; []
    while True:
        id &#x3D; &#39;&#39;
        name &#x3D; &#39;&#39;
        if os.path.exists(filename):
            mode &#x3D; input(&quot;按ID查找请输入1，按姓名查找请输入2&quot;)
            if mode &#x3D;&#x3D;&#39;1&#39;:
                id &#x3D; input(&quot;请输入学生ID&quot;)
            elif mode &#x3D;&#x3D;&#39;2&#39;:
                name &#x3D; input(&quot;请输入学生姓名&quot;)
            else:
                print(&quot;您的输入有误，请重新输入&quot;)
                search()
            with open(filename,&#39;r&#39;,encoding&#x3D;&#39;utf-8&#39;) as rfile:
                student &#x3D; rfile.readlines()
                for item in student:
                    d &#x3D; dict(eval(item))
                    if id!&#x3D;&#39;&#39;:
                        if d[&#39;id&#39;] &#x3D;&#x3D; id:
                            student_query.append(d)
                    if name!&#x3D;&#39;&#39;:
                        if d[&#39;name&#39;] &#x3D;&#x3D;name:
                            student_query.append(d)
            #显示查询结果
            show_student(student_query)
            #清空列表
            student_query.clear()
            answer &#x3D; input(&quot;是否继续查询y&#x2F;n\n&quot;)
            if answer&#x3D;&#x3D;&#39;y&#39; or answer&#x3D;&#x3D;&#39;Y&#39;:
                continue
            else:
                break
        else:
            print(&quot;暂未保存学生信息&quot;)
            return

def show_student(lst):
    if len(lst) &#x3D;&#x3D;0:
        print(&quot;没有查询到学生信息，无数据显示！！！&quot;)
        return
    #定义标题显示格式
    format_title &#x3D; &#39;&#123;:^6&#125;\t&#123;:^12&#125;\t&#123;:^8&#125;\t&#123;:^10&#125;\t&#123;:^10&#125;\t&#123;:^8&#125;&#39;
    print(format_title.format(&#39;ID&#39;,&#39;姓名&#39;,&#39;英语成绩&#39;,&#39;Python成绩&#39;,&#39;Java成绩&#39;,&#39;总成绩&#39;))
    #定义内容显示格式
    format_data &#x3D; &#39;&#123;:^6&#125;\t&#123;:^12&#125;\t&#123;:^8&#125;\t&#123;:^10&#125;\t&#123;:^10&#125;\t&#123;:^8&#125;&#39;
    for item in lst:
        print(format_data.format(item.get(&#39;id&#39;),
                                item.get(&#39;name&#39;),
                                  item.get(&#39;english&#39;),
                                  item.get(&#39;python&#39;),
                                  item.get(&#39;java&#39;),
                                 int(item.get(&#39;english&#39;))+int(item.get(&#39;python&#39;))+int(item.get(&#39;java&#39;))
                                 ))</code></pre>
<h1 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h1><pre class="line-numbers language-none"><code class="language-none">def delete():
    while True:
        student_id &#x3D; input(&quot;请输入要删除的学生的ID：&quot;)
        if student_id !&#x3D;&#39;&#39;:
            if os.path.exists(filename):
                with open(filename,&#39;r&#39;,encoding&#x3D;&#39;utf-8&#39;) as file:
                    student_old &#x3D; file.readlines()#逐行读取，按行生成一个列表
            else:
                student_old &#x3D;[]
            flag &#x3D; False#标记是否删除
            if student_old:#判断原有文件内容是否为空，如果有内容就打开并写入东西
                with open(filename,&#39;w&#39;,encoding&#x3D;&#39;utf-8&#39;) as wfile:
                    d&#x3D;&#123;&#125;
                    for item in student_old:
                        d &#x3D; dict(eval(item))#将字符串转换为字典
                        if d[&#39;id&#39;]!&#x3D;student_id:
                            wfile.write(str(d)+&quot;\n&quot;)
                        else:
                            flag&#x3D;True#定义这个标志，同时也没有将变量进行写入，即为删除
                    if flag:
                        print(f&quot;id为&#123;student_id&#125;的学生信息已经被删除。&quot;)
                    else:
                        print(f&quot;没有找到ID为&#123;student_id&#125;的学生信息。&quot;)
            else:
                print(&quot;无学生信息。&quot;)
                break
            show()#删完之后要重新显示学生信息
            answer &#x3D; input(&quot;是否继续删除？y&#x2F;n\n&quot;)
            if answer&#x3D;&#x3D;&#39;y&#39; or answer &#x3D;&#x3D; &quot;Y&quot;:
                continue
            else:
                break</code></pre>
<h1 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h1><pre class="line-numbers language-none"><code class="language-none">def modify():
    show()
    if os.path.exists(filename):
        with open(filename,&#39;r&#39;,encoding&#x3D;&#39;utf-8&#39;) as rfile:
            student_old &#x3D; rfile.readlines()
    else:
        return
    student_id &#x3D; input(&quot;请输入要修改的学员的ID：&quot;)
    with open(filename,&#39;w&#39;,encoding&#x3D;&#39;utf-8&#39;) as wfile:
        for item in student_old:
            d &#x3D; dict(eval(item))
            if d[&#39;id&#39;]&#x3D;&#x3D;student_id:#找到要修改的相关id
                print(&quot;找到学生信息，可以修改他的相关信息了！&quot;)
                while True:
                    try:
                        d[&#39;name&#39;]&#x3D;input(&quot;请输入姓名：&quot;)
                        d[&#39;english&#39;] &#x3D;input(&quot;请输入英语成绩：&quot;)
                        d[&#39;python&#39;] &#x3D; input(&quot;请输入Python成绩：&quot;)
                        d[&#39;Java&#39;] &#x3D; input(&quot;请输入Java成绩：&quot;)
                    except:
                        print(&quot;您的输入有误，请重新输入！！！&quot;)
                    wfile.write(str(d)+&quot;\n&quot;)
                    print(&quot;修改成功&quot;)

            else:
                wfile.write(str(d)+&quot;\n&quot;)
        answer &#x3D; input(&quot;是否继续修改其他学校信息？y&#x2F;n\n&quot;)
        if answer&#x3D;&#x3D;&#39;y&#39; or answer &#x3D;&#x3D;&#39;Y&#39;:
            modify()</code></pre>
<h1 id="数据排序"><a href="#数据排序" class="headerlink" title="数据排序"></a>数据排序</h1><pre class="line-numbers language-none"><code class="language-none">def sort():
    if os.path.exists(filename):
        with open(filename, &#39;r&#39;, encoding&#x3D;&#39;utf-8&#39;) as rfile:
            student &#x3D; rfile.readlines()
        student_new &#x3D; []
        for item in student:
            d &#x3D; dict(eval(item))
            student_new.append(d)
    else:
        return
    asc_or_desc &#x3D; input(&quot;请选择(0.升序 1.降序)&quot;)
    if asc_or_desc&#x3D;&#x3D;&#39;0&#39;:
        asc_or_desc_bool &#x3D; False
        pass
    elif asc_or_desc&#x3D;&#x3D;&#39;1&#39;:
        asc_or_desc_bool &#x3D; True
        pass
    else:
        print(&quot;您的输入有误，请重新输入！&quot;)
        sort()
    mode &#x3D; input(&quot;请选择排序方式(1.按英语成绩排序 2.按Python成绩排序 3.按Java程序排序 0.按总成绩排序)&quot;)
    if mode&#x3D;&#x3D;&#39;1&#39;:
        student_new.sort(key&#x3D;lambda x:x[&#39;english&#39;],reverse&#x3D;asc_or_desc_bool)
    elif mode&#x3D;&#x3D;&#39;2&#39;:
        student_new.sort(key&#x3D;lambda x:x[&#39;python&#39;],reverse&#x3D;asc_or_desc_bool)
    elif mode&#x3D;&#x3D;3:
        student_new.sort(key&#x3D;lambda x:x[&#39;java&#39;],reverse&#x3D;asc_or_desc_bool)
    elif mode&#x3D;&#x3D;&#39;0&#39;:
        student_new.sort(key&#x3D;lambda x:x[&#39;english&#39;]+x[&#39;python&#39;]+x[&#39;java&#39;],reverse&#x3D;asc_or_desc_bool)
    else:
        print(&quot;你的输入有误，请重新输入&quot;)
        sort()
    show_student(student_new)</code></pre>
<h1 id="显示数据"><a href="#显示数据" class="headerlink" title="显示数据"></a>显示数据</h1><pre class="line-numbers language-none"><code class="language-none">def total():
    if os.path.exists(filename):
        with open(filename,&#39;r&#39;,encoding&#x3D;&#39;utf-8&#39;) as rfile:
            students &#x3D; rfile.readlines()
            if students:
                print(f&quot;一共有&#123;len(students)&#125;名学生&quot;)
            else:
                print(&quot;还没有录入学生信息&quot;)
    else:
        print(&quot;暂未存学生相关信息&quot;)
def show():
    student_ls &#x3D; []
    if os.path.exists(filename):
        with open(filename,&#39;r&#39;,encoding&#x3D;&#39;utf-8&#39;) as rfile:
            students &#x3D; rfile.readlines()
            for item in students:
                student_ls.append(eval(item))
            if student_ls:
                show_student(student_ls)
            else:
                print(&quot;还没有保存学生信息&quot;)
    else:
        print(&quot;没有发现相应数据文件&quot;)


if __name__ &#x3D;&#x3D;&#39;__main__&#39;:
    main()</code></pre>
<h1 id="写在结尾"><a href="#写在结尾" class="headerlink" title="写在结尾"></a>写在结尾</h1><ul>
<li>打包成exe需要在终端激活环境后运行 pip install PyIntaller<br>下载好之后再执行 pyinstaller -F D:\Studentsys\stusystem.py  </li>
</ul>
<p>-F后面是完整路径以及文件名<br><a href="https://www.bilibili.com/video/BV1wD4y1o7AS?p=135&amp;spm_id_from=pageDriver">https://www.bilibili.com/video/BV1wD4y1o7AS?p=135&amp;spm_id_from=pageDriver</a><br>娟姐yyds! </p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title>python办公自动化：pdf和word</title>
    <url>//post/python%E5%8A%9E%E5%85%AC%E8%87%AA%E5%8A%A8%E5%8C%96%EF%BC%9Apdf%E5%92%8Cword.html</url>
    <content><![CDATA[<h2 id="python-使用-PyPDF2-和-pdfplumber-操作pdf"><a href="#python-使用-PyPDF2-和-pdfplumber-操作pdf" class="headerlink" title="python 使用 PyPDF2 和 pdfplumber 操作pdf"></a>python 使用 PyPDF2 和 pdfplumber 操作pdf</h2><ul>
<li>PyPDF2 官网：<a href="https://pythonhosted.org/PyPDF2/">https://pythonhosted.org/PyPDF2/</a></li>
<li>PyPDF2 可以更好的读取、写入、分割、合并 PDF 文件；</li>
<li>pdfplumber 官网：<a href="https://github.com/jsvine/pdfplumber">https://github.com/jsvine/pdfplumber</a></li>
<li>pdfplumber 可以更好地读取 PDF 文件内容和提取 PDF 中的表格；</li>
<li>查找某个包 anaconda search -t conda pdfplumber<br>下载某个包 anaconda show package</li>
</ul>
<h2 id="python-提取-PDF-文字内容"><a href="#python-提取-PDF-文字内容" class="headerlink" title="python 提取 PDF 文字内容"></a>python 提取 PDF 文字内容</h2><h3 id="1）利用-pdfplumber-提取文字"><a href="#1）利用-pdfplumber-提取文字" class="headerlink" title="1）利用 pdfplumber 提取文字"></a>1）利用 pdfplumber 提取文字</h3><pre class="line-numbers language-none"><code class="language-none">import PyPDF2 
import pdfplumber 
with pdfplumber.open(&quot;test.pdf&quot;) as p: 
page &#x3D; p.pages[2] 
print(page.extract_text())#打印第3页所有文字</code></pre>
<h3 id="2）利用-pdfplumber-提取表格并写入-excel"><a href="#2）利用-pdfplumber-提取表格并写入-excel" class="headerlink" title="2）利用 pdfplumber 提取表格并写入 excel"></a>2）利用 pdfplumber 提取表格并写入 excel</h3><ul>
<li>extract_table()：如果一页有一个表格；</li>
<li>extract_tables()：如果一页有多个表格；<pre class="line-numbers language-none"><code class="language-none">import PyPDF2 
import pdfplumber 
from openpyxl import Workbook 
with pdfplumber.open(&quot;test.pdf&quot;) as p: 
page &#x3D; p.pages[4] 
table &#x3D; page.extract_table() 
print(table) 
workbook &#x3D; Workbook()
sheet &#x3D; workbook.active 
for row in table: 
  if not &quot;&quot;.join([str(i) for i in row]) &#x3D;&#x3D; &quot;&quot;:
  #将列表中每个元素都连接成一个字符串，如果还是一个空字符串那么肯定就是空行。
    sheet.append(row)
  #sheet.append(row) #直接append这里提取出来的表格有很多空行
workbook.save(filename &#x3D; &quot;新pdf.xlsx&quot;)</code></pre>
提取表格这也是一种方式：<a href="https://github.com/camelot-dev/camelot">https://github.com/camelot-dev/camelot</a></li>
</ul>
<h3 id="3、PDF-合并及页面的排序和旋转"><a href="#3、PDF-合并及页面的排序和旋转" class="headerlink" title="3、PDF 合并及页面的排序和旋转"></a>3、PDF 合并及页面的排序和旋转</h3><h4 id="1）分割及合并-pdf"><a href="#1）分割及合并-pdf" class="headerlink" title="1）分割及合并 pdf"></a>1）分割及合并 pdf</h4><p>① 合并 pdf<br>首先，我们有如下几个文件，可以发现这里共有三个 PDF 文件需要我们合并。同时可以发现他们的文件名都是有规律的(如果文件名，没有先后顺序，我们合并起来就没有意义了。)</p>
<pre class="line-numbers language-none"><code class="language-none">from PyPDF2 import PdfFileReader, PdfFileWriter 
pdf_writer &#x3D; PdfFileWriter() 
for i in range(1,len(os.listdir(r&quot;G:\concat_pdf&quot;))+1):
  print(i*50+1,(i+1)*50) 
  pdf_reader &#x3D; PdfFileReader(&quot;G:\concat_pdf\&#123;&#125;-&#123;&#125;.pdf&quot;.format(i*50+1,(i+1)*50))  
  #这里是指文件名的格式为51-100，101-150、151-200
  for page in range(pdf_reader.getNumPages()):
    pdf_writer.addPage(pdf_reader.getPage(page)) 
with open(&quot;G:\concat_pdf\merge.pdf&quot;, &quot;wb&quot;) as out: 
  pdf_writer.write(out)</code></pre>
<p>② 拆分 pdf<br>这里有一个“时间序列.pdf”的文件，共 3 页，我们将其每一页存为一个 PDF 文件。</p>
<pre class="line-numbers language-none"><code class="language-none">from PyPDF2 import PdfFileReader, PdfFileWriter 
pdf_reader &#x3D; PdfFileReader(r&quot;G:\concat_pdf\时间序列.pdf&quot;) 
for page in range(pdf_reader.getNumPages()): 
  pdf_writer &#x3D; PdfFileWriter() 
  pdf_writer.addPage(pdf_reader.getPage(page)) 
  with open(f&quot;G:\concat_pdf\\&#123;page&#125;.pdf&quot;, &quot;wb&quot;) as out: 
    pdf_writer.write(out)</code></pre>
<h4 id="2）旋转及排序-pdf"><a href="#2）旋转及排序-pdf" class="headerlink" title="2）旋转及排序 pdf"></a>2）旋转及排序 pdf</h4><p>① 旋转 pdf</p>
<ul>
<li>.rotateClockwise(90 的倍数)：顺时针旋转 90 度</li>
<li>.rotateCounterClockwise(90 的倍数)：逆时针旋转 90 度<pre class="line-numbers language-none"><code class="language-none">from PyPDF2 import PdfFileReader, PdfFileWriter
pdf_reader &#x3D; PdfFileReader(r&quot;G:\concat_pdf\时间序列.pdf&quot;) 
pdf_writer &#x3D; PdfFileWriter() 
for page in range(pdf_reader.getNumPages()): 
  if page % 2 &#x3D;&#x3D; 0: 
    rotation_page &#x3D; pdf_reader.getPage(page).rotateCounterClockwise(90) 
  else: 
    rotation_page &#x3D; pdf_reader.getPage(page).rotateClockwise(90) 
  pdf_writer.addPage(rotation_page) 
  with open(&quot;G:\concat_pdf\旋转.pdf&quot;, &quot;wb&quot;) as out: 
    pdf_writer.write(out)
&quot;&quot;&quot; 
上述代码中，我们循环遍历了这个 pdf，对于偶数页我们逆时针旋转 90°，对于奇数页我
们顺时针旋转 90°； 注意：旋转的角度只能是 90 的倍数；
&quot;&quot;&quot;</code></pre>
② 排序 pdf<br>PDF 文件需要倒序排列，应该怎么做呢？</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">from PyPDF2 import PdfFileReader, PdfFileWriter 
pdf_reader &#x3D; PdfFileReader(r&quot;G:\concat_pdf\时间序列.pdf&quot;) 
pdf_writer &#x3D; PdfFileWriter() 
for page in range(pdf_reader.getNumPages()-1, -1, -1): 
#这里用到range，很巧妙
  pdf_writer.addPage(pdf_reader.getPage(page)) 
  with open(&quot;G:\concat_pdf\倒序.pdf&quot;, &quot;wb&quot;) as out:
    pdf_writer.write(out)</code></pre>
<h3 id="4、pdf-批量加水印及加密、解密"><a href="#4、pdf-批量加水印及加密、解密" class="headerlink" title="4、pdf 批量加水印及加密、解密"></a>4、pdf 批量加水印及加密、解密</h3><h4 id="1）批量加水印"><a href="#1）批量加水印" class="headerlink" title="1）批量加水印"></a>1）批量加水印</h4><pre class="line-numbers language-none"><code class="language-none">from PyPDF2 import PdfFileReader, PdfFileWriter 
from copy import copy 
water &#x3D; PdfFileReader(r&quot;G:\concat_pdf\水印.pdf&quot;) 
water_page &#x3D; water.getPage(0) 
pdf_reader &#x3D; PdfFileReader(r&quot;G:\concat_pdf\aa.pdf&quot;) 
pdf_writer &#x3D; PdfFileWriter() 
for page in range(pdf_reader.getNumPages()): 
  my_page &#x3D; pdf_reader.getPage(page) 
  new_page &#x3D; copy(water_page) 
  new_page.mergePage(my_page) 
  pdf_writer.addPage(new_page) 
  with open(&quot;G:\concat_pdf\\添加水印后的 aa.pdf&quot;, &quot;wb&quot;) as out: 
    pdf_writer.write(out) 
&quot;&quot;&quot; 
这里有一点需要注意：进行 pdf 合并的时候，我们希望“水印”在下面,
文字在上面，因此 是“水印”.mergePage(“图片页”)
&quot;&quot;&quot;</code></pre>
<h3 id="2）批量加密、解密"><a href="#2）批量加密、解密" class="headerlink" title="2）批量加密、解密"></a>2）批量加密、解密</h3><ul>
<li><p>这里的“解密”，是在知道 pdf 的密码下，去打开 pdf，而不是暴力破解；<br>① 加密 pdf</p>
<pre class="line-numbers language-none"><code class="language-none">from PyPDF2 import PdfFileReader, PdfFileWriter 
pdf_reader &#x3D; PdfFileReader(r&quot;G:\concat_pdf\test.pdf&quot;) 
pdf_writer &#x3D; PdfFileWriter() 
for page in range(pdf_reader.getNumPages()): 
pdf_writer.addPage(pdf_reader.getPage(page)) 
# 添加密码
pdf_writer.encrypt(&quot;a123456&quot;)
with open(&quot;G:\concat_pdf\\test.pdf&quot;, &quot;wb&quot;) as out: 
pdf_writer.write(out)</code></pre>
<p>② 解密 pdf 并保存为未加密的 pdf</p>
<pre class="line-numbers language-none"><code class="language-none">from PyPDF2 import PdfFileReader, PdfFileWriter 
pdf_reader &#x3D; PdfFileReader(r&quot;G:\concat_pdf\test.pdf&quot;) 
# 解密
pdf pdf_reader.decrypt(&quot;a123456&quot;) 
pdf_writer &#x3D; PdfFileWriter() 
for page in range(pdf_reader.getNumPages()): 
  pdf_writer.addPage(pdf_reader.getPage(page))
  with open(&quot;G:\concat_pdf\未加密.pdf&quot;, &quot;wb&quot;) as out: 
    pdf_writer.write(out)</code></pre>
<h2 id="python-使用-python-docx-操作-word"><a href="#python-使用-python-docx-操作-word" class="headerlink" title="python 使用 python-docx 操作 word"></a>python 使用 python-docx 操作 word</h2><h3 id="1、python-docx-库介绍"><a href="#1、python-docx-库介绍" class="headerlink" title="1、python-docx 库介绍"></a>1、python-docx 库介绍</h3></li>
<li><p>该模块儿可以创建、修改 Word（.docx）文件；</p>
</li>
<li><p>此模块儿不属于 python 标准库，需要单独安装；</p>
</li>
<li><p>python-docx 使用官网： <a href="https://python-docx.readthedocs.io/en/latest/%EF%BC%9B">https://python-docx.readthedocs.io/en/latest/；</a></p>
</li>
<li><p>我们在安装此模块儿使用的是 pip install python-docx，但是在导入的时候是 import<br>docx； </p>
<h3 id="2、Python-读取-Word-文档内容"><a href="#2、Python-读取-Word-文档内容" class="headerlink" title="2、Python 读取 Word 文档内容"></a>2、Python 读取 Word 文档内容</h3></li>
<li><p>注意：每进行一个操作，必须保存一下，否则等于白做；<br>1）word 文档结构介绍</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/zhang18340082962/image-rick@master/image-rick/%E5%9B%BE%E7%89%87.5t8bcxum41a8.png"><br>2）python-docx 提取文字和文字块儿<br>① python-docx 提取文字<br>有一个这样的 docx 文件，提取其中的文字</p>
<pre class="line-numbers language-none"><code class="language-none">from docx import Document 
doc &#x3D; Document(r&quot;G:\concat_word\test1.docx&quot;) 
print(doc.paragraphs) 
for paragraph in doc.paragraphs: 
  print(paragraph.text)</code></pre>
<p>② python-docx 提取文字块儿</p>
<pre class="line-numbers language-none"><code class="language-none">from docx import Document 
doc &#x3D; Document(r&quot;G:\concat_word\test1.docx&quot;) 
print(doc.paragraphs) 
for i range(len((doc.paragraphs)):
#这里按段落进行循环
  paragraph &#x3D; doc.paragraphs[i] 
  runs &#x3D; paragraph.runs 
  print(runs) 
  for run in paragraph.runs: 
    print(run.text)</code></pre>
<p>3）利用 Python 向 Word 文档写入内容</p>
<pre class="line-numbers language-none"><code class="language-none">from docx import Document 
doc &#x3D; Document(r&quot;G:\concat_word\test1.docx&quot;) 
# print(doc.add_heading(&quot;一级标题&quot;, level&#x3D;1)) 添加一级标题的时候出错，还没有解决！
paragraph1 &#x3D; doc.add_paragraph(&quot;这是一个段落&quot;) 
paragraph2 &#x3D; doc.add_paragraph(&quot;这是第二个段落&quot;) 
doc.save(r&quot;G:\concat_word\test1.docx&quot;) 
&quot;&quot;&quot; 
添加段落的时候，赋值给一个变量，方便我们后面进行格式调整；
&quot;&quot;&quot;</code></pre>
<ul>
<li>读取word文档中的表格内容<pre class="line-numbers language-none"><code class="language-none">import docx

fn &#x3D; r&#39;D:\长恨歌.docx&#39;
doc &#x3D; docx.Document(fn)

# 按段落读取全部数据
for paragraph in doc.paragraphs:
    print(paragraph.text)

# 按表格读取全部数据
for table in doc.tables:
    for row in table.rows:
        for cell in row.cells:
            print(cell.text)

table_num &#x3D; len(doc.tables)
# 获取文档的表格个数
print(table_num)

table_0 &#x3D; doc.tables[0]
# 选取第一个表
table_rows &#x3D; len(table_0.rows)
# 获取第一个表的行数
print(table_rows)

tab &#x3D; doc.tables[0].rows[0].cells[0]
# 获取第一张表第一行第一列数据
print(tab.text)

par &#x3D; doc.paragraphs[2]
# 读取第三段数据
print(par.text)</code></pre></li>
<li>批量提取word中表格内容<pre class="line-numbers language-none"><code class="language-none">import docx
import pandas as pd
from docx import Document #导入库
path &#x3D; &quot;word2.docx&quot; #文件路径
document &#x3D; Document(path) #读入文件
tables &#x3D; document.tables #获取文件中的表格集
table &#x3D; tables[0]#获取文件中的第一个表格

for table in tables:
    columns &#x3D; [table.cell(0,c).text for c in range(len(table.columns))]#获取表头 
#     print(columns)
    values &#x3D; []
    for i in range(1,len(table.rows)):#从表格第二行开始循环读取表格数据
        result &#x3D; [table.cell(i,c).text for c in range(len(table.columns))]# 自动获取每一行的数据
        #cell(i,0)表示第(i+1)行第1列数据，以此类推
#         print(result)
        values.append(result)
    print(values)
    print(columns)
    print(pd.DataFrame(data &#x3D; values,columns&#x3D;columns))</code></pre>
在操作word这块感觉并不怎么实用，等遇到问题了再加，也可以参考<br><a href="https://juejin.cn/post/6868073137263607821">https://juejin.cn/post/6868073137263607821</a></li>
</ul>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>自动化</tag>
      </tags>
  </entry>
  <entry>
    <title>python办公自动化：操作excel</title>
    <url>//post/python%E5%8A%9E%E5%85%AC%E8%87%AA%E5%8A%A8%E5%8C%96%EF%BC%9A%E6%93%8D%E4%BD%9Cexcel.html</url>
    <content><![CDATA[<p>#python 使用 openpyxl 操作 excel</p>
<ul>
<li><p>openpyxl 最好用的 python 操作 excel 表格库，不接受反驳（想反驳自己去学其他的） </p>
</li>
<li><p>openpyxl 官网链接：<a href="https://openpyxl.readthedocs.io/en/stable/">https://openpyxl.readthedocs.io/en/stable/</a></p>
</li>
<li><p><a href="https://www.zhihu.com/column/c_1261255815367487488">https://www.zhihu.com/column/c_1261255815367487488</a></p>
</li>
<li><p>openpyxl 只支持【.xlsx / .xlsm / .xltx / .xltm】格式的文件</p>
</li>
<li><p>建议在jupyter-notebook里面操作</p>
<h3 id="打开-Excel-表格并获取表格名称；通过-sheet-名称获取表格"><a href="#打开-Excel-表格并获取表格名称；通过-sheet-名称获取表格" class="headerlink" title="打开 Excel 表格并获取表格名称；通过 sheet 名称获取表格"></a>打开 Excel 表格并获取表格名称；通过 sheet 名称获取表格</h3><pre class="line-numbers language-none"><code class="language-none">from openpyxl import load_workbook 
workbook &#x3D; load_workbook(filename &#x3D; &quot;test.xlsx&quot;) 
workbook.sheetnames #打开 Excel 表格并获取表格名称
sheet &#x3D; workbook[&quot;Sheet1&quot;] #通过 sheet 名称获取表格
sheet.dimensions # 获取表格的尺寸大小(几行几列数据)</code></pre>
<h3 id="获取表格内某个格子的数据"><a href="#获取表格内某个格子的数据" class="headerlink" title="获取表格内某个格子的数据"></a>获取表格内某个格子的数据</h3><pre class="line-numbers language-none"><code class="language-none">workbook &#x3D; load_workbook(filename &#x3D; &quot;test.xlsx&quot;) 
sheet &#x3D; workbook.active #打开激活的表格
print(sheet) 
cell1 &#x3D; sheet[&quot;A1&quot;] #获取 A1 格子的数据
cell2 &#x3D; sheet[&quot;C11&quot;] 
cell3 &#x3D; sheet.cell(row &#x3D; 1,column &#x3D; 1) #通过指定行列号获取格子数据
cell4 &#x3D; sheet.cell(row &#x3D; 11,column &#x3D; 3)
print(cell1.value, cell1.row, cell1.column, cell1.coordinate) 
#获取格子中的值、行数、列数、坐标；
sheet[&quot;A&quot;] --- 获取 A 列的数据
sheet[&quot;A:C&quot;] --- 获取 A,B,C 三列的数据
sheet[5] --- 只获取第 5 行的数据
# 获取 A1:C2 区域的值
cell &#x3D; sheet[&quot;A1:C2&quot;] 
print(cell) 
for i in cell: 
  for j in i: 
    print(j.value)</code></pre></li>
<li><p>.iter_rows()方式（类似pandas里面的iterrows）有.iter_rows()方式，肯定也会有.iter_cols()方式，只不过一个是按行读取，一个是按<br>列读取。</p>
<pre class="line-numbers language-none"><code class="language-none">workbook &#x3D; load_workbook(filename &#x3D; &quot;test.xlsx&quot;) 
sheet &#x3D; workbook.active 
print(sheet) 
# 按行获取值
for i in sheet.iter_rows(min_row&#x3D;2, max_row&#x3D;5, min_col&#x3D;1, max_col&#x3D;2): #按行读取
  for j in i: 
    print(j.value)
# 按列获取值
for i in sheet.iter_cols(min_row&#x3D;2, max_row&#x3D;5, min_col&#x3D;1, max_col&#x3D;2): #按列读取
  for j in i: 
    print(j.value)
for i in sheet.rows: #获取所有行
  print(i)</code></pre>
<h3 id="修改表格中的内容-向某个格子中写入内容并保存"><a href="#修改表格中的内容-向某个格子中写入内容并保存" class="headerlink" title="修改表格中的内容: 向某个格子中写入内容并保存"></a>修改表格中的内容: 向某个格子中写入内容并保存</h3><pre class="line-numbers language-none"><code class="language-none">workbook &#x3D; load_workbook(filename &#x3D; &quot;test.xlsx&quot;) 
sheet &#x3D; workbook.active 
print(sheet)
sheet[&quot;A1&quot;] &#x3D; &quot;哈喽&quot; 
# 这句代码也可以改为 cell &#x3D; sheet[&quot;A1&quot;] cell.value &#x3D; &quot;哈喽&quot; 
workbook.save(filename &#x3D; &quot;哈喽.xlsx&quot;) 
&quot;&quot;&quot; 
注意：我们将“A1”单元格的数据改为了“哈喽”，并另存为了“哈喽.xlsx”文
件。 如果我们保存的时候，不修改表名，相当于直接修改源文件；
&quot;&quot;&quot;</code></pre></li>
<li><p>.append()方式：会在表格已有的数据后面，按行插入数据(很有用)；</p>
<pre class="line-numbers language-none"><code class="language-none">workbook &#x3D; load_workbook(filename &#x3D; &quot;test.xlsx&quot;) 
sheet &#x3D; workbook.active
print(sheet) 
data &#x3D; [ 
[&quot;唐僧&quot;,&quot;男&quot;,&quot;180cm&quot;], 
[&quot;孙悟空&quot;,&quot;男&quot;,&quot;188cm&quot;], 
[&quot;猪八戒&quot;,&quot;男&quot;,&quot;175cm&quot;], 
[&quot;沙僧&quot;,&quot;男&quot;,&quot;176cm&quot;], 
] 
for row in data: 
  sheet.append(row) 
workbook.save(filename &#x3D; &quot;test.xlsx&quot;)</code></pre>
<h3 id="使用-excel-函数公式-很有用"><a href="#使用-excel-函数公式-很有用" class="headerlink" title="使用 excel 函数公式(很有用)"></a>使用 excel 函数公式(很有用)</h3><pre class="line-numbers language-none"><code class="language-none">import openpyxl
from openpyxl.utils import FORMULAE 
print(FORMULAE)#python 支持写哪些“excel 函数公式”</code></pre>
<pre class="line-numbers language-none"><code class="language-none"># 这是我们在 excel 中输入的公式
&#x3D;IF(RIGHT(C2,2)&#x3D;&quot;cm&quot;,C2,SUBSTITUTE(C2,&quot;m&quot;,&quot;&quot;)*100&amp;&quot;cm&quot;) 
# 那么，在 python 中怎么插入 excel 公式呢？
workbook &#x3D; load_workbook(filename &#x3D; &quot;test.xlsx&quot;) 
sheet &#x3D; workbook.active 
print(sheet) 
sheet[&quot;D1&quot;] &#x3D; &quot;标准身高&quot; 
for i in range(2,16): 
  sheet[&quot;D&#123;&#125;&quot;.format(i)] &#x3D; 
  &#39;&#x3D;IF(RIGHT(C&#123;&#125;,2)&#x3D;&quot;cm&quot;,C&#123;&#125;,SUBSTITUTE(C&#123;&#125;,&quot;m&quot;,&quot;&quot;)*100&amp;&quot;cm&quot;)&#39;.format(i,i,i) 
workbook.save(filename &#x3D; &quot;test.xlsx&quot;)</code></pre>
<h3 id="insert-cols-和-insert-rows-：插入空行和空列"><a href="#insert-cols-和-insert-rows-：插入空行和空列" class="headerlink" title=".insert_cols()和.insert_rows()：插入空行和空列"></a>.insert_cols()和.insert_rows()：插入空行和空列</h3></li>
<li><p>.insert_cols(idx=数字编号, amount=要插入的列数)，插入的位置是在 idx 列数的左侧插入；</p>
</li>
<li><p>.insert_rows(idx=数字编号, amount=要插入的行数)，插入的行数是在 idx 行数的下方插入；</p>
<pre class="line-numbers language-none"><code class="language-none">workbook &#x3D; load_workbook(filename &#x3D; &quot;test.xlsx&quot;) 
sheet &#x3D; workbook.active 
print(sheet) 
sheet.insert_cols(idx&#x3D;4,amount&#x3D;2) #从第4列开始插入2列
sheet.insert_rows(idx&#x3D;5,amount&#x3D;4) #第5行开始插入2行
workbook.save(filename &#x3D; &quot;test.xlsx&quot;)</code></pre></li>
</ul>
<h3 id="delete-rows-和-delete-cols-：删除行和列"><a href="#delete-rows-和-delete-cols-：删除行和列" class="headerlink" title=".delete_rows()和.delete_cols()：删除行和列"></a>.delete_rows()和.delete_cols()：删除行和列</h3><ul>
<li>.delete_rows(idx=数字编号, amount=要删除的行数)</li>
<li>.delete_cols(idx=数字编号, amount=要删除的列数)<pre class="line-numbers language-none"><code class="language-none">workbook &#x3D; load_workbook(filename &#x3D; &quot;test.xlsx&quot;) 
sheet &#x3D; workbook.active print(sheet) 
# 删除第一列，第一行
sheet.delete_cols(idx&#x3D;1) 
sheet.delete_rows(idx&#x3D;1) 
workbook.save(filename &#x3D; &quot;test.xlsx&quot;)</code></pre>
<h3 id="move-range-：移动格子"><a href="#move-range-：移动格子" class="headerlink" title=".move_range()：移动格子"></a>.move_range()：移动格子</h3></li>
<li>.move_range(“数据区域”,rows=,cols=)：row正整数表示向下、负整数表示向上移动；cols正整数表示向右、负整数表示向左移动。</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">sheet.move_range(&quot;C1:D4&quot;,rows&#x3D;2,cols&#x3D;-1)# 向左移动两列，向下移动两行</code></pre>
<h3 id="create-sheet-：创建新的-sheet-表格"><a href="#create-sheet-：创建新的-sheet-表格" class="headerlink" title=".create_sheet()：创建新的 sheet 表格"></a>.create_sheet()：创建新的 sheet 表格</h3><ul>
<li>.create_sheet(“新的 sheet 名”)：创建一个新的 sheet 表；<pre class="line-numbers language-none"><code class="language-none">workbook &#x3D; load_workbook(filename &#x3D; &quot;test.xlsx&quot;) 
sheet &#x3D; workbook.active 
print(sheet) 
workbook.create_sheet(&quot;我是一个新的 sheet&quot;) 
print(workbook.sheetnames) 
workbook.save(filename &#x3D; &quot;test.xlsx&quot;)</code></pre></li>
</ul>
<h3 id="remove-：删除某个-sheet-表"><a href="#remove-：删除某个-sheet-表" class="headerlink" title=".remove()：删除某个 sheet 表"></a>.remove()：删除某个 sheet 表</h3><ul>
<li>.remove(“sheet 名”)：删除某个 sheet 表；<pre class="line-numbers language-none"><code class="language-none">workbook &#x3D; load_workbook(filename &#x3D; &quot;test.xlsx&quot;) 
sheet &#x3D; workbook.active 
print(workbook.sheetnames) 
# 这个相当于激活的这个 sheet 表，激活状态下，才可以操作；
sheet &#x3D; workbook[&#39;我是一个新的 sheet&#39;] 
print(sheet) 
workbook.remove(sheet) 
print(workbook.sheetnames) 
workbook.save(filename &#x3D; &quot;test.xlsx&quot;)</code></pre></li>
</ul>
<h3 id="copy-worksheet-：复制一个-sheet-表到另外一张-excel-表"><a href="#copy-worksheet-：复制一个-sheet-表到另外一张-excel-表" class="headerlink" title=".copy_worksheet()：复制一个 sheet 表到另外一张 excel 表"></a>.copy_worksheet()：复制一个 sheet 表到另外一张 excel 表</h3><ul>
<li>这个操作的实质，就是复制某个 excel 表中的 sheet 表，然后将文件存储到另外一张excel 表中<pre class="line-numbers language-none"><code class="language-none">workbook &#x3D; load_workbook(filename &#x3D; &quot;a.xlsx&quot;) 
sheet &#x3D; workbook.active 
print(&quot;a.xlsx 中有这几个 sheet 表&quot;,workbook.sheetnames) 
sheet &#x3D; workbook[&#39;姓名&#39;] 
workbook.copy_worksheet(sheet) 
workbook.save(filename &#x3D; &quot;test.xlsx&quot;)</code></pre></li>
</ul>
<h3 id="sheet-title：修改-sheet-表的名称"><a href="#sheet-title：修改-sheet-表的名称" class="headerlink" title="sheet.title：修改 sheet 表的名称"></a>sheet.title：修改 sheet 表的名称</h3><pre class="line-numbers language-none"><code class="language-none">workbook &#x3D; load_workbook(filename &#x3D; &quot;a.xlsx&quot;) 
sheet &#x3D; workbook.active 
print(sheet) 
sheet.title &#x3D; &quot;我是修改后的 sheet 名&quot; 
print(sheet)</code></pre>

<h3 id="创建新的-excel-表格文件"><a href="#创建新的-excel-表格文件" class="headerlink" title="创建新的 excel 表格文件"></a>创建新的 excel 表格文件</h3><pre class="line-numbers language-none"><code class="language-none">from openpyxl import Workbook 
workbook &#x3D; Workbook() 
sheet &#x3D; workbook.active 
sheet.title &#x3D; &quot;表格 1&quot; 
workbook.save(filename &#x3D; &quot;新建的 excel 表格&quot;)</code></pre>

<h3 id="sheet-freeze-panes：冻结窗口"><a href="#sheet-freeze-panes：冻结窗口" class="headerlink" title="sheet.freeze_panes：冻结窗口"></a>sheet.freeze_panes：冻结窗口</h3><ul>
<li>.freeze_panes = “单元格”<pre class="line-numbers language-none"><code class="language-none">workbook &#x3D; load_workbook(filename &#x3D; &quot;花园.xlsx&quot;) 
sheet &#x3D; workbook.active 
print(sheet) 
sheet.freeze_panes &#x3D; &quot;C3&quot; 
workbook.save(filename &#x3D; &quot;花园.xlsx&quot;) 
&quot;&quot;&quot; 
冻结窗口以后，你可以打开源文件，进行检验；
&quot;&quot;&quot;</code></pre></li>
</ul>
<h3 id="sheet-auto-filter-ref：给表格添加“筛选器”"><a href="#sheet-auto-filter-ref：给表格添加“筛选器”" class="headerlink" title="sheet.auto_filter.ref：给表格添加“筛选器”"></a>sheet.auto_filter.ref：给表格添加“筛选器”</h3><ul>
<li>.auto_filter.ref = sheet.dimension 给所有字段添加筛选器；</li>
<li>.auto_filter.ref = “A1” 给 A1 这个格子添加“筛选器”，就是给第一列添加“筛选器”；<pre class="line-numbers language-none"><code class="language-none">workbook &#x3D; load_workbook(filename &#x3D; &quot;花园.xlsx&quot;) 
sheet &#x3D; workbook.active 
print(sheet) 
sheet.auto_filter.ref &#x3D; sheet[&quot;A1&quot;] 
workbook.save(filename &#x3D; &quot;花园.xlsx&quot;)</code></pre></li>
</ul>
<h2 id="批量调整字体和样式"><a href="#批量调整字体和样式" class="headerlink" title="批量调整字体和样式"></a>批量调整字体和样式</h2><h3 id="1、修改字体样式"><a href="#1、修改字体样式" class="headerlink" title="1、修改字体样式"></a>1、修改字体样式</h3><ul>
<li>Font(name=字体名称,size=字体大小,bold=是否加粗,italic=是否斜体,color=字体颜色)<pre class="line-numbers language-none"><code class="language-none">from openpyxl.styles import Font 
from openpyxl import load_workbook 
workbook &#x3D; load_workbook(filename&#x3D;&quot;花园.xlsx&quot;) 
sheet &#x3D; workbook.active 
cell &#x3D; sheet[&quot;A1&quot;] 
font &#x3D; Font(name&#x3D;&quot;微软雅黑&quot;,size&#x3D;20,bold&#x3D;True,italic&#x3D;True,color&#x3D;&quot;FF0000&quot;) 
cell.font &#x3D; font
workbook.save(filename &#x3D; &quot;花园.xlsx&quot;) 
&quot;&quot;&quot; 
这个 color 是 RGB 的 16 进制表示，自己下去百度学习；
&quot;&quot;&quot;</code></pre></li>
</ul>
<h3 id="2、获取表格中格子的字体样式"><a href="#2、获取表格中格子的字体样式" class="headerlink" title="2、获取表格中格子的字体样式"></a>2、获取表格中格子的字体样式</h3><pre class="line-numbers language-none"><code class="language-none">from openpyxl.styles import Font 
from openpyxl import load_workbook 
workbook &#x3D; load_workbook(filename&#x3D;&quot;花园.xlsx&quot;) 
sheet &#x3D; workbook.active 
cell &#x3D; sheet[&quot;A2&quot;] 
font &#x3D; cell.font 
print(font.name, font.size, font.bold, font.italic, font.color)</code></pre>

<h3 id="3、设置对齐样式"><a href="#3、设置对齐样式" class="headerlink" title="3、设置对齐样式"></a>3、设置对齐样式</h3><ul>
<li><p>Alignment(horizontal=水平对齐模式,vertical=垂直对齐模式,text_rotation=旋转角<br>度,wrap_text=是否自动换行)</p>
</li>
<li><p>水平对齐：‘distributed’，‘justify’，‘center’，‘leftfill’， ‘centerContinuous’，‘right，<br>‘general’；</p>
</li>
<li><p>垂直对齐：‘bottom’，‘distributed’，‘justify’，‘center’，‘top’；</p>
<pre class="line-numbers language-none"><code class="language-none">from openpyxl.styles import Alignment 
from openpyxl import load_workbook 
workbook &#x3D; load_workbook(filename&#x3D;&quot;花园.xlsx&quot;) 
sheet &#x3D; workbook.active 
cell &#x3D; sheet[&quot;A1&quot;]
alignment &#x3D; Alignment(horizontal&#x3D;&quot;center&quot;,vertical&#x3D;&quot;center&quot;,text_rotation&#x3D;45,wrap_text&#x3D;True) 
cell.alignment &#x3D; alignment 
workbook.save(filename &#x3D; &quot;花园.xlsx&quot;)</code></pre>
<h3 id="4、设置边框样式"><a href="#4、设置边框样式" class="headerlink" title="4、设置边框样式"></a>4、设置边框样式</h3></li>
<li><p>Side(style=边线样式，color=边线颜色)</p>
</li>
<li><p>Border(left=左边线样式，right=右边线样式，top=上边线样式，bottom=下边线样式)</p>
</li>
<li><p>style 参数的种类： ‘double, ‘mediumDashDotDot’, ‘slantDashDot’, ‘dashDotDot’,’dotted’,’hair’,<br>‘mediumDashed, ‘dashed’, ‘dashDot’, ‘thin’, ‘mediumDashDot’,’medium’, ‘thick’</p>
<pre class="line-numbers language-none"><code class="language-none">from openpyxl.styles import Side,Border 
from openpyxl import load_workbook 
workbook &#x3D; load_workbook(filename&#x3D;&quot;花园.xlsx&quot;) 
sheet &#x3D; workbook.active 
cell &#x3D; sheet[&quot;D6&quot;]
side1 &#x3D; Side(style&#x3D;&quot;thin&quot;,color&#x3D;&quot;FF0000&quot;) 
side2 &#x3D; Side(style&#x3D;&quot;thick&quot;,color&#x3D;&quot;FFFF0000&quot;) 
border &#x3D; Border(left&#x3D;side1,right&#x3D;side1,top&#x3D;side2,bottom&#x3D;side2) 
cell.border &#x3D; border 
workbook.save(filename &#x3D; &quot;花园.xlsx&quot;)</code></pre></li>
</ul>
<h3 id="5、设置填充样式"><a href="#5、设置填充样式" class="headerlink" title="5、设置填充样式"></a>5、设置填充样式</h3><ul>
<li><p>PatternFill(fill_type=填充样式，fgColor=填充颜色）</p>
</li>
<li><p>GradientFill(stop=(渐变颜色 1，渐变颜色 2……))</p>
<pre class="line-numbers language-none"><code class="language-none">from openpyxl.styles import PatternFill,GradientFill 
from openpyxl import load_workbook 
workbook &#x3D; load_workbook(filename&#x3D;&quot;花园.xlsx&quot;) 
sheet &#x3D; workbook.active 
cell_b9 &#x3D; sheet[&quot;B9&quot;] 
pattern_fill &#x3D; PatternFill(fill_type&#x3D;&quot;solid&quot;,fgColor&#x3D;&quot;99ccff&quot;) 
cell_b9.fill &#x3D; pattern_fill 
cell_b10 &#x3D; sheet[&quot;B10&quot;]
gradient_fill &#x3D; GradientFill(stop&#x3D;(&quot;FFFFFF&quot;,&quot;99ccff&quot;,&quot;000000&quot;)) 
cell_b10.fill &#x3D; gradient_fill 
workbook.save(filename &#x3D; &quot;花园.xlsx&quot;)</code></pre>
<h3 id="6、设置行高和列宽"><a href="#6、设置行高和列宽" class="headerlink" title="6、设置行高和列宽"></a>6、设置行高和列宽</h3></li>
<li><p>.row_dimensions[行编号].height = 行高</p>
</li>
<li><p>.column_dimensions[列编号].width = 列宽</p>
<pre class="line-numbers language-none"><code class="language-none">workbook &#x3D; load_workbook(filename&#x3D;&quot;花园.xlsx&quot;) 
sheet &#x3D; workbook.active 
# 设置第 1 行的高度
sheet.row_dimensions[1].height &#x3D; 50 #将整个表的行高设置为 50
# 设置 B 列的宽度
sheet.column_dimensions[&quot;B&quot;].width &#x3D; 20 #列宽设置为 30；
workbook.save(filename &#x3D; &quot;花园.xlsx&quot;)</code></pre></li>
</ul>
<h3 id="7、合并单元格"><a href="#7、合并单元格" class="headerlink" title="7、合并单元格"></a>7、合并单元格</h3><ul>
<li>.merge_cells(待合并的格子编号)</li>
<li>.merge_cells(start_row=起始行号，start_column=起始列号，end_row=结束行号，<br>end_column=结束列号)<pre class="line-numbers language-none"><code class="language-none">workbook &#x3D; load_workbook(filename&#x3D;&quot;花园.xlsx&quot;)
sheet &#x3D; workbook.active sheet.merge_cells(&quot;C1:D2&quot;) 
sheet.merge_cells(start_row&#x3D;7,start_column&#x3D;1,end_row&#x3D;8,end_column&#x3D;3) 
workbook.save(filename &#x3D; &quot;花园.xlsx&quot;)</code></pre>
当然，也有“取消合并单元格”，用法一致。</li>
<li>.unmerge_cells(待合并的格子编号)</li>
<li>.unmerge_cells(start_row=起始行号，start_column=起始列号，end_row=结束行号，<br>end_column=结束列号)</li>
</ul>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>自动化</tag>
      </tags>
  </entry>
  <entry>
    <title>python办公自动化：文件和目录操作</title>
    <url>//post/python%E5%8A%9E%E5%85%AC%E8%87%AA%E5%8A%A8%E5%8C%96%EF%BC%9A%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C.html</url>
    <content><![CDATA[<pre class="line-numbers language-none"><code class="language-none">import os</code></pre>
<h3 id="创建目录结构"><a href="#创建目录结构" class="headerlink" title="创建目录结构"></a>创建目录结构</h3><ul>
<li>os.makedirs 可以递归的创建目录结构，比如<pre class="line-numbers language-none"><code class="language-none">os.makedirs(&#39;tmp&#x2F;python&#x2F;fileop&#39;,exist_ok&#x3D;True)</code></pre>
在当前工作目录下面创建 tmp目录，在tmp目录下面再创建 python目录，在Python目录下面再创建fileop目录；exist_ok=True 指定了，如果某个要创建的目录已经存在，也不报错</li>
</ul>
<h3 id="删除文件或目录"><a href="#删除文件或目录" class="headerlink" title="删除文件或目录"></a>删除文件或目录</h3><p>os.remove 可以删除一个文件，比如</p>
<pre class="line-numbers language-none"><code class="language-none">os.remove(&#39;sdf.py&#39;)</code></pre>
<p>shutil.rmtree() 可以递归的删除某个目录所有的子目录和子文件 比如</p>
<pre class="line-numbers language-none"><code class="language-none">import shutil
shutil.rmtree(&#39;tmp&#39;, ignore_errors&#x3D;True)</code></pre>
<p>注意：参数 ignore_errors=True 保证如果目录不为空，不会抛出异常。</p>
<h3 id="拷贝文件"><a href="#拷贝文件" class="headerlink" title="拷贝文件"></a>拷贝文件</h3><p>shutil 模块里面有很多 目录文件操作的函数<br>拷贝文件，可以使用shutil模块的copyfile函数。</p>
<pre class="line-numbers language-none"><code class="language-none">from shutil import copyfile
# 拷贝 d:&#x2F;tools&#x2F;first.py 到 e:&#x2F;first.py
copyfile(&#39;d:&#x2F;tools&#x2F;first.py&#39;, &#39;e:&#x2F;first.py&#39;)</code></pre>
<p>注意，如果拷贝前，e:/first.py 已经存在，则会被拷贝覆盖，所以使用该函数一定要小心。<br>###拷贝目录<br>如果我们要拷贝一个目录里面所有的内容（包括子目录和文件、子目录里面的子目录和文件，等等）到另外一个目录中，可以使用 shutil的copytree函数。</p>
<pre class="line-numbers language-none"><code class="language-none">from shutil import copytree
# 拷贝 d:&#x2F;tools&#x2F;aaa 目录中所有的内容 到 e:&#x2F;bbb 中
copytree(&#39;d:&#x2F;tools&#x2F;aaa&#39;, &#39;e:&#x2F;new&#x2F;bbb&#39;)</code></pre>
<p>注意拷贝前， 目标目录必须 不存在 ，否则会报错。</p>
<p>上面的代码执行前面，如果 e:/new/bbb 已经存在，执行到copytree时，就会报错</p>
<p>上面的代码执行前面，如果 e:/new 这个目录都不存在，执行到copytree时，就会 创建 e:/new 目录，再创建 e:/new/bbb 目录，再拷贝 d:/tools/aaa 目录中所有的内容 到 e:/new/bbb 中。</p>
<p>上面的代码执行前面，如果 e:/new 这个目录存在，但是 e:/new/bbb 不存在，执行到copytree时，就只会 创建 e:/new/bbb ，再拷贝 d:/tools/aaa 目录中所有的内容 到 e:/new/bbb 中。<br>###修改文件名、目录名<br>要修改文件名、目录名，可以使用os模块的rename函数。</p>
<pre class="line-numbers language-none"><code class="language-none"># 修改目录名 d:&#x2F;tools&#x2F;aaa 为 d:&#x2F;tools&#x2F;bbb
os.rename(&#39;d:&#x2F;tools&#x2F;aaa&#39;,&#39;d:&#x2F;tools&#x2F;bbb&#39;)

# 修改文件名 d:&#x2F;tools&#x2F;first.py 为 d:&#x2F;tools&#x2F;second.py
os.rename(&#39;d:&#x2F;tools&#x2F;first.py&#39;,&#39;d:&#x2F;tools&#x2F;second.py&#39;)</code></pre>

<h3 id="对文件路径名的操作"><a href="#对文件路径名的操作" class="headerlink" title="对文件路径名的操作"></a>对文件路径名的操作</h3><p>对于文件名的操作，比如 获取文件名称，文件所在目录，文件路径的拼接等，都可以使用 os.path 模块。</p>
<p>通常我们喜欢使用格式化字符串的方法来做文件路径的拼接，但是如果你的程序需要在Linux、Windows等多个平台运行，它们的路径的分隔符是不同的，Windows上是 <code>\</code> , 而 Linux上是 <code>/</code>。</p>
<p>这时，我们应该使用 os.path 模块。 它能够自动处理类似 Data/data.csv 和 Data\data.csv 这样的文件路径差异。</p>
<pre class="line-numbers language-none"><code class="language-none">path &#x3D; &#39;&#x2F;Users&#x2F;beazley&#x2F;Data&#x2F;data.csv&#39;
# 获取路径中的文件名部分
os.path.basename(path)
&#39;data.csv&#39;
# 获取路径中的目录部分
os.path.dirname(path)
&#39;&#x2F;Users&#x2F;beazley&#x2F;Data&#39;
# 文件路径的拼接
os.path.join(&#39;tmp&#39;, &#39;data&#39;, os.path.basename(path))
&#39;tmp&#x2F;data&#x2F;data.csv&#39;</code></pre>
<h3 id="判断文件、目录是否存在"><a href="#判断文件、目录是否存在" class="headerlink" title="判断文件、目录是否存在"></a>判断文件、目录是否存在</h3><pre class="line-numbers language-none"><code class="language-none">os.path.exists(&#39;d:&#x2F;systems&#x2F;cmd.exe&#39;)
os.path.exists(&#39;d:&#x2F;systems&#39;)</code></pre>
<p>exists方法返回值为True表示 存在，否则表示不存在。<br>如果你要判断指定路径是否是文件，可以这样<br>os.path.isfile(‘d:/systems/cmd.exe’)# 返回值为True 表示是文件<br>如果你要判断指定路径是否是目录，可以这样<br>os.path.isdir(‘d:/systems’)#返回值为True 表示是目录</p>
<p>###文件大小和修改日期</p>
<ul>
<li><p>返回文件大小<br>os.path.getsize(‘file1’)<br>3669</p>
</li>
<li><p>返回文件的最后修改日期，是秒时间<br>参考下一章 日期和时间 里面的内容<br>os.path.getmtime(‘file1’)<br>1272478234.0</p>
</li>
<li><p>可以把秒时间 转化为日期时间<br>import time<br>time.ctime(os.path.getmtime(‘/etc/passwd’))<br>‘Wed Apr 28 13:10:34 2010’</p>
</li>
</ul>
<p>###当前工作目录<br>当前工作目录的路径：<br>wd = os.getcwd()<br>改变当前工作目录到另外的路径：<br>os.chdir(path)<br>参数就是 新的当前工作目录 路径地址。</p>
<p>###递归的遍历目录下面所有的文件<br>获取某个目录中所有的 文件， 包括子目录里面的文件。 可以使用 os库中的walk方法<br>比如我们要得到某个目录下面所有的子目录 和所有的文件，存放在两个列表中<br> os.walk(top[, topdown=True[, onerror=None[, followlinks=False]]])<br>    top ：是你所要遍历的目录的地址, 返回的是一个三元组 (dirpath, dirnames, filenames)<br>    topdown ：可选，True则优先遍历 top 文件夹，与top 文件夹中每一个子目录；否则优先遍历 top 的子目录(默认为开启)。<br>    onerror ：可选，需要一个 callable 对象，当 walk 需要异常时，会调用<br>    followlinks ：可选，如果为 True，则会遍历目录下的快捷方式(linux 下是软连接 symbolic link )实际所指的目录(默认关闭)，如果为 False，则优先遍历 top 的子目录；</p>
<ul>
<li>得到某个目录下所有文件的全路径<pre class="line-numbers language-none"><code class="language-none">import os
# 目标目录
targetDir &#x3D; r&#39;d:\tmp\util\dist\check&#39;
for (dirpath, dirnames, filenames) in os.walk(targetDir):
    for fn in filenames:
        # 把 dirpath 和 每个文件名拼接起来 就是全路径
        fpath &#x3D; os.path.join(dirpath, fn)
# dirpath 代表当前遍历到的目录名
# dirnames 是列表对象，存放当前dirpath中的所有子目录名
# filenames 是列表对象，存放当前dirpath中的所有文件名</code></pre>
<h3 id="得到目录中所有的文件和子目录名"><a href="#得到目录中所有的文件和子目录名" class="headerlink" title="得到目录中所有的文件和子目录名"></a>得到目录中所有的文件和子目录名</h3>listdir返回的是该目录下面所有的文件和子目录。<pre class="line-numbers language-none"><code class="language-none"># 目标目录
targetDir &#x3D; r&#39;d:\tmp\util\dist\check&#39;
files &#x3D;  os.listdir(targetDir)
print(files)</code></pre>
如果只需要获取目录中所有的文件，或者只需要子目录<pre class="line-numbers language-none"><code class="language-none">import os
from os.path import isfile, join,isdir
# 目标目录
targetDir &#x3D; r&#39;d:\tmp\util\dist\check&#39;
# 所有的文件
print([f for f in os.listdir(targetDir) if isfile(join(targetDir, f))])
# 所有的目录
print([f for f in os.listdir(targetDir) if isdir(join(targetDir, f))])</code></pre>
###得到目录中指定扩展名的文件和子目录<br>可以使用glob库<pre class="line-numbers language-none"><code class="language-none">import glob
exes &#x3D; glob.glob(r&#39;d:\tmp\*.txt&#39;)
print(exes)</code></pre>
<a href="http://www.byhy.net/tut/py/extra/file_dir">http://www.byhy.net/tut/py/extra/file_dir</a></li>
</ul>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>自动化</tag>
      </tags>
  </entry>
  <entry>
    <title>python办公自动化：邮件发送</title>
    <url>//post/python%E5%8A%9E%E5%85%AC%E8%87%AA%E5%8A%A8%E5%8C%96%EF%BC%9A%E9%82%AE%E4%BB%B6%E5%8F%91%E9%80%81.html</url>
    <content><![CDATA[<ul>
<li>邮件批量发送<br>调用smtp.exmail.qq.com批量自动发送邮件<br>注意文件路径，逗号分隔符，csv中不要有多余回车和空格<pre class="line-numbers language-none"><code class="language-none">import os
import sys
import csv
import smtplib
import pandas as pd
import numpy as np
from email.mime.base import MIMEBase
from email.mime.image import MIMEImage
from email.utils import formataddr
from email import encoders
import time,datetime
import smtplib
import email.mime.multipart
import email.mime.text
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from email.mime.application import MIMEApplication
from email.header import Header

def get_current_date():
    &quot;&quot;&quot;获取当前时间&quot;&quot;&quot;
    return str(time.strftime(&#39;%Y%m%d&#39;))

def getAddrBook(addrBook):
    &#39;&#39;&#39;
        @作用：根据输入的CSV文件，形成相应的通讯录字典
        @返回：字典类型，name为人名，value为对应的邮件地址
    &#39;&#39;&#39;
    with open(addrBook,&#39;r&#39;,encoding&#x3D;&#39;UTF-8&#39;) as addrFile:
        #将文件名和邮件接收人邮箱地址分行存放在csv文件中，用逗号分隔
        reader &#x3D; csv.reader(addrFile)
        name &#x3D; []
        value &#x3D; []
        for row in reader:
            name.append(row[0])
            value.append(row[1])
    addrs &#x3D; dict(zip(name, value))
    return addrs

def send_email(inputpath,smtpHost,port,sendAddr,password,recipientAddrs, subject, content,attachfilename):
    &quot;&quot;&quot;定义并配置好发邮件的函数&quot;&quot;&quot;
    msg &#x3D; email.mime.multipart.MIMEMultipart()
    msg[&#39;from&#39;] &#x3D;sendAddr #发件人
    msg[&#39;to&#39;] &#x3D;recipientAddrs #接收人
    # msg[&#39;cc&#39;] &#x3D;cc_name #抄送人名称
    msg[&#39;subject&#39;] &#x3D;subject #主题
    content&#x3D;content
    txt &#x3D; email.mime.text.MIMEText(content, &#39;plain&#39;, &#39;UTF-8&#39;)
    msg.attach(txt)
    print(&quot;准备添加附件...&quot;)
    inputfile&#x3D;inputpath+attachfilename #文件路径
    part &#x3D; MIMEText(open(inputfile,&#39;rb&#39;).read(),&#39;base64&#39;, &#39;utf-8&#39;)
    part[&quot;Content-Type&quot;] &#x3D; &#39;application&#x2F;octet-stream&#39;
    part.add_header(&#39;Content-Disposition&#39;, &#39;attachment&#39;, filename&#x3D;Header(attachfilename,&#39;utf-8&#39;).encode())
    msg.attach(part)
    smtp &#x3D; smtplib.SMTP_SSL(smtpHost, port)
    smtp.login(sendAddr, password)
    smtp.sendmail(sendAddr, recipientAddrs.split(&#39;,&#39;), str(msg))   #+cc_name.split(&#39;,&#39;)
    #print(&quot;发送成功！&quot;)
    smtp.quit()

if __name__&#x3D;&#x3D;&#39;__main__&#39;:
    #这里需要定义send_email函数中传入的所有变量
    inputpath &#x3D; &quot;r&#39;D:&#x2F;&quot; #数据存放的文件路径（这里是绝对路径）
    smtpHost &#x3D; &#39;smtp.exmail.qq.com&#39;  # 默认服务器地址及端口
    port&#x3D;465
    sendAddr &#x3D;&quot;&quot;    #自己也就是发件人的邮箱账号
    password &#x3D; &quot;&quot;   #自己的邮箱密码
    subject&#x3D;&quot; &quot;+current_date  #主题+当前日期
    content&#x3D;&#39;&#39;&#39;附件为测试文件&#39;&#39;&#39;+current_date# 正文内容+当前日期

    addrBook&#x3D;r&#39;D:\邮箱联系人表单.csv&#39;  #联系人表单文件路径
    addrs&#x3D;getAddrBook(addrBook)
    for i in addrs:
        attachfilename&#x3D;i+&#39;.xlsx&#39; #将要发送的文件添加为附件
        recipientAddrs&#x3D;addrs[i] #接收人的邮箱地址
        result &#x3D; os.path.exists(inputpath+i+&#39;.xlsx&#39;) #判断当前目录是否存在该文件
        if result:
            #存在就执行邮件
            send_email(inputpath,smtpHost,port,sendAddr,password,recipientAddrs,
            subject,content,attachfilename)
            print ((&#39;发给 %s 的邮件执行成功&#39;) %(recipientAddrs))
</code></pre></li>
</ul>
<p>这里也看到有使用126邮箱的smtp服务器：’smtp.126.com’<br><a href="https://blog.csdn.net/weixin_42350212/article/details/118751583">https://blog.csdn.net/weixin_42350212/article/details/118751583</a><br>Python smtp发送邮件怎么设置抄送人<br><a href="https://www.cnblogs.com/shiyixirui/p/14692146.html">https://www.cnblogs.com/shiyixirui/p/14692146.html</a></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>自动化</tag>
      </tags>
  </entry>
  <entry>
    <title>python实现鼠标键盘自动化——pyautogui、opencv</title>
    <url>//post/python%E5%AE%9E%E7%8E%B0%E9%BC%A0%E6%A0%87%E9%94%AE%E7%9B%98%E8%87%AA%E5%8A%A8%E5%8C%96.html</url>
    <content><![CDATA[<h1 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h1><p>总的来说这是一个通过个人自定义流程，在python环境下通过自定义鼠标键盘操作来实现自动化办公的RPA工具~</p>
<h2 id="所需环境："><a href="#所需环境：" class="headerlink" title="所需环境："></a>所需环境：</h2><p>pip install -i <a href="https://pypi.tuna.tsinghua.edu.cn/simple">https://pypi.tuna.tsinghua.edu.cn/simple</a> pyperclip 回车</p>
<p>pip install -i <a href="https://pypi.tuna.tsinghua.edu.cn/simple">https://pypi.tuna.tsinghua.edu.cn/simple</a> xlrd 回车</p>
<p>pip install -i <a href="https://pypi.tuna.tsinghua.edu.cn/simple">https://pypi.tuna.tsinghua.edu.cn/simple</a> pyautogui==0.9.50 回车</p>
<p>pip install -i <a href="https://pypi.tuna.tsinghua.edu.cn/simple">https://pypi.tuna.tsinghua.edu.cn/simple</a> opencv-python 回车</p>
<p>pip install -i <a href="https://pypi.tuna.tsinghua.edu.cn/simple">https://pypi.tuna.tsinghua.edu.cn/simple</a> pillow 回车</p>
<h1 id="初始化操作"><a href="#初始化操作" class="headerlink" title="初始化操作"></a>初始化操作</h1><pre class="line-numbers language-python" data-language="python"><code class="language-python">import pyautogui
import xlrd
import pyperclip
import time
import os
import shutil
import sys

# pyautogui.PAUSE &#x3D; 1 # 调用在执行动作后暂停的秒数，只能在执行一些pyautogui动作后才能使用，建议用time.sleep
pyautogui.FAILSAFE &#x3D; False # 启用自动防故障功能，左上角的坐标为（0，0），将鼠标移到屏幕的左上角，来抛出failSafeException异常

def resource_path(relative_path):
    if getattr(sys, &#39;frozen&#39;, False):  # 是否Bundle Resource
        base_path &#x3D; sys._MEIPASS
    else:
        base_path &#x3D; os.path.abspath(&quot;.&quot;)
    return os.path.join(base_path, relative_path)

def ClearTemp():
    MEIpath &#x3D; &quot;C:\\Users\\&quot; + os.getlogin() + &quot;\\AppData\\Local\\Temp&quot;
    # mylog(&quot;当前临时文件位置&quot;, MEIpath)
    # print(os.getlogin()) #获取计算机使用对象
    for root, dirs, files in os.walk(MEIpath):
        if &quot;_MEI&quot; in root:
            try:
                print(&quot;正在清理:&quot;,root)
                shutil.rmtree(root)
            except:
                pass
        else:
            pass
</code></pre>

<h1 id="定义鼠标事件"><a href="#定义鼠标事件" class="headerlink" title="定义鼠标事件"></a>定义鼠标事件</h1><pre class="line-numbers language-python" data-language="python"><code class="language-python"># pyautogui库其他用法 https:&#x2F;&#x2F;blog.csdn.net&#x2F;qingfengxd1&#x2F;article&#x2F;details&#x2F;108270159
def mouseClick(clickTimes, lOrR, img, reTry,fail_retry,retry_interval):
    try:
        time.sleep(retry_interval&#x2F;1000000)
        fail_retry &#x3D; int(fail_retry)
    except:
        fail_retry&#x3D;10
        retry_interval&#x3D;0.1
    f &#x3D; open(f&quot;日志文件\&#123;time.strftime(&#39;%Y-%m-%d&#39;, time.localtime())&#125;.txt&quot;,&quot;a+&quot;)
    global pic_exist
    pic_exist&#x3D; False
    if reTry &#x3D;&#x3D; 1:
        fail_retry_num&#x3D; 1
        while True:
            location &#x3D; pyautogui.locateCenterOnScreen(img, confidence&#x3D;0.98)
            if location is not None:
                pyautogui.click(location.x, location.y, clicks&#x3D;clickTimes, interval&#x3D;0.2, duration&#x3D;0.2, button&#x3D;lOrR)
                break

            print(f&quot;未找到匹配图片&#123;img&#125;,我将在&#123;retry_interval&#125;秒后重试&quot;)
            f.write(f&quot;未找到匹配图片&#123;img&#125;,我将在&#123;retry_interval&#125;秒后重试\n&quot;)
            time.sleep(retry_interval)
            fail_retry_num+&#x3D;1
            if fail_retry_num&gt;fail_retry:
                print(f&quot;已重试&#123;fail_retry&#125;次&quot;)
                f.write(f&quot;已重试&#123;fail_retry&#125;次\n&quot;)
                pic_exist &#x3D; True
                break
    elif reTry &#x3D;&#x3D; -1:
        #不建议这么搞
        fail_retry_num&#x3D;1
        while True:
            location &#x3D; pyautogui.locateCenterOnScreen(img, confidence&#x3D;0.98)
            if location is not None:
                pyautogui.click(location.x, location.y, clicks&#x3D;clickTimes, interval&#x3D;0.2, duration&#x3D;0.2, button&#x3D;lOrR)
            else:
                print(f&quot;未找到匹配图片&#123;img&#125;,我将在&#123;retry_interval&#125;秒后重试&quot;)
                f.write(f&quot;未找到匹配图片&#123;img&#125;,我将在&#123;retry_interval&#125;秒后重试\n&quot;)
    
            time.sleep(retry_interval)
            fail_retry_num +&#x3D; 1
            if fail_retry_num &gt; fail_retry:
                print(f&quot;已重试&#123;fail_retry&#125;次，无限重复且找不到图,你这是在玩火啊！&quot;)
                f.write(f&quot;已重试&#123;fail_retry&#125;次，无限重复且找不到图!你这是在玩火啊！\n&quot;)
                pic_exist &#x3D; True
                break


    elif reTry &gt; 1:
        i &#x3D; 1
        fail_retry_num&#x3D;1
        while i &lt; reTry + 1:
            location &#x3D; pyautogui.locateCenterOnScreen(img, confidence&#x3D;0.98)
            if location is not None:
                pyautogui.click(location.x, location.y, clicks&#x3D;clickTimes, interval&#x3D;0.2, duration&#x3D;0.2, button&#x3D;lOrR)
                print(&quot;重复&quot;)
                i +&#x3D; 1
            else:
                print(f&quot;未找到匹配图片&#123;img&#125;,我将在&#123;retry_interval&#125;秒后重试&quot;)
                f.write(f&quot;未找到匹配图片&#123;img&#125;,我将在&#123;retry_interval&#125;秒后重试\n&quot;)
            time.sleep(retry_interval)
            fail_retry_num +&#x3D; 1
            if fail_retry_num &gt; fail_retry:
                print(f&quot;已重试&#123;fail_retry&#125;次&quot;)
                f.write(f&quot;已重试&#123;fail_retry&#125;次\n&quot;)
                pic_exist &#x3D; True
                break</code></pre>

<h1 id="定义热键事件"><a href="#定义热键事件" class="headerlink" title="定义热键事件"></a>定义热键事件</h1><pre class="line-numbers language-python" data-language="python"><code class="language-python"># hotkey_get方法用来判断热键组合个数,还是文字输入。此方法由B站up主 尔茄无双 提供。
def hotkey_get(hk_g_inputValue):
    try:
        newinput &#x3D; hk_g_inputValue.split(&#39;,&#39;)
        pyautogui.hotkey(*tuple(newinput))
    except:
        pyperclip.copy(hk_g_inputValue)
        pyautogui.hotkey(&#39;ctrl&#39;, &#39;v&#39;)</code></pre>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"># hotkey_get方法用来判断热键组合个数，并把热键传到对应的变量上newinput[0],[1],[2],[3]……[9]只写了10个后续可以添加。【老方法弃用】
# newinput &#x3D; hk_g_inputValue.split(&#39;,&#39;)
#         if len(newinput)&#x3D;&#x3D;1:
#                 pyautogui.hotkey(hk_g_inputValue)
#         elif len(newinput)&#x3D;&#x3D;2:
#                 pyautogui.hotkey(newinput[0],newinput[1])
#         elif len(newinput)&#x3D;&#x3D;3:
#                 pyautogui.hotkey(newinput[0],newinput[1],newinput[2])
#         elif len(newinput)&#x3D;&#x3D;4:
#                 pyautogui.hotkey(newinput[0],newinput[1],newinput[2],newinput[3])
#         elif len(newinput)&#x3D;&#x3D;4:
#                     pyautogui.hotkey(newinput[0],newinput[1],newinput[2],newinput[3])
#         elif len(newinput)&#x3D;&#x3D;5:
#                     pyautogui.hotkey(newinput[0],newinput[1],newinput[2],newinput[3],newinput[4])
#         elif len(newinput)&#x3D;&#x3D;6:
#                     pyautogui.hotkey(newinput[0],newinput[1],newinput[2],newinput[3],newinput[4],newinput[5])
#         elif len(newinput)&#x3D;&#x3D;7:
#                     pyautogui.hotkey(newinput[0],newinput[1],newinput[2],newinput[3],newinput[4],newinput[5],newinput[6])
#         elif len(newinput)&#x3D;&#x3D;8:
#                     pyautogui.hotkey(newinput[0],newinput[1],newinput[2],newinput[3],newinput[4],newinput[5],newinput[6],newinput[7])
#         elif len(newinput)&#x3D;&#x3D;9:
#                     pyautogui.hotkey(newinput[0],newinput[1],newinput[2],newinput[3],newinput[4],newinput[5],newinput[6],newinput[7],newinput[8])
#         elif len(newinput)&#x3D;&#x3D;10:
#                     pyautogui.hotkey(newinput[0],newinput[1],newinput[2],newinput[3],newinput[4],newinput[5],newinput[6],newinput[7],newinput[8],newinput[9])

# hotkey_Group方法调用hotkey_get方法，并判断其热键内容是否需要循环。</code></pre>
<p>#键盘热键</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">def hotkeyGroup(reTry, hkg_inputValue):
    if reTry &#x3D;&#x3D; 1:
        hotkey_get(hkg_inputValue)
        print(&quot;执行了：&quot;, hkg_inputValue)
        time.sleep(0.1)
    elif reTry &#x3D;&#x3D; -1:
        while True:
            hotkey_get(hkg_inputValue)
            print(&quot;执行了：&quot;, hkg_inputValue)
            time.sleep(0.1)
    elif reTry &gt; 1:
        i &#x3D; 1
        while i &lt; reTry + 1:
            hotkey_get(hkg_inputValue)
            print(&quot;执行了：&quot;, hkg_inputValue)
            i +&#x3D; 1
            time.sleep(0.1)</code></pre>

<h1 id="数据检查"><a href="#数据检查" class="headerlink" title="数据检查"></a>数据检查</h1><pre class="line-numbers language-python" data-language="python"><code class="language-python"># cmdType.value  1.0 左键单击    2.0 左键双击  3.0 右键单击  4.0 输入  5.0 等待  6.0 滚轮
# 7.0 热键组合（最多4个）
# 8.0 粘贴当前时间
# 9.0 系统命令集
# ctype     空：0
#           字符串：1
#           数字：2
#           日期：3
#           布尔：4
#           error：5
def dataCheck(sheet1):
    checkCmd &#x3D; True
    # 行数检查
    if sheet1.nrows &lt; 2:
        print(&quot;没数据啊哥&quot;)
        checkCmd &#x3D; False
    # 每行数据检查
    i &#x3D; 1
    while i &lt; sheet1.nrows:
        # 第1列 操作类型检查
        cmdType &#x3D; sheet1.row(i)[0]
        if cmdType.ctype !&#x3D; 2 or (cmdType.value !&#x3D; 1.0 and cmdType.value !&#x3D; 2.0 and cmdType.value !&#x3D; 3.0
                                  and cmdType.value !&#x3D; 4.0 and cmdType.value !&#x3D; 5.0 and cmdType.value !&#x3D; 6.0
                                  and cmdType.value !&#x3D; 7.0 and cmdType.value !&#x3D; 8.0 and cmdType.value !&#x3D; 9.0):
            print(&#39;第&#39;, i + 1, &quot;行,第1列数据有毛病&quot;)
            checkCmd &#x3D; False
        # 第2列 内容检查
        cmdValue &#x3D; sheet1.row(i)[1]
        # 读图点击类型指令，内容必须为字符串类型
        if cmdType.value &#x3D;&#x3D; 1.0 or cmdType.value &#x3D;&#x3D; 2.0 or cmdType.value &#x3D;&#x3D; 3.0:
            if cmdValue.ctype !&#x3D; 1:
                print(&#39;第&#39;, i + 1, &quot;行,第2列数据有毛病&quot;)
                checkCmd &#x3D; False
        # 输入类型，内容不能为空
        if cmdType.value &#x3D;&#x3D; 4.0:
            if cmdValue.ctype &#x3D;&#x3D; 0:
                print(&#39;第&#39;, i + 1, &quot;行,第2列数据有毛病&quot;)
                checkCmd &#x3D; False
        # 等待类型，内容必须为数字
        if cmdType.value &#x3D;&#x3D; 5.0:
            if cmdValue.ctype !&#x3D; 2:
                print(&#39;第&#39;, i + 1, &quot;行,第2列数据有毛病&quot;)
                checkCmd &#x3D; False
        # 滚轮事件，内容必须为数字
        if cmdType.value &#x3D;&#x3D; 6.0:
            if cmdValue.ctype !&#x3D; 2:
                print(&#39;第&#39;, i + 1, &quot;行,第2列数据有毛病&quot;)
                checkCmd &#x3D; False
        # 7.0 热键组合，内容不能为空
        if cmdType.value &#x3D;&#x3D; 7.0:
            if cmdValue.ctype &#x3D;&#x3D; 0:
                print(&#39;第&#39;, i + 1, &quot;行,第2列数据有毛病&quot;)
                checkCmd &#x3D; False
        # 8.0 时间，内容不能为空
        if cmdType.value &#x3D;&#x3D; 8.0:
            if cmdValue.ctype &#x3D;&#x3D; 0:
                print(&#39;第&#39;, i + 1, &quot;行,第2列数据有毛病&quot;)
                checkCmd &#x3D; False
        # 9.0 系统命令集模式，内容不能为空
        if cmdType.value &#x3D;&#x3D; 9.0:
            if cmdValue.ctype &#x3D;&#x3D; 0:
                print(&#39;第&#39;, i + 1, &quot;行,第2列数据有毛病&quot;)
                checkCmd &#x3D; False
        i +&#x3D; 1
    return checkCmd</code></pre>

<h1 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h1><pre class="line-numbers language-python" data-language="python"><code class="language-python">def mainWork(img):
    # cur_path &#x3D; os.getcwd()
    i &#x3D; 1
    f &#x3D; open(f&quot;日志文件\&#123;time.strftime(&#39;%Y-%m-%d&#39;, time.localtime())&#125;.txt&quot;,&quot;a+&quot;)
    # f.write(f&quot;\n当前时间：&#123;time.strftime(&#39;%Y-%m-%d %H:%M:%S&#39;, time.localtime())&#125;\n&quot;)
    while i &lt; sheet1.nrows:
        try:
            # 取本行指令的操作类型
            cmdType &#x3D; sheet1.row(i)[0]

            if cmdType.value &#x3D;&#x3D; 1.0:
                # 取图片名称
                img &#x3D; sheet1.row(i)[1].value
                reTry &#x3D; 1# 取重试次数
                fail_retry &#x3D;sheet1.row(i)[3].value # 取查找图片失败重试次数
                retry_interval &#x3D; sheet1.row(i)[4].value #取重试间隔
                if sheet1.row(i)[2].ctype &#x3D;&#x3D; 2 and sheet1.row(i)[2].value !&#x3D; 0:
                    reTry &#x3D; sheet1.row(i)[2].value
                mouseClick(1, &quot;left&quot;, img, reTry,fail_retry,retry_interval)
                if sheet1.row(i)[5].value&#x3D;&#x3D;1:
                    print(f&quot;第&#123;i&#125;步，查找&#123;img&#125;超时将跳过\n&quot;)
                    f.write(f&quot;第&#123;i&#125;步，查找&#123;img&#125;超时将跳过\n&quot;)
                    pass
                else:
                    if pic_exist:
                        #查找图片已超时
                        print(f&quot;第&#123;i&#125;步，查找&#123;img&#125;超时将终止\n&quot;)
                        f.write(f&quot;第&#123;i&#125;步，查找&#123;img&#125;超时将终止\n&quot;)
                        break
                    else:
                        #查找未超时
                        f.write(f&quot;第&#123;i&#125;步，单击左键&#123;reTry&#125;次，&#123;img&#125;\n&quot;)
                print(&quot;单击左键&quot;, img)
    
            # 2代表双击左键
            elif cmdType.value &#x3D;&#x3D; 2.0:
                # 取图片名称
                img &#x3D; sheet1.row(i)[1].value
                # 取重试次数
                reTry &#x3D; 1
                fail_retry &#x3D; sheet1.row(i)[3].value  # 取查找图片失败重试次数
                retry_interval &#x3D; sheet1.row(i)[4].value  # 取重试间隔
    
                if sheet1.row(i)[2].ctype &#x3D;&#x3D; 2 and sheet1.row(i)[2].value !&#x3D; 0:
                    reTry &#x3D; sheet1.row(i)[2].value
                mouseClick(2, &quot;left&quot;, img, reTry,fail_retry,retry_interval)
                if sheet1.row(i)[5].value&#x3D;&#x3D;1:
                    print(f&quot;第&#123;i&#125;步，查找&#123;img&#125;超时将跳过\n&quot;)
                    f.write(f&quot;第&#123;i&#125;步，查找&#123;img&#125;超时将跳过\n&quot;)
                    pass
                else:
                    if pic_exist:
                        #查找图片已超时
                        print(f&quot;第&#123;i&#125;步，查找&#123;img&#125;超时将终止\n&quot;)
                        f.write(f&quot;第&#123;i&#125;步，查找&#123;img&#125;超时将终止\n&quot;)
                        break
                    else:
                        #查找未超时
                        f.write(f&quot;第&#123;i&#125;步，双击左键&#123;reTry&#125;次，&#123;img&#125;\n&quot;)
                print(&quot;双击左键&quot;, img)
                # f.write(f&quot;第&#123;i&#125;步，双击左键&#123;reTry&#125;次，&#123;img&#125;\n&quot;)
            # 3代表右键
            elif cmdType.value &#x3D;&#x3D; 3.0:
                # 取图片名称
                img &#x3D; sheet1.row(i)[1].value
                # 取重试次数
                reTry &#x3D; 1
                fail_retry &#x3D; sheet1.row(i)[3].value  # 取查找图片失败重试次数
                retry_interval &#x3D; sheet1.row(i)[4].value  # 取重试间隔
    
                if sheet1.row(i)[2].ctype &#x3D;&#x3D; 2 and sheet1.row(i)[2].value !&#x3D; 0:
                    reTry &#x3D; sheet1.row(i)[2].value
                mouseClick(1, &quot;right&quot;, img, reTry,fail_retry,retry_interval)
                if sheet1.row(i)[5].value &#x3D;&#x3D; 1:
                    print(f&quot;第&#123;i&#125;步，查找&#123;img&#125;超时将跳过\n&quot;)
                    f.write(f&quot;第&#123;i&#125;步，查找&#123;img&#125;超时将跳过\n&quot;)
                    pass
                else:
                    if pic_exist:
                        # 查找图片已超时
                        print(f&quot;第&#123;i&#125;步，查找&#123;img&#125;超时将终止\n&quot;)
                        f.write(f&quot;第&#123;i&#125;步，查找&#123;img&#125;超时将终止\n&quot;)
                        break
                    else:
                        #查找未超时
                        f.write(f&quot;第&#123;i&#125;步，单击右键&#123;reTry&#125;次，&#123;img&#125;\n&quot;)
                print(&quot;右键&quot;, img)
                # f.write(f&quot;第&#123;i&#125;步，单击右键&#123;reTry&#125;次，&#123;img&#125;\n&quot;)
                # 4代表输入
            elif cmdType.value &#x3D;&#x3D; 4.0:
                inputValue &#x3D; sheet1.row(i)[1].value
                pyperclip.copy(inputValue)
                pyautogui.hotkey(&#39;ctrl&#39;, &#39;v&#39;)
                print(f&quot;第&#123;i&#125;步，输入&#123;inputValue&#125;&quot;)
                f.write(f&quot;第&#123;i&#125;步，输入&#123;inputValue&#125;\n&quot;)
                time.sleep(0.5)
            # 5代表等待
            elif cmdType.value &#x3D;&#x3D; 5.0:
                #取等待时间
                waitTime &#x3D; sheet1.row(i)[1].value
                time.sleep(waitTime)
                print(f&quot;第&#123;i&#125;步，等待&quot;, waitTime, &quot;秒&quot;)
                f.write(f&quot;第&#123;i&#125;步，等待&#123;waitTime&#125;秒\n&quot;)
            # 6代表滚轮
            elif cmdType.value &#x3D;&#x3D; 6.0:
                #取滚动距离
                scroll &#x3D; sheet1.row(i)[1].value
                pyautogui.scroll(int(scroll))
                print(f&quot;第&#123;i&#125;步，滚轮滑动,&#123;int(scroll)&#125;, 距离&quot;)
                f.write(f&quot;第&#123;i&#125;步，滚轮滑动&#123;int(scroll)&#125;距离\n&quot;)
            # 7代表_热键组合
            elif cmdType.value &#x3D;&#x3D; 7.0:
                # 取重试次数,并循环。
                reTry &#x3D; 1
                if sheet1.row(i)[2].ctype &#x3D;&#x3D; 2 and sheet1.row(i)[2].value !&#x3D; 0:
                    reTry &#x3D; sheet1.row(i)[2].value
                inputValue &#x3D; sheet1.row(i)[1].value
                hotkeyGroup(reTry, inputValue)
                print(f&quot;第&#123;i&#125;步，执行了&#123;reTry&#125;次热键组合&#123;inputValue&#125;&quot;)
                f.write(f&quot;第&#123;i&#125;步，执行了&#123;reTry&#125;次热键组合&#123;inputValue&#125;\n&quot;)
                time.sleep(0.5)
            # 8代表_粘贴当前时间
            elif cmdType.value &#x3D;&#x3D; 8.0:
                # 设置本机当前时间。
                localtime &#x3D; time.strftime(&quot;%Y-%m-%d %H：%M：%S&quot;, time.localtime())
                pyperclip.copy(localtime)
                pyautogui.hotkey(&#39;ctrl&#39;, &#39;v&#39;)
                print(f&quot;第&#123;i&#125;步，粘贴了本机时间:&quot;, localtime)
                f.write(f&quot;第&#123;i&#125;步，粘贴了本机时间: &#123;localtime&#125;\n&quot;)
                time.sleep(0.5)
            # 9代表_系统命令集模式
            elif cmdType.value &#x3D;&#x3D; 9.0:
                wincmd &#x3D; sheet1.row(i)[1].value
                os.system(wincmd)
                print(f&quot;第&#123;i&#125;步，运行系统命令:&quot;, wincmd)
                f.write(f&quot;第&#123;i&#125;步，运行系统命令 &#123;wincmd&#125;\n&quot;)
                time.sleep(0.5)
    
        except Exception as error:
            print(f&quot;执行第&#123;i&#125;条步骤发生报错&#123;error&#125;,将中断当前流程，请解决错误后重新执行！&quot;)
            f.write(f&quot;执行第&#123;i&#125;条步骤发生报错:\n&#123;error&#125;,\n将中断当前流程，请解决错误后重新执行！\n&quot;)
            # time.sleep(10)
            break
        i +&#x3D; 1
    #关闭日志文件
    f.write(f&quot;当前时间：&#123;time.strftime(&#39;%Y-%m-%d %H:%M:%S&#39;, time.localtime())&#125;\n&quot;)
    f.write(&quot;-----------本次流程执行日志记录完毕-----------\n&quot;)
    f.close()</code></pre>

<h1 id="主程序"><a href="#主程序" class="headerlink" title="主程序"></a>主程序</h1><pre class="line-numbers language-python" data-language="python"><code class="language-python">while True:
    if __name__ &#x3D;&#x3D; &#39;__main__&#39;:
        file &#x3D; &#39;cmd.xls&#39;
        # 打开文件
        wb &#x3D; xlrd.open_workbook(filename&#x3D;file)
        print(&#39;-----欢迎使用傻妞RPA~-----\n&#39;)
        try:
            sheet_names &#x3D; wb.sheet_names()
            sheet_name &#x3D; input(f&#39;请准确输入自动化流程sheet表名或位置序号(从1开始):  (输入0直接退出)\n现有的sheet表名称有：&#39;
                               f&#39;&#123;sheet_names&#125;\nPS：执行包含“-0“的流程完毕后会自动退出\n———————————————————————————————————————\n&#39;)
            if sheet_name&#x3D;&#x3D; &#39;0&#39;:
                print(&quot;正清理缓存文件...&quot;)
                # os.system(&#39;@echo off &amp; for &#x2F;d %i in (%temp%\^_MEI*) do (rd &#x2F;s &#x2F;q &quot;%i&quot;)&gt;nul&#39;)
                ClearTemp()
                # exit(&quot;正在退出程序...&quot;)
                break
            elif type(int(sheet_name))&#x3D;&#x3D;int:
                sheet_name &#x3D; sheet_names[int(sheet_name)-1]

            # 通过索引获取表格sheet页
            sheet1 &#x3D; wb.sheet_by_name(sheet_name)  # 这里选择你配置的工作表名称
            f &#x3D; open(f&quot;日志文件\&#123;time.strftime(&#39;%Y-%m-%d&#39;, time.localtime())&#125;.txt&quot;,&quot;a+&quot;)
            f.write(f&quot;\n当前时间：&#123;time.strftime(&#39;%Y-%m-%d %H:%M:%S&#39;, time.localtime())&#125;，即开始执行流程——&#123;sheet_name&#125;\n&quot;)
            f.close()
        except Exception as e:
            print(e,&quot;\nsheet名输错了,没这个文件啊，重新输入吧(输入0可直接退出)\n&quot;)
            continue
        # 避免多次循环导致的ctrl+v导入到，按ESC进行取消。
        pyautogui.hotkey(&#39;esc&#39;)
        # 数据检查
        checkCmd &#x3D; dataCheck(sheet1)
    
        # 输入选项实现功能
        if checkCmd:
            key &#x3D; input(f&#39;即将开始执行流程：&#123;sheet_name&#125;\n选择功能: 1.做一次 2.循环几次 0.退出程序\n特殊功能：c.清理屏幕显示（请输入后最小化当前页面）\n———————————————————————————————————————\n&#39;)
            if key &#x3D;&#x3D; &#39;1&#39; or key &#x3D;&#x3D;&quot;&quot;:
                # 循环拿出每一行指令
                print(&quot;正在执行第1次流程\n&quot;)
                mainWork(sheet1)
                print(&quot;本次命令执行完了.&quot;)
                print(&quot;正清理缓存文件...&quot;)
                ClearTemp()
                # os.system(&#39;@echo off &amp; for &#x2F;d %i in (%temp%\^_MEI*) do (rd &#x2F;s &#x2F;q &quot;%i&quot;)&gt;nul&#39;)
                # exit(&quot;正在退出程序...快去成为你想要的样子！&quot;)
                print(&quot;清理缓存完毕，快去成为你想要的样子！&quot;)
                print(&quot;——————————————————分割线——————————————————&quot;)
                if &quot;-0&quot; in sheet_name:
                    print(&quot;正清理缓存文件...&quot;)
                    # os.system(&#39;@echo off &amp; for &#x2F;d %i in (%temp%\^_MEI*) do (rd &#x2F;s &#x2F;q &quot;%i&quot;)&gt;nul&#39;)
                    ClearTemp()
                    exit(&quot;正在退出程序...&quot;)
    
            elif key &#x3D;&#x3D; &#39;2&#39;:
                print(&quot;&quot;)
                count &#x3D; 0
                times &#x3D; input(&#39;想要执行几次呢? 最高执行10次喔\n&#39;)
                times &#x3D; int(times)
                if count &lt; times and times&lt;&#x3D;10:
                    while count &lt; times:
                        count +&#x3D; 1
                        print(&quot;正在执行第&quot;, count, &quot;次流程&quot;)
                        mainWork(sheet1)
                        time.sleep(0.1)
                        print(&quot;等待0.1秒&quot;)
                        print(&quot;已经完成第&quot;, count, &quot;次&quot;, &quot;命令&quot;)
                        print(&quot;——————————————————分割线——————————————————&quot;)
                if &quot;-0&quot; in sheet_name:
                    print(&quot;正清理缓存文件...&quot;)
                    # os.system(&#39;@echo off &amp; for &#x2F;d %i in (%temp%\^_MEI*) do (rd &#x2F;s &#x2F;q &quot;%i&quot;)&gt;nul&#39;)
                    ClearTemp()
                    exit(&quot;正在退出程序...&quot;)
                else:
                    print(&#39;输入有误或者已经退出!&#39;)
                    os.system(&#39;pause&#39;)
                    print(&quot;——————————————————————————————————————————&quot;)
    
            # elif key &#x3D;&#x3D; &#39;3&#39;:
            #     count &#x3D; 0
            #     while True:
            #         count +&#x3D; 1
            #         print(&quot;正在执行第&quot;, count, &quot;次&quot;, &quot;命令&quot;)
            #         print(&quot;&quot;)
            #         mainWork(sheet1)
            #         time.sleep(0.1)
            #         print(&quot;等待0.1秒&quot;)
            #         print(&quot;&quot;)
            #         print(&quot;已经完成第&quot;, count, &quot;次&quot;, &quot;命令&quot;)
            #         print(&quot;——————————————————分割线——————————————————&quot;)
            #         print(&quot;&quot;)
    
            elif key &#x3D;&#x3D; &#39;0&#39;:
                print(&quot;正清理缓存文件...&quot;)
                # os.system(&#39;@echo off &amp; for &#x2F;d %i in (%temp%\^_MEI*) do (rd &#x2F;s &#x2F;q &quot;%i&quot;)&gt;nul&#39;)
                ClearTemp()
                exit(&quot;正在退出程序...&quot;)
    
            elif key &#x3D;&#x3D; &#39;c&#39;:
                os.system(&#39;cls&#39;)
    
            else:
                print(&#39;输入有误或者已经退出!&#39;)
                os.system(&#39;pause&#39;)
                print(&quot;——————————————————————————————————————————&quot;)</code></pre>

<h1 id="大致的操作说明"><a href="#大致的操作说明" class="headerlink" title="大致的操作说明"></a>大致的操作说明</h1><p>\1.   双击exe文件执行开始时请输入表名称；按照提示输入后回车即可；在cmd.xls 的每个sheet中，一个sheet对应一个自动化流程，自己新建命名即可配置每一步的指令，如：</p>
<p>\2.   指令类型1、2、3是操作鼠标单击、双击、右击，对应的内容在第二列填 截图文件路径（例如“./pic/chrome.png”；这里最前面有个点别忘了），把每一步要操作的图标、区域截图保存至pics文件夹图片为png格式，截图名称必须为英文，中文不行。（注意：如果同屏有多个相同图标，会默认找到最左上的一个，因此怎么截图，截多大的区域，是个学问，如输入框只截中间空白部分肯定是不行的，宗旨就是“唯一”）</p>
<p>\3.   指令5是等待时长（单位秒） ，建议每配置一步都加上一定等待时间，否则可能会容易卡顿；</p>
<p>\4.   指令6是滚轮的距离，正数表示向上滚，负数表示向下滚，滚动距离不确定的话可自己进行测试，可从50或100开始；</p>
<p>\5.   指令4是输入，实际实现逻辑为复制粘贴，会占用粘贴板资源。</p>
<p>\6.   指令7是热键，第二列将需要的组合的热键以英文半角逗号（”,”）分隔填写即可。例如：win,r,ctrl,shift,esc,1,2,3,4,del（del删除这类热键要慎用）</p>
<p>当然单个的按键也是可以，单个按键时后面必须加”,” (例如：9, 按一下9这个键。)注意：英文中的逗号”,”无法作为热键被单独被识别，原因是这个符号被用来分隔其他按键组合了。</p>
<p>\7.   第三列，重复次数；不填写则默认为执行1次，填写的话只能填写正整数，-1为无限循环；目前重复次数仅支持 第一列为 1,2,3,7 的指令（分别为：鼠标单击，双击，右键，热键组合。）但不建议填-1可能会卡死喔。</p>
<p>\8.   第四列，失败重试次数（正整数，否则默认重试10次）</p>
<p>\9.   第五列，重试间隔（秒，默认间隔0.1秒）</p>
<p>\10. 第六列，失败后是否跳过（为1将跳过，其他或不填将中断；仅对指令1/2/3生效）</p>
<p>\11. 指令8是本机时间粘贴，获取当前系统时间。此指令也会使用粘贴板，实际为复制粘贴。第一列填写8，第二列<strong>填写</strong>“当前时间”（一定要填写，否者不执行），第三列重复次数无效。</p>
<p>\12. 指令9是执行系统指令，第二列填写系统指令，第三列重复次数无效。</p>
<p>例如：start c:（在新窗口中打开C盘）；start cmd （打开CMD程序）</p>
<p>\13. 开始程序后请将程序框最小化，不然程序框挡住的区域是无法识别和操作的。</p>
<p>\14. 双击exe文件打开程序（目前只能win10/11使用，<strong>如果<strong><strong>win7</strong></strong>使用报错：需要安装<strong><strong>kb2533623</strong></strong>补丁，这里不提供。</strong>），根据提示输入相关指令后敲回车；如果不能运行或者开始后立马关闭；说明流程有问题，可检查cmd表格文件中的数据是否有错；一般都是图片路径填写错误，指令数据填写错误这类问题；如果实在无法解决那就关掉吧~</p>
<p>\15. 执行开始时或完毕后都会有退出选项；尽量使用这个选项（输入0之后回车）退出程序，（可以避免出现exe执行文件会产生临时文件，长久累积可能会占满C盘（这是python可执行文件的一个特性））；如果程序开始后因为你选择了多次重复而键鼠被占用但是想要停下来，关闭Dos控制台即可。点击右上角的x 或者ctrl+c或者alt+F4 都可以。</p>
<p>代码参考B站大佬（不高兴就喝水）的源码 进行二次开发，加入查找失败重试，超时查找，快捷键组合，dos命令，实时日志记录等功能；（有些自动化操作受windows系统安全限制可能会失效，这里不一一列举了）一直想做个图形化界面客户端，还有些地方没有打通。。。</p>
<p><a href="https://www.bilibili.com/video/BV1T34y1o73U?spm_id_from=333.999.0.0">https://www.bilibili.com/video/BV1T34y1o73U?spm_id_from=333.999.0.0</a></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>自动化</tag>
      </tags>
  </entry>
  <entry>
    <title>python常用功能代码整理，持续更新</title>
    <url>//post/python%E5%B8%B8%E7%94%A8%E5%8A%9F%E8%83%BD%E4%BB%A3%E7%A0%81%E6%95%B4%E7%90%86%EF%BC%8C%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0.html</url>
    <content><![CDATA[<p>部分参考，实测后有改动<br><a href="https://mp.weixin.qq.com/s/A0NYVPaNclMkKgie2swClw">https://mp.weixin.qq.com/s/A0NYVPaNclMkKgie2swClw</a></p>
<h1 id="【python】如何提取本机连接过的wifi密码（亲测好用"><a href="#【python】如何提取本机连接过的wifi密码（亲测好用" class="headerlink" title="【python】如何提取本机连接过的wifi密码（亲测好用"></a>【python】如何提取本机连接过的wifi密码（亲测好用</h1><pre class="line-numbers language-python" data-language="python"><code class="language-python">import subprocess
# 获取wifi列表
output &#x3D; subprocess.run([&#39;netsh&#39;,&#39;wlan&#39;,&#39;show&#39;,&#39;profiles&#39;],capture_output &#x3D; True).stdout.decode(&#39;gbk&#39;).split(&#39;\n&#39;)
wifis &#x3D; [line.split(&#39;:&#39;)[1][1:-1] for line in output if &quot;所有用户配置文件&quot; in line]

#查看每个wifi对应的密码
for wifi in wifis:
    results &#x3D; subprocess.run([&#39;netsh&#39;,&#39;wlan&#39;,&#39;show&#39;,&#39;profile&#39;,wifi,&#39;key&#x3D;clear&#39;],capture_output &#x3D; True).stdout.decode(&#39;gbk&#39;,errors &#x3D; &#39;ignore&#39;).split(&#39;\n&#39;)
    results &#x3D; [line.split(&#39;:&#39;)[1][1:-1] for line in results if &quot;关键内容&quot; in line]
    try:
        print(f&#39;wifi账号：&#123;wifi&#125;，密码:&#123;results[0]&#125;&#39;)
    except IndexError:
        print(f&#39;wifi账号：&#123;wifi&#125;，密码:提取失败！&#39;)
</code></pre>

<h1 id="本地文件整理-将本地多个-CSV-文件整合成一个文件"><a href="#本地文件整理-将本地多个-CSV-文件整合成一个文件" class="headerlink" title="本地文件整理   将本地多个 CSV 文件整合成一个文件"></a>本地文件整理   将本地多个 CSV 文件整合成一个文件</h1><pre class="line-numbers language-python" data-language="python"><code class="language-python">import pandas as pd
import os

df_list &#x3D; []
for i in os.listdir():
    if &quot;csv&quot; in i:
        day &#x3D; i.split(&#39;.&#39;)[0].split(&#39;_&#39;)[-1]
        df &#x3D; pd.read_csv(i)
        df[&#39;day&#39;] &#x3D; day
        df_list.append(df)
df &#x3D; pd.concat(df_list, axis&#x3D;0)
df.to_csv(&quot;total.txt&quot;, index&#x3D;0)</code></pre>

<h1 id="多线程代码"><a href="#多线程代码" class="headerlink" title="多线程代码"></a>多线程代码</h1><pre class="line-numbers language-python" data-language="python"><code class="language-python">import threading
import time

exitFlag &#x3D; 0

class myThread (threading.Thread):
    def __init__(self, threadID, name, delay):
        threading.Thread.__init__(self)
        self.threadID &#x3D; threadID
        self.name &#x3D; name
        self.delay &#x3D; delay
    def run(self):
        print (&quot;开始线程：&quot; + self.name)
        print_time(self.name, self.delay, 5)
        print (&quot;退出线程：&quot; + self.name)

def print_time(threadName, delay, counter):
    while counter:
        if exitFlag:
            threadName.exit()
        time.sleep(delay)
        print (&quot;%s: %s&quot; % (threadName, time.ctime(time.time())))
        counter -&#x3D; 1

# 创建新线程
thread1 &#x3D; myThread(1, &quot;Thread-1&quot;, 1)
thread2 &#x3D; myThread(2, &quot;Thread-2&quot;, 2)

# 开启新线程
thread1.start()
thread2.start()
thread1.join()
thread2.join()
print (&quot;退出主线程&quot;)</code></pre>

<h1 id="异步编程代码-异步爬取网站"><a href="#异步编程代码-异步爬取网站" class="headerlink" title="异步编程代码  异步爬取网站"></a>异步编程代码  异步爬取网站</h1><pre class="line-numbers language-python" data-language="python"><code class="language-python">import asyncio
import aiohttp
import aiofiles

async def get_html(session, url):
    try:
        async with session.get(url&#x3D;url, timeout&#x3D;8) as resp:
            if not resp.status &#x2F;&#x2F; 100 &#x3D;&#x3D; 2:
                print(resp.status)
                print(&quot;爬取&quot;, url, &quot;出现错误&quot;)
            else:
                resp.encoding &#x3D; &#39;utf-8&#39;
                text &#x3D; await resp.text()
                return text
    except Exception as e:
        print(&quot;出现错误&quot;, e)
        await get_html(session, url)
        #使用异步请求之后，对应的文件保存也需要使用异步，即是一处异步，处处异步
async def download(title_list, content_list):
    async with aiofiles.open(&#39;&#123;&#125;.txt&#39;.format(title_list[0]), &#39;a&#39;,
                             encoding&#x3D;&#39;utf-8&#39;) as f:
        await f.write(&#39;&#123;&#125;&#39;.format(str(content_list)))
</code></pre>
<h1 id="requests-库调用"><a href="#requests-库调用" class="headerlink" title="requests 库调用"></a>requests 库调用</h1><pre class="line-numbers language-python" data-language="python"><code class="language-python">import requests

#发送 GET 请求
headers &#x3D; &#123;
    &#39;user-agent&#39;: &#39;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;96.0.4664.110 Safari&#x2F;537.36&#39;,
  &#39;cookie&#39;: &#39;some_cookie&#39;
&#125;
response &#x3D; requests.request(&quot;GET&quot;, url, headers&#x3D;headers)
#发送 POST 请求
import requests

payload&#x3D;&#123;&#125;
files&#x3D;[]
headers &#x3D; &#123;
    &#39;user-agent&#39;: &#39;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;96.0.4664.110 Safari&#x2F;537.36&#39;,
  &#39;cookie&#39;: &#39;some_cookie&#39;
&#125;
response &#x3D; requests.request(&quot;POST&quot;, url, headers&#x3D;headers, data&#x3D;payload, files&#x3D;files)


#保存数据到CSV
import os
def save_data(data, date):
    if not os.path.exists(r&#39;2021_data_%s.csv&#39; % date):
        with open(&quot;2021_data_%s.csv&quot; % date, &quot;a+&quot;, encoding&#x3D;&#39;utf-8&#39;) as f:
            f.write(&quot;标题,热度,时间,url\n&quot;)
            for i in data:
                title &#x3D; i[&quot;title&quot;]
                extra &#x3D; i[&quot;extra&quot;]
                time &#x3D; i[&#39;time&#39;]
                url &#x3D; i[&quot;url&quot;]
                row &#x3D; &#39;&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;&#39;.format(title,extra,time,url)
                f.write(row)
                f.write(&#39;\n&#39;)
    else:
        with open(&quot;2021_data_%s.csv&quot; % date, &quot;a+&quot;, encoding&#x3D;&#39;utf-8&#39;) as f:
            for i in data:
                title &#x3D; i[&quot;title&quot;]
                extra &#x3D; i[&quot;extra&quot;]
                time &#x3D; i[&#39;time&#39;]
                url &#x3D; i[&quot;url&quot;]
                row &#x3D; &#39;&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;&#39;.format(title,extra,time,url)
                f.write(row)
                f.write(&#39;\n&#39;)</code></pre>

<h1 id="IP代理池搭建"><a href="#IP代理池搭建" class="headerlink" title="IP代理池搭建"></a>IP代理池搭建</h1><pre class="line-numbers language-python" data-language="python"><code class="language-python">import requests # python基础爬虫库
from lxml import etree # 可以将网页转换为Elements对象
import time # 防止爬取过快可以睡眠一秒

# 第一步：构造主页url地址，发送请求获取响应
# 第二步：解析数据，将数据分组
# 第三步：将数组的数据提取出来
# 第四步：检测代理IP的可用性
# 第五步：保存到文件中
# https:&#x2F;&#x2F;blog.csdn.net&#x2F;yuan2019035055&#x2F;article&#x2F;details&#x2F;121334216

class daili():

    # 1.发送请求，获取响应
    def send_request(self, page):
        print(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;正在抓取第&#123;&#125;页&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;.format(page))
        # 目标网页，添加headers参数
        base_url &#x3D; &#39;https:&#x2F;&#x2F;www.kuaidaili.com&#x2F;free&#x2F;inha&#x2F;&#123;&#125;&#x2F;&#39;.format(page)
        headers &#x3D; &#123;
            &#39;User-Agent&#39;: &#39;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;95.0.4638.69 Safari&#x2F;537.36&#39;&#125;

        # 发送请求：模拟浏览器发送请求，获取响应数据
        response &#x3D; requests.get(base_url, headers&#x3D;headers)
        data &#x3D; response.content.decode()
        time.sleep(1)

        return data

    # 2.解析数据
    def parse_data(self, data):

        # 数据转换
        html_data &#x3D; etree.HTML(data)
        # 分组数据
        parse_list &#x3D; html_data.xpath(&#39;&#x2F;&#x2F;table[@class&#x3D;&quot;table table-bordered table-striped&quot;]&#x2F;tbody&#x2F;tr&#39;)
        return parse_list

    # 4.检测代理IP
    def check_ip(self, proxies_list):
        headers &#x3D; &#123;
            &#39;User-Agent&#39;: &#39;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;95.0.4638.69 Safari&#x2F;537.36&#39;&#125;

        can_use &#x3D; []
        for proxies in proxies_list:
            try:
                response &#x3D; requests.get(&#39;https:&#x2F;&#x2F;www.baidu.com&#x2F;&#39;, headers&#x3D;headers, proxies&#x3D;proxies, timeout&#x3D;0.1)
                if response.status_code &#x3D;&#x3D; 200:
                    can_use.append(proxies)
            except Exception as e:
                print(e)
        return can_use

    # 5.保存到文件
    def save(self, can_use):

        file &#x3D; open(&#39;..\data\IP.txt&#39;, &#39;w&#39;)
        for i in range(len(can_use)):
            s &#x3D; str(can_use[i]) + &#39;\n&#39;
            file.write(s)
        file.close()

    # 实现主要逻辑
    def run(self):
        proxies_list &#x3D; []
        # 实现翻页，我这里只爬取了四页（可以修改5所在的数字）
        for page in range(1, 3):
            data &#x3D; self.send_request(page)
            parse_list &#x3D; self.parse_data(data)
            # 3.获取数据
            for tr in parse_list:
                proxies_dict &#x3D; &#123;&#125;
                http_type &#x3D; tr.xpath(&#39;.&#x2F;td[4]&#x2F;text()&#39;)
                ip_num &#x3D; tr.xpath(&#39;.&#x2F;td[1]&#x2F;text()&#39;)
                port_num &#x3D; tr.xpath(&#39;.&#x2F;td[2]&#x2F;text()&#39;)

                http_type &#x3D; &#39; &#39;.join(http_type)
                ip_num &#x3D; &#39; &#39;.join(ip_num)
                port_num &#x3D; &#39; &#39;.join(port_num)

                proxies_dict[http_type] &#x3D; ip_num + &quot;:&quot; + port_num

                proxies_list.append(proxies_dict)

        print(&quot;获取到的代理IP数量：&quot;, len(proxies_list))

        can_use &#x3D; self.check_ip(proxies_list)

        print(&quot;能用的代理IP数量：&quot;, len(can_use))
        print(&quot;能用的代理IP:&quot;, can_use)
        self.save(can_use)



if __name__ &#x3D;&#x3D; &quot;__main__&quot;:
    dl &#x3D; daili()
    dl.run()

    # 从文件中随机取出一个IP去访问网址
    import random
    import requests
    # 打开文件，换行读取
    f&#x3D;open(&quot;..\data\IP.txt&quot;,&quot;r&quot;)
    file &#x3D; f.readlines()

    # 遍历并分别存入列表，方便随机选取IP
    item &#x3D; []
    for proxies in file:
        proxies &#x3D; eval(proxies.replace(&#39;\n&#39;,&#39;&#39;)) # 以换行符分割，转换为dict对象
        item.append(proxies)

    proxies &#x3D; random.choice(item)  # 随机选取一个IP

    url &#x3D; &#39;https:&#x2F;&#x2F;www.baidu.com&#x2F;&#39;
    headers &#x3D; &#123;&#39;User-Agent&#39;: &#39;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;95.0.4638.69 Safari&#x2F;537.36&#39;&#125;

    response &#x3D; requests.get(url,headers&#x3D;headers,proxies&#x3D;proxies)
    print(response.status_code) # 输出状态码 200，表示访问成功
    </code></pre>



<h1 id="生成一段时间区间内的日期"><a href="#生成一段时间区间内的日期" class="headerlink" title="生成一段时间区间内的日期"></a>生成一段时间区间内的日期</h1><pre class="line-numbers language-python" data-language="python"><code class="language-python">import pandas as pd
print([str(i) for i in pd.date_range(&#39;2020-02-03&#39;,&#39;2020-03-05&#39;,freq&#x3D;&quot;D&quot;).strftime(&quot;%Y-%m-%d&quot;).tolist()])</code></pre>

<h1 id="获取过去-N-天的日期"><a href="#获取过去-N-天的日期" class="headerlink" title="获取过去 N 天的日期"></a>获取过去 N 天的日期</h1><pre class="line-numbers language-python" data-language="python"><code class="language-python">import datetime

def get_nday_list(n):
    before_n_days &#x3D; []
    for i in range(1, n + 1)[::-1]:
        before_n_days.append(str(datetime.date.today() - datetime.timedelta(days&#x3D;i)))
    return before_n_days

a &#x3D; get_nday_list(30)
print(a)</code></pre>

<h1 id="生成xmind"><a href="#生成xmind" class="headerlink" title="生成xmind"></a>生成xmind</h1><pre class="line-numbers language-python" data-language="python"><code class="language-python">import xmind

w &#x3D; xmind.load(&quot;test.xmind&quot;)
s1 &#x3D; w.getPrimarySheet()  # 获取此工作表
s1.setTitle(&quot;first sheet&quot;)  # 设置标题
a &#x3D; &#123;&quot;h1&quot;: &#39;Python 技术学习&#39;, &#39;h2&#39;: [&#39;Python基础&#39;, &#39;Python 爬虫&#39;],
     &#39;h3&#39;: [[&#39;Python环境安装&#39;, &#39;Python基础语法&#39;, &#39;Python数据结构&#39;], [&#39;Python爬虫基础知识详解&#39;, &#39;Python爬虫相关模块详解&#39;]]&#125;
r1 &#x3D; s1.getRootTopic()  # 获取此工作表的根主题
r1.setTitle(a[&#39;h1&#39;])  # 设置标题
c &#x3D; a[&#39;h2&#39;]
c2 &#x3D; a[&#39;h3&#39;]
for i, val in enumerate(c):
    print(i, val)
    a &#x3D; &#39;b&#39; + str(i)
    a &#x3D; r1.addSubTopic()
    a.setTitle(val)  # 设置标题
    for i2, val2 in enumerate(c2):
        if i &#x3D;&#x3D; i2:
            a2 &#x3D; &#39;b2&#39; + str(i)
            a2 &#x3D; a.addSubTopic()
            #        if isinstance(val, list):
            for i3, val3 in enumerate(val2):
                a3 &#x3D; &#39;b3&#39; + str(i3)
                a3 &#x3D; a2.addSubTopic()
                a3.setTitle(val3)

xmind.save(w, &quot;Python_detail.xmind&quot;)</code></pre>
<h1 id="【python】如何提取本机连接过的wifi密码（亲测好用-1"><a href="#【python】如何提取本机连接过的wifi密码（亲测好用-1" class="headerlink" title="【python】如何提取本机连接过的wifi密码（亲测好用"></a>【python】如何提取本机连接过的wifi密码（亲测好用</h1><pre class="line-numbers language-python" data-language="python"><code class="language-python">import subprocess
# 获取wifi列表
output &#x3D; subprocess.run([&#39;netsh&#39;,&#39;wlan&#39;,&#39;show&#39;,&#39;profiles&#39;],capture_output &#x3D; True).stdout.decode(&#39;gbk&#39;).split(&#39;\n&#39;)
wifis &#x3D; [line.split(&#39;:&#39;)[1][1:-1] for line in output if &quot;所有用户配置文件&quot; in line]

#查看每个wifi对应的密码
for wifi in wifis:
    results &#x3D; subprocess.run([&#39;netsh&#39;,&#39;wlan&#39;,&#39;show&#39;,&#39;profile&#39;,wifi,&#39;key&#x3D;clear&#39;],capture_output &#x3D; True).stdout.decode(&#39;gbk&#39;,errors &#x3D; &#39;ignore&#39;).split(&#39;\n&#39;)
    results &#x3D; [line.split(&#39;:&#39;)[1][1:-1] for line in results if &quot;关键内容&quot; in line]
    try:
        print(f&#39;wifi账号：&#123;wifi&#125;，密码:&#123;results[0]&#125;&#39;)
    except IndexError:
        print(f&#39;wifi账号：&#123;wifi&#125;，密码:提取失败！&#39;)
</code></pre>

]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python数据分析：xlwings操作excel</title>
    <url>//post/python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%EF%BC%9Axlwings%E6%93%8D%E4%BD%9Cexcel.html</url>
    <content><![CDATA[<h5 id="xlwings是Python中操作Excel的一个第三方库，支持-xls读写，-xlsx读写，操作非常简单，功能也很强大"><a href="#xlwings是Python中操作Excel的一个第三方库，支持-xls读写，-xlsx读写，操作非常简单，功能也很强大" class="headerlink" title="xlwings是Python中操作Excel的一个第三方库，支持.xls读写，.xlsx读写，操作非常简单，功能也很强大"></a>xlwings是Python中操作Excel的一个第三方库，支持.xls读写，.xlsx读写，操作非常简单，功能也很强大</h5><h5 id="xlwings与VBA的配合非常完美，你可以在python中调用VBA，也可以在VBA中使用python编程，这些通过xlwings都可以巧妙实现。"><a href="#xlwings与VBA的配合非常完美，你可以在python中调用VBA，也可以在VBA中使用python编程，这些通过xlwings都可以巧妙实现。" class="headerlink" title="xlwings与VBA的配合非常完美，你可以在python中调用VBA，也可以在VBA中使用python编程，这些通过xlwings都可以巧妙实现。"></a>xlwings与VBA的配合非常完美，你可以在python中调用VBA，也可以在VBA中使用python编程，这些通过xlwings都可以巧妙实现。</h5><p>先说装这个xlwings碰到个神坑：</p>
<p>用pip install pywin32装完之后错误就来了</p>
<p>DLL load failed while importing win32api: 找不到指定的程序。<br>md搞死我了</p>
<p>查不到，再查，再查，再查。。。</p>
<p>解决方法：<a href="https://links.jianshu.com/go?to=https://www.cnblogs.com/Swalllow/p/11711750.html">https://www.cnblogs.com/Swalllow/p/11711750.html</a><br>找到文件pywin32_postinstall.py的路径，</p>
<p>由于安装路径不同，可能位置不一样，可以在你安装python的文件夹搜索这个文件，</p>
<p>一般在安装文件下的Scripts文件里，用cmd进入这个Scripts文件夹</p>
<p>如cd/d D:\install\python3.8\Scripts</p>
<p>在路径下运行python pywin32_postinstall.py -install</p>
<p>再检查一次是否成功</p>
<p>芜湖~，居然好了</p>
<p>学习xlwings看这里：</p>
<p><a href="https://www.kancloud.cn/gnefnuy/xlwings-docs/1127455">https://www.kancloud.cn/gnefnuy/xlwings-docs/1127455</a><br><a href="https://www.cnblogs.com/Renyi-Fan/p/13244027.html">https://www.cnblogs.com/Renyi-Fan/p/13244027.html</a></p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">import pandas as pd
import xlwings as xw</code></pre>


<pre class="line-numbers language-python" data-language="python"><code class="language-python"># 建立excel表连接
wb &#x3D; xw.Book(&quot;out.xlsx&quot;)
#     实例化工作表对象
sht &#x3D; wb.sheets[&quot;源数据&quot;]
sht</code></pre>


<pre><code>&lt;Sheet [out.xlsx]源数据&gt;
</code></pre>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">#     返回工作表绝对路径
wb.fullname</code></pre>


<pre><code>&#39;C:\\Users\\supermanzwg\\workspace\\3Data_Processing(自动化)\\out.xlsx&#39;
</code></pre>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">#     返回工作簿的名字

sht.name</code></pre>


<pre><code>&#39;源数据&#39;
</code></pre>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">#     在单元格中写入数据
sht.range(&#39;A1&#39;).value &#x3D; &quot;xlwing牛逼啊&quot;
sht</code></pre>


<pre><code>&lt;Sheet [out.xlsx]源数据&gt;
</code></pre>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">#     读取单元格内容
sht.range(&#39;A1&#39;).value</code></pre>


<pre><code>&#39;xlwing牛逼啊&#39;
</code></pre>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">#     清除单元格内容和格式
sht.range(&#39;A1&#39;).clear()</code></pre>


<pre class="line-numbers language-python" data-language="python"><code class="language-python">#     获取单元格的列标
sht.range(&#39;A1&#39;).column</code></pre>


<pre><code>1
</code></pre>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">#     获取单元格的行标
sht.range(&#39;A1&#39;).row</code></pre>

<pre><code>1
</code></pre>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">#     获取单元格的行高
sht.range(&#39;A1&#39;).row_height</code></pre>

<pre><code>13.2
</code></pre>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">#     获取单元格的列宽
sht.range(&#39;A1&#39;).column_width</code></pre>

<pre><code>8.47
</code></pre>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">#     列宽自适应
sht.range(&#39;A1:A99&#39;).columns.autofit()
sht</code></pre>

<pre><code>&lt;Sheet [out.xlsx]源数据&gt;
</code></pre>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">#     行高自适应
sht.range(&#39;A1:M1&#39;).rows.autofit()</code></pre>

<pre class="line-numbers language-python" data-language="python"><code class="language-python">#     给单元格上背景色，传入RGB值
sht.range(&#39;A1&#39;).color &#x3D; (34,139,34)</code></pre>

<pre class="line-numbers language-python" data-language="python"><code class="language-python">#     获取单元格颜色，RGB值
sht.range(&#39;A1&#39;).color</code></pre>

<pre><code>(34, 139, 34)
</code></pre>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">#     清除单元格颜色
sht.range(&#39;A1&#39;).color &#x3D; None</code></pre>

<pre class="line-numbers language-python" data-language="python"><code class="language-python">#     输入公式，相应单元格会出现计算结果
sht.range(&#39;A1&#39;).formula&#x3D;&#39;&#x3D;SUM(H6:H7)&#39;</code></pre>

<pre class="line-numbers language-python" data-language="python"><code class="language-python">#     获取单元格公式
sht.range(&#39;A1&#39;).formula_array</code></pre>

<pre><code>&#39;=SUM(H6:H7)&#39;
</code></pre>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">#     在单元格中写入批量数据，只需要指定其实单元格位置即可
sht.range(&#39;A2&#39;).value &#x3D; [[&#39;Foo 1&#39;, &#39;Foo 2&#39;, &#39;Foo 3&#39;], [10.0, 20.0, 30.0]]</code></pre>


<pre class="line-numbers language-python" data-language="python"><code class="language-python">#     读取表中批量数据，使用expand()方法
sht.range(&#39;A2&#39;).expand().value</code></pre>


<pre class="line-numbers language-python" data-language="python"><code class="language-python">#     其实你也可以不指定工作表的地址，直接与电脑里的活动表格进行交互
# 写入
xw.Range(&quot;E1&quot;).value &#x3D; &quot;xlwings&quot;# 读取
xw.Range(&quot;E1&quot;).value</code></pre>

<pre><code>&#39;xlwings&#39;
</code></pre>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">xw.range(&quot;E2&quot;).value &#x3D; &quot;xlwings&quot;</code></pre>

<pre><code>---------------------------------------------------------------------------

AttributeError                            Traceback (most recent call last)

C:\Users\SUPERM~1\AppData\Local\Temp/ipykernel_10040/191138757.py in &lt;module&gt;
----&gt; 1 xw.range(&quot;E2&quot;).value = &quot;xlwings&quot;

AttributeError: module &#39;xlwings&#39; has no attribute &#39;range&#39;
</code></pre>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"># xlwings与numpy、pandas、matplotlib互动
#     支持写入numpy array数据类型

import numpy as np
np_data &#x3D; np.array((1,2,3))
sht.range(&#39;F1&#39;).value &#x3D; np_data</code></pre>

<pre class="line-numbers language-python" data-language="python"><code class="language-python">#     支持将pandas DataFrame数据类型写入excel

import pandas as pd
df &#x3D; pd.DataFrame([[1,2], [3,4]], columns&#x3D;[&#39;a&#39;, &#39;b&#39;])
sht.range(&#39;A5&#39;).value &#x3D; df</code></pre>

<pre class="line-numbers language-python" data-language="python"><code class="language-python">#     将数据读取，输出类型为DataFrame

sht.range(&#39;A5&#39;).options(pd.DataFrame,expand&#x3D;&#39;table&#39;).value</code></pre>

<pre class="line-numbers language-python" data-language="python"><code class="language-python">#     将matplotlib图表写入到excel表格里

import matplotlib.pyplot as plt
%matplotlib inline
fig &#x3D; plt.figure()
plt.plot([1, 2, 3, 4, 5])
sht.pictures.add(fig, name&#x3D;&#39;MyPlot&#39;, update&#x3D;True)

# xlwings与VBA互相调用
</code></pre>

<pre><code>&lt;Picture &#39;MyPlot&#39; in &lt;Sheet [out.xlsx]源数据&gt;&gt;
</code></pre>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title>python连接mysql:读取、写入、更新、删除</title>
    <url>//post/python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%EF%BC%9A%E8%BF%9E%E6%8E%A5mysql%EF%BC%8C%E8%AF%BB%E5%8F%96%E3%80%81%E5%86%99%E5%85%A5%E3%80%81%E6%9B%B4%E6%96%B0%E3%80%81%E5%88%A0%E9%99%A4.html</url>
    <content><![CDATA[<h2 id="1、连接读取数据"><a href="#1、连接读取数据" class="headerlink" title="1、连接读取数据"></a>1、连接读取数据</h2><h3 id="第一种：用pymysql连接"><a href="#第一种：用pymysql连接" class="headerlink" title="第一种：用pymysql连接"></a>第一种：用pymysql连接</h3><pre class="line-numbers language-none"><code class="language-none">#安装pymysql
conda install pymysql
#或者
pip install pymysql</code></pre>
<pre class="line-numbers language-none"><code class="language-none">import pymysql
#创建数据库连接，依次是主机名，用户名，密码，要打开的数据库，端口号和编码类型
def get_conn():
    conn &#x3D; pymysql.connect(
        host&#x3D;&quot;****&quot;,
        user&#x3D;&quot;****&quot;,
        password&#x3D;&quot;****&quot;,
        db&#x3D;&quot;****&quot;,
        charset&#x3D;&quot;utf8&quot;,
        port&#x3D;3306,
    )
    # 创建游标：
    cursor &#x3D; conn.cursor()
    return conn, cursor
def close_conn(conn, cursor):
    if cursor:
        cursor.close()
    if conn:
        conn.close()
def query(sql, *args):
    &#39;&#39;&#39;
    :param sql:
    :param args:
    :return:返回结果，提取数据，返回的data是一个二维元组，((),())形式；
    &#39;&#39;&#39;
    conn, cursor&#x3D; get_conn()
    cursor.execute(sql)
    res &#x3D; cursor.fetchall() # 获取结果
    close_conn(conn, cursor)
    return res
#返回的是所有行在对应列的值</code></pre>

<pre class="line-numbers language-none"><code class="language-none"># connect.commit()
#如果对数据进行了增删改查的话，执行该语句，相当于把对数据库的操作提交上去，否则修改不会生效
close_conn(conn, cursor)#当然要有关闭游标和数据库连接的习惯</code></pre>

<ul>
<li>fetchone与fetchall的理解；举个例子:cursor是我们连接数据库的实例<br>fetchone()的使用:返回值是单个的元组,也就是一行记录,如果没有结果,那就会返回null</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">cursor.execute(f&quot;select username,password,nickname from user where id&#x3D;&#123;input&#125;&quot;)
result&#x3D;cursor.fetchone();  
此时我们可以通过result[0],result[1],result[2]得到username,password,nickname</code></pre>
<p>fetchall()的使用:返回值是多个元组,即返回多个行记录,如果没有结果,返回的是()</p>
<pre class="line-numbers language-none"><code class="language-none">cursor.execute(select * from user)
result&#x3D;cursor.fetchall();此时select得到的可能是多行记录,那么我们通过fetchall得到的就是多行记录,是一个二维元组
((username1,password1,nickname1),(username2,password2,nickname2),(username3,password3,nickname))</code></pre>
<h3 id="第二种：pandas内置的read-sql"><a href="#第二种：pandas内置的read-sql" class="headerlink" title="第二种：pandas内置的read_sql"></a>第二种：pandas内置的read_sql</h3><p>  需要安装sqlalchemy,但是可以DataFrame的形式读出来，方便多了</p>
<pre class="line-numbers language-none"><code class="language-none">conda install sqlalchemy
#或者
pip install sqlalchemy</code></pre>
<pre class="line-numbers language-none"><code class="language-none">import pandas as pd
from sqlalchemy import create_engine
def reader_sql(query,db&#x3D;&#39;myemployees&#39;):
    sql &#x3D; query
    engine &#x3D; create_engine(f&#39;mysql+pymysql:&#x2F;&#x2F;root:&#123;pwd&#125;@localhost:3306&#x2F;&#123;db&#125;?charset&#x3D;utf8&#39;)
    #格式一点不能错，依次是用户名，密码（###），主机名，端口号，要连接的数据库，指定编码
    df &#x3D; pd.read_sql(sql,engine)
    return df
df_departments &#x3D; reader_sql(&#39;select  * from departments&#39;)#这里输出的是一个dataframe</code></pre>
<h2 id="2、写入数据"><a href="#2、写入数据" class="headerlink" title="2、写入数据"></a>2、写入数据</h2><h3 id="第一种：to-sql写入"><a href="#第一种：to-sql写入" class="headerlink" title="第一种：to_sql写入"></a>第一种：to_sql写入</h3><pre class="line-numbers language-none"><code class="language-none">result.to_sql(name&#x3D;&#39;newtable&#39;,con&#x3D;engine,if_exists&#x3D;&#39;append&#39;,index&#x3D;False)
#这里的index如果为True的话也会报错，数据库中没有索引列（建表的时候没有预留索引列的位置）
#默认参数是fail，如果这张表本来存在的话，操作就会fail失败掉
#不建议这种直接建表操作，这样的表中字段类型会有变化，不符合原先数据要求
#建议在workbench中先create table并把所有字段的类型定义好，在使用to_sql进行写入</code></pre>
<ul>
<li>新建表设置好字段类型或者用cursor.execute执行建表语句后，就可以用to_sql写入了</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">result.to_sql(name&#x3D;&#39;new_table2&#39;,con&#x3D;engine,if_exists&#x3D;&#39;append&#39;,index&#x3D;False)
#这里注意新建表的时候一定要把各个字段的类型搞准确，编码搞清楚不然没意识到出个错，很难受
#如果重复执行这行代码的话，会导致插入的数据成倍数增加，因为你传入的append参数，会在原数据上接着添加</code></pre>

<pre class="line-numbers language-none"><code class="language-none">del result[&#39;department_name&#39;]#删掉一列后再进行写入
result.to_sql(name&#x3D;&#39;new_table2&#39;,con&#x3D;engine,if_exists&#x3D;&#39;append&#39;,index&#x3D;False)
#如果建表时在NN列未勾选上的话，不会报错，会发现原本的值数量多了一倍，且新增的数据中的department_name列均为空值
#但如果建表时在NN列勾选上的话，表示该字段不允许为空值，就会报错
#还有如果写入的数据字段多了，与建表时给定的字段数量不符也会报错</code></pre>
<ul>
<li>将excel中分sheet写入数据库</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">import pymysql
import pandas as pd
from sqlalchemy import create_engine
import xlrd
file &#x3D; r&#39;C:\Users\sofia.xlsx&#39;
#分sheet写入数据库
# 然后调用df.to_sql()函数将dataframe数据写入：

&quot;&quot;&quot; 打开excel表格&quot;&quot;&quot;
workbook &#x3D; xlrd.open_workbook(file)
sheet_names &#x3D; workbook.sheet_names()
for i in sheet_names :
    data &#x3D; pd.read_excel(file,sheet_name &#x3D; i,index &#x3D; False,encoding&#x3D;&#39;utf-8&#39;)
    data.to_sql(i,con&#x3D;engine,if_exists&#x3D;&#39;replace&#39;,index&#x3D;False)</code></pre>

<ul>
<li>pd.read_sql()介绍</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">pandas.read_sql(sql, con, index_col&#x3D;None, coerce_float&#x3D;True, params&#x3D;None, parse_dates&#x3D;None, columns&#x3D;None, chunksize&#x3D;None)
各参数意义：
sql:SQL命令字符串
con：连接sql数据库的engine，一般可以用SQLalchemy或者pymysql之类的包建立
index_col: 选择某一列作为index
coerce_float:非常有用，将数字形式的字符串直接以float型读入
parse_dates:将某一列日期型字符串转换为datetime型数据，与pd.to_datetime函数功能类似。可以直接提供需要转换的列名以默认的日期形式转换，也可以用字典的格式提供列名和转换的日期格式，比如&#123;column_name: format string&#125;（format string：&quot;%Y:%m:%H:%M:%S&quot;）。
columns:要选取的列。一般没啥用，因为在sql命令里面一般就指定要选择的列了
chunksize：如果提供了一个整数值，那么就会返回一个generator，每次输出的行数就是提供的值的大小。
##read_sql本质上是read_sql_table、read_sql_query的统一方式。
三者都return返回DataFrame。</code></pre>
<p><a href="https://pandas.pydata.org/pandas-docs/stable/generated/pandas.read_sql_table.html#pandas.read_sql_table"><code>read_sql_table</code></a></p>
<p>Read SQL database table into a DataFrame.</p>
<p><a href="https://pandas.pydata.org/pandas-docs/stable/generated/pandas.read_sql_query.html#pandas.read_sql_query"><code>read_sql_query</code></a></p>
<p>Read SQL query into a DataFrame.</p>
<p><a href="http://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.to_sql.html">to_sql</a><br>主要有以下几个参数：</p>
<ul>
<li>  name: 输出的表名</li>
<li>  con: 与read_sql中相同</li>
<li>  if_exits： 三个模式：fail，若表存在，则不输出；replace：若表存在，覆盖原来表里的数据；append：若表存在，将数据写到原表的后面。默认为fail</li>
<li>  index：是否将df的index单独写到一列中</li>
<li>  index_label:指定列作为df的index输出，此时index为True</li>
<li>  chunksize： 同read_sql</li>
<li>dtype: 指定列的输出到数据库中的数据类型。字典形式储存：{column_name: sql_dtype}。常见的数据类型有sqlalchemy.types.INTEGER(), sqlalchemy.types.NVARCHAR(),sqlalchemy.Datetime()等，具体数据类型可以参考<a href="http://docs.sqlalchemy.org/en/latest/core/type_basics.html#sql-standard-and-multiple-vendor-types">这里</a><br>  还是以写到mysql数据库为例：<pre class="line-numbers language-none"><code class="language-none">df.to_sql(name&#x3D;&#39;table&#39;, 
          con&#x3D;con, 
          if_exists&#x3D;&#39;append&#39;, 
          index&#x3D;False,
          dtype&#x3D;&#123;&#39;col1&#39;:sqlalchemy.types.INTEGER(),
                 &#39;col2&#39;:sqlalchemy.types.NVARCHAR(length&#x3D;255),
                 &#39;col_time&#39;:sqlalchemy.DateTime(),
                 &#39;col_bool&#39;:sqlalchemy.types.Boolean
          &#125;)</code></pre></li>
<li>*注：**如果不提供dtype,to_sql会自动根据df列的dtype选择默认的数据类型输出，比如字符型会以sqlalchemy.types.TEXT类型输出，相比NVARCHAR，TEXT类型的数据所占的空间更大，所以一般会指定输出为NVARCHAR；而如果df的列的类型为np.int64时，将会导致无法识别并转换成INTEGER型，需要事先转换成int类型（用map，apply函数可以方便的转换）。<br><a href="https://www.cnblogs.com/arkenstone/p/6271923.html">https://www.cnblogs.com/arkenstone/p/6271923.html</a></li>
</ul>
<h3 id="第二种：cursor-execute-直接写入"><a href="#第二种：cursor-execute-直接写入" class="headerlink" title="第二种：cursor.execute()直接写入"></a>第二种：cursor.execute()直接写入</h3><pre class="line-numbers language-none"><code class="language-none">#插入方法无需改动，传入一个动态变化的字典
connect &#x3D; pymysql.connect(host&#x3D;&#39;&#39;,user&#x3D;&#39;&#39;,db &#x3D; &#39;&#39;,password&#x3D;&#39;&#39;,port&#x3D;3306,charset&#x3D;&#39;utf8&#39;)
cursor&#x3D;connect.cursor()
data &#x3D; &#123;&quot;id&quot;:&#39;100&#39;,&#39;name&#39;:&#39;Bob&#39;&#125;
table&#x3D; &#39;stuinfo&#39;
keys &#x3D; &#39;, &#39;.join(data.keys())
values &#x3D; &#39;, &#39;.join([&#39;%s&#39;]*len(data))
sql &#x3D; f&quot;insert into &#123;table&#125;(&#123;keys&#125;) values(&#123;values&#125;)&quot;
try:
    cursor.execute(sql,tuple(data.values()))
    connect.commit()
    cursor.execute(&#39;select * from &#123;table&#125;&#39;.format(table&#x3D;table))
    print(&#39;执行成功&#39;,cursor.fetchall())
except:
    print(&quot;插入失败，数据回滚&quot;)
    connect.rollback()</code></pre>
<h2 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h2><pre class="line-numbers language-none"><code class="language-none">#更新，把Bon的age更新为28
sql &#x3D; &quot;update stuinfo set id&#x3D;%s where name &#x3D; %s&quot;
cursor.execute(sql,(&quot;28&quot;,&#39;Bob&#39;))
connect.commit()
cursor.execute(&#39;select * from stuinfo&#39;)
print(&quot;Successful:&quot;,cursor.fetchall())</code></pre>
<h2 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h2><pre class="line-numbers language-none"><code class="language-none">#删除数据
sql &#x3D; &quot;delete from stuinfo where id &gt;&#x3D;10&quot;
cursor.execute(sql)
connect.commit()
cursor.execute(&quot;select * from stuinfo&quot;)
print(cursor.fetchall())</code></pre>]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title>python数据可视化：pyecharts v1版本</title>
    <url>//post/python%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%EF%BC%9Apyecharts-v1%E7%89%88%E6%9C%AC.html</url>
    <content><![CDATA[<p><a href="https://github.com/ecomfe/echarts">Echarts</a>是一个由百度开源的数据可视化，结合巧妙的交互性，精巧的图表设计；而 Python 是一门富有表达力的语言，很适合用于数据处理。分析遇上数据可视化时，<a href="https://github.com/pyecharts/pyecharts">pyecharts</a>诞生了。<br>个人觉得可视化最好用的，不接受反驳，毕竟用echarts的都那么多；<br><a href="https://pyecharts.org/#/zh-cn/intro">官方文档</a></p>
<ul>
<li>自己挑了一些碰到的坑记了一下，分享一些自己学习过程中发现的资源，其他看文档就够了</li>
</ul>
<h1 id="基础柱状图"><a href="#基础柱状图" class="headerlink" title="基础柱状图"></a>基础柱状图</h1><pre class="line-numbers language-python" data-language="python"><code class="language-python">from pyecharts import options as opts
from pyecharts.charts import Bar
from pyecharts.faker import Faker
c &#x3D; (
    Bar()
    .add_xaxis(Faker.choose())
    .add_yaxis(&quot;商家A&quot;, Faker.values())#gap&#x3D;&quot;0%&quot;；category_gap&#x3D;&quot;80%&quot;；stack&#x3D;&quot;stack1&quot;
    .add_yaxis(&quot;商家B&quot;, Faker.values())#gap&#x3D;&quot;0%&quot;；is_selected&#x3D;False；stack&#x3D;&quot;stack1&quot;；label_opts&#x3D;opts.LabelOpts(is_show&#x3D;False)
    .set_global_opts(title_opts&#x3D;opts.TitleOpts(title&#x3D;&quot;Bar-基本示例&quot;, subtitle&#x3D;&quot;我是副标题&quot;))
                     # datazoom_opts&#x3D;[opts.DataZoomOpts(), opts.DataZoomOpts(type_&#x3D;&quot;inside&quot;)],#时间轴显示并可同通过鼠标滑动
    .set_series_opts(
        label_opts&#x3D;opts.LabelOpts(is_show&#x3D;False),
        markpoint_opts&#x3D;opts.MarkPointOpts(
            data&#x3D;[
                opts.MarkPointItem(type_&#x3D;&quot;max&quot;, name&#x3D;&quot;最大值&quot;),
                opts.MarkPointItem(type_&#x3D;&quot;min&quot;, name&#x3D;&quot;最小值&quot;),
#                 opts.MarkPointItem(type_&#x3D;&quot;average&quot;, name&#x3D;&quot;平均值&quot;),
            ]
        ),
        markline_opts&#x3D; opts.MarkLineOpts(data &#x3D; [opts.MarkLineItem(type_ &#x3D; &quot;average&quot;,name &#x3D; &quot;平均值&quot;)])
    )
    .render_notebook()
)
c</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/zhang18340082962/image-rick@master/image-rick/6460608-c318cf13b19d947a.1zz3gy9m634w.png"></p>
<ul>
<li><p>只能通过滑动水平轴缩放x轴：只传入datazoom_opts=[opts.DataZoomOpts()]；省略掉 opts.DataZoomOpts(), 删除水平轴，就只能通过鼠标拖动；</p>
</li>
<li><p>显示水平轴的比例（默认）：<br>opts.DataZoomOpts(range_start=20,range_end=80)</p>
</li>
<li><p>取消柱子上方数据显示：<br>label_opts=opts.LabelOpts(is_show=False)</p>
</li>
<li><p>添加y轴水平轴：<br>datazoom_opts=opts.DataZoomOpts(orient=”vertical”)，可缩放大小；</p>
</li>
<li><p>柱间距离：<br>加入参数gap=”0%”(两个add_yaxis里面都要传)；<br>加入参数category_gap=”80%”，表示单系柱间距离；</p>
</li>
<li><p>默认取消显示某 Series：<br>加入参数is_selected=False，默认取消显示某 Series</p>
</li>
<li><p>堆叠数据：传入stack=”stack1”，希望哪几个指标堆叠就传那几个add_yaxis中；</p>
</li>
<li><p>显示ToolBox：在set_global_opts()中传入        toolbox_opts=opts.ToolboxOpts(), brush_opts=opts.BrushOpts(),；</p>
</li>
<li><p>XY轴名称：在set_globel_opts()中加入 yaxis_opts=opts.AxisOpts(name=”我是 Y  轴”),xaxis_opts=opts.AxisOpts(name=”我是 X 轴”),  ；</p>
</li>
<li><p>Y轴数据单位：在set_globel_opts()中加入 yaxis_opts=opts.AxisOpts(axislabel_opts=opts.LabelOpts(formatter=”{value} /月”)),  ；</p>
</li>
<li><p>加入标记线</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">    .set_series_opts(
        label_opts&#x3D;opts.LabelOpts(is_show&#x3D;False),
        markline_opts&#x3D;opts.MarkLineOpts(
            data&#x3D;[opts.MarkLineItem(y&#x3D;50, name&#x3D;&quot;yAxis&#x3D;50&quot;)]
        ),
    )
#set_global_opts()后加入set_series_opts，加入标记线，这里是y&#x3D;50；</code></pre></li>
<li><p>标记线的维度（当然可以是横轴）</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">.set_series_opts(
	markline_opts&#x3D;opts.MarkLineOpts(
                data&#x3D;[opts.MarkLineItem(type_&#x3D;&quot;average&quot;,value_dim&#x3D;&quot;x&quot;, name&#x3D;&quot;xAxis&quot;),
                     opts.MarkLineItem(type_&#x3D;&quot;average&quot;,value_dim&#x3D;&quot;y&quot;, name&#x3D;&quot;xAxis&quot;)
                     ]</code></pre></li>
<li><p>加入标记值</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">#set_series_opts中加入，表示传入标记，最大、最小、平均值。
        markpoint_opts&#x3D;opts.MarkPointOpts(
            data&#x3D;[
                opts.MarkPointItem(type_&#x3D;&quot;max&quot;, name&#x3D;&quot;最大值&quot;),
                opts.MarkPointItem(type_&#x3D;&quot;min&quot;, name&#x3D;&quot;最小值&quot;),
                opts.MarkPointItem(type_&#x3D;&quot;average&quot;, name&#x3D;&quot;平均值&quot;),
            ]</code></pre></li>
<li><p>xy轴互换</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">#设置完add_yaxis后接着
    .reversal_axis()#xy轴互换
    .set_series_opts(label_opts&#x3D;opts.LabelOpts(position&#x3D;&quot;right&quot;))#显示数据在柱子右边</code></pre></li>
<li><p>x轴名字标签过长，旋转角度</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">在set_global_opts（）中传入
xaxis_opts&#x3D;opts.AxisOpts(axislabel_opts&#x3D;opts.LabelOpts(rotate&#x3D;-15)),</code></pre></li>
<li><p>连接空数据 </p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">import pyecharts.options as opts
from pyecharts.charts import Line
from pyecharts.faker import Faker

y &#x3D; Faker.values()
y[3], y[5] &#x3D; None, None
c &#x3D; (
    Line()
    .add_xaxis(Faker.choose())
    .add_yaxis(&quot;商家A&quot;, y, is_connect_nones&#x3D;True)
    .set_global_opts(title_opts&#x3D;opts.TitleOpts(title&#x3D;&quot;Line-连接空数据&quot;))
    .render(&quot;line_connect_null.html&quot;)
)</code></pre></li>
<li><p>自定义标记点</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">import pyecharts.options as opts
from pyecharts.charts import Line
from pyecharts.faker import Faker

x, y &#x3D; Faker.choose(), Faker.values()
c &#x3D; (
    Line()
    .add_xaxis(x)
    .add_yaxis(
        &quot;商家A&quot;,
        y,
        markpoint_opts&#x3D;opts.MarkPointOpts(
            data&#x3D;[opts.MarkPointItem(name&#x3D;&quot;自定义标记点&quot;, coord&#x3D;[x[2], y[2]], value&#x3D;y[2])]
        ),
    )
    .set_global_opts(title_opts&#x3D;opts.TitleOpts(title&#x3D;&quot;Line-MarkPoint（自定义）&quot;))
    .render(&quot;line_markpoint_custom.html&quot;)
)</code></pre></li>
<li><p>作条形图时由于有时候座标轴文字过长，缩放后导致无法完全显示，此时则需要调整座标轴与图像的边距。调整边距是采用grid（）方法。在图形设置完成后，使用grid设置座标轴与图像边界的距离。</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">report_day_line &#x3D; Grid()
report_day_line.add(report_day_line1,opts.GridOpts(pos_left&#x3D;&quot;10%&quot;,pos_top &#x3D;&quot;10%&quot;), is_control_axis_index&#x3D;True)
report_day_line.render_notebook()</code></pre></li>
<li><p>指定chart_id时要将写好的图形定义成函数，这样子可以复用后面的page中图片位置，方便更改</p>
</li>
<li><p>jscode的妙用 <a href="https://zhuanlan.zhihu.com/p/133533187">https://zhuanlan.zhihu.com/p/133533187</a></p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">tooltip_opts&#x3D;opts.TooltipOpts(
                formatter&#x3D;JsCode(
                &quot;function (params) &#123;return params.value[2] + &#39; ：复购率：&#39; +(Number(params.value[0])* 100).toFixed(2) + &#39;%&#39;+&#39;，销售额：&#39;+ params.value[1];&#125;&quot;
                )
#                 trigger&#x3D;&quot;axis&quot;, axis_pointer_type&#x3D;&quot;cross&quot;
            ),</code></pre>
<h3 id="pyecharts画时间排序图"><a href="#pyecharts画时间排序图" class="headerlink" title="pyecharts画时间排序图"></a>pyecharts画时间排序图</h3></li>
</ul>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">from pyecharts import options as opts
from pyecharts.charts import Bar,Timeline
from pyecharts.faker import Faker
import random
import pandas as pd
import numpy as np

# 受这篇文章启发https:&#x2F;&#x2F;blog.csdn.net&#x2F;weixin_42512684&#x2F;article&#x2F;details&#x2F;108176613
data &#x3D; np.array([random.randint(30,150) for i in range(52*7) ]).reshape(52,7)
df &#x3D; pd.DataFrame(data,index&#x3D;[i for i in range(1969,2021)],columns &#x3D; random.sample(attr, len(attr)))
df</code></pre>

<pre class="line-numbers language-python" data-language="python"><code class="language-python">df_sorted &#x3D; [r[:].sort_values() for i,r in df.iterrows()]
df_sorted[0].values
t1  &#x3D; Timeline()# 创建 Timeline对象

for j in range(1969,2021):
    bar &#x3D; (
    Bar()
    .add_xaxis([str(i) for i in df_sorted[j-1969].index])
    .add_yaxis(&#39;Data&#39;,[int(i) for i in df_sorted[j-1969].values]
               ,label_opts &#x3D; opts.LabelOpts(position &#x3D; &#39;right&#39;),
             )
    .set_series_opts(label_opts &#x3D; opts.LabelOpts(is_show &#x3D; True,position &#x3D; &#39;right&#39;))
    .reversal_axis()
    .set_global_opts(title_opts &#x3D; opts.TitleOpts(&quot;&#123;&#125;&quot;.format(j),
                                                 pos_left &#x3D; &#39;50%&#39;,

                                                ),
                    legend_opts &#x3D; opts.LegendOpts(pos_right &#x3D; &#39;10%&#39;))

    )

    t1.add(bar,&#39;&#123;&#125;年&#39;.format(j))
    
t1.add_schema(
symbol &#x3D; &#39;arrow&#39;,# 设置标记时间；
    #orient &#x3D; &#39;vertical&#39;,
     symbol_size &#x3D; 2,# 标记大小;
    play_interval &#x3D; 1000,# 播放时间间隔；
    control_position &#x3D; &#39;right&#39;,# 控制位置;
linestyle_opts &#x3D; opts.LineStyleOpts(width &#x3D; 5,
                                   type_ &#x3D; &#39;dashed&#39;,
                                   color &#x3D; &#39;rgb(255,0,0,0.5)&#39;),
    label_opts &#x3D; opts.LabelOpts(color &#x3D; &#39;rgb(0,0,255,0.5)&#39;,
                                    font_size &#x3D; 15,
                                    font_style &#x3D; &#39;italic&#39;,
                                    font_weight &#x3D; &#39;bold&#39;,
                                     font_family &#x3D;&#39;Time New Roman&#39;,

                                position &#x3D; &#39;left&#39;,
                                interval &#x3D; 20,
                                    )
)
t1.render_notebook()</code></pre>

<h1 id="pyecharts画地理图-geo-map"><a href="#pyecharts画地理图-geo-map" class="headerlink" title="pyecharts画地理图-geo,map"></a>pyecharts画地理图-geo,map</h1><pre class="line-numbers language-python" data-language="python"><code class="language-python">def my_geo(city, city_value):
    c &#x3D; (
        Geo(init_opts&#x3D;opts.InitOpts(theme&#x3D;ThemeType.DARK,chart_id&#x3D;1))
            .add_schema(maptype&#x3D;&quot;china&quot;)
            .add(&quot;geo&quot;, [list(z) for z in zip(city, city_value)])
            .set_series_opts(label_opts&#x3D;opts.LabelOpts(is_show&#x3D;False))
            .set_global_opts(
            visualmap_opts&#x3D;opts.VisualMapOpts(), title_opts&#x3D;opts.TitleOpts(title&#x3D;&quot;用户城市分布&quot;)
        )  # .render(&quot;geo_base.html&quot;)
    )
    return c</code></pre>
<p>is_piecewise参数：在 set_global_opts()中的visualmap_opts=opts.VisualMapOpts(is_piecewise=True),表示分段显示；</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">def my_map(province, num):
    c &#x3D; (
        Map(init_opts&#x3D;opts.InitOpts(theme&#x3D;ThemeType.DARK,chart_id&#x3D;2))
            .add(&quot;map&quot;, [list(z) for z in zip(province, num)], &quot;china&quot;)
            .set_series_opts(label_opts&#x3D;opts.LabelOpts(is_show&#x3D;False))
            .set_global_opts(visualmap_opts&#x3D;opts.VisualMapOpts(), title_opts&#x3D;opts.TitleOpts(title&#x3D;&quot;用户省份分布&quot;))
    )  # .render(&quot;map_base.html&quot;)
    return c</code></pre>
<h1 id="pyecharts画内层嵌套饼图"><a href="#pyecharts画内层嵌套饼图" class="headerlink" title="pyecharts画内层嵌套饼图"></a>pyecharts画内层嵌套饼图</h1><pre class="line-numbers language-python" data-language="python"><code class="language-python">c &#x3D; (
    Pie()
    .add(&quot;&quot;, [list(z) for z in zip(Faker.choose(), Faker.values())])#center&#x3D;[&quot;35%&quot;, &quot;50%&quot;],
    .set_global_opts(title_opts&#x3D;opts.TitleOpts(title&#x3D;&quot;Pie-基本示例&quot;))#legend_opts&#x3D;opts.LegendOpts(pos_left&#x3D;&quot;15%&quot;),
    .set_series_opts(label_opts&#x3D;opts.LabelOpts(formatter&#x3D;&quot;&#123;b&#125;: &#123;c&#125;&quot;))
#     .render(&quot;pie_base.html&quot;)
)
c.render_notebook()</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/zhang18340082962/image-rick@master/image-rick/6460608-109a65be286830ab.wpn8qntfni8.png"></p>
<h1 id="内嵌饼图nested-pies"><a href="#内嵌饼图nested-pies" class="headerlink" title="内嵌饼图nested_pies"></a>内嵌饼图nested_pies</h1><pre class="line-numbers language-python" data-language="python"><code class="language-python">inner_x_data &#x3D; [&quot;直达&quot;, &quot;营销广告&quot;, &quot;搜索引擎&quot;]
inner_y_data &#x3D; [335, 679, 1548]
inner_data_pair &#x3D; [list(z) for z in zip(inner_x_data, inner_y_data)]

outer_x_data &#x3D; [&quot;直达&quot;, &quot;营销广告&quot;, &quot;搜索引擎&quot;, &quot;邮件营销&quot;, &quot;联盟广告&quot;, &quot;视频广告&quot;, &quot;百度&quot;, &quot;谷歌&quot;]
outer_y_data &#x3D; [335, 310, 234, 135, 1048, 251, 147, 102]
outer_data_pair &#x3D; [list(z) for z in zip(outer_x_data, outer_y_data)]
(
    Pie(init_opts&#x3D;opts.InitOpts())#theme&#x3D;ThemeType.DARK 指定主题为黑色
    .add(
        series_name&#x3D;&quot;访问来源&quot;,
        data_pair&#x3D;inner_data_pair,#指定数据源
        radius&#x3D;[0, &quot;30%&quot;],#半径 
        label_opts&#x3D;opts.LabelOpts(position&#x3D;&quot;inner&quot;),#图形位置
    )
    .add(
        series_name&#x3D;&quot;访问来源&quot;,
        radius&#x3D;[&quot;40%&quot;, &quot;55%&quot;],
        data_pair&#x3D;outer_data_pair,
        label_opts&#x3D;opts.LabelOpts(
            position&#x3D;&quot;outside&quot;,
            formatter&#x3D;&quot;&#123;a|&#123;a&#125;&#125;&#123;abg|&#125;\n&#123;hr|&#125;\n &#123;b|&#123;b&#125;: &#125;&#123;c&#125; &#123;per|&#123;d&#125;%&#125;  &quot;,#&quot;&#123;a&#125; &lt;br&#x2F;&gt;&#123;b&#125;: &#123;c&#125; (&#123;d&#125;%)&quot; 文本样式
            background_color&#x3D;&quot;#eee&quot;,  #背景颜色
            border_color&#x3D;&quot;#aaa&quot;,  #边框颜色
            border_width&#x3D;1,   #边框宽度
            border_radius&#x3D;4,  #边界半径
            rich&#x3D;&#123;
                &quot;a&quot;: &#123;&quot;color&quot;: &quot;#999&quot;, &quot;lineHeight&quot;: 22, &quot;align&quot;: &quot;center&quot;&#125;,
                &quot;abg&quot;: &#123;
                    &quot;backgroundColor&quot;: &quot;#e3e3e3&quot;,
                    &quot;width&quot;: &quot;100%&quot;,
                    &quot;align&quot;: &quot;right&quot;,
                    &quot;height&quot;: 22,
                    &quot;borderRadius&quot;: [4, 4, 0, 0],
                &#125;,
                &quot;hr&quot;: &#123;
                    &quot;borderColor&quot;: &quot;#aaa&quot;,
                    &quot;width&quot;: &quot;100%&quot;,
                    &quot;borderWidth&quot;: 0.5,
                    &quot;height&quot;: 0,
                &#125;,
                &quot;b&quot;: &#123;&quot;fontSize&quot;: 16, &quot;lineHeight&quot;: 33&#125;,#,&quot;color&quot;:&quot;#999&quot;
#                 &quot;c&quot;:&#123;&quot;color&quot;:&quot;#999&quot;&#125;,
                &quot;per&quot;: &#123;
                    &quot;color&quot;: &quot;#eee&quot;,
                    &quot;backgroundColor&quot;: &quot;#334455&quot;,
                    &quot;padding&quot;: [2, 4],
                    &quot;borderRadius&quot;: 2,
                &#125;,
            &#125;,
        ),
    )
    .set_global_opts(legend_opts&#x3D;opts.LegendOpts(pos_left&#x3D;&quot;left&quot;, orient&#x3D;&quot;vertical&quot;,textstyle_opts&#x3D;&#123;&quot;color&quot;:&quot;#999&quot;&#125;))#设置图例字体为白色
    .set_series_opts(
        tooltip_opts&#x3D;opts.TooltipOpts(
            trigger&#x3D;&quot;item&quot;, formatter&#x3D;&quot;&#123;a&#125; &lt;br&#x2F;&gt;&#123;b&#125;: &#123;c&#125; (&#123;d&#125;%)&quot;    # &#39;item&#39;: 数据项图形触发，主要在散点图，饼图等无类目轴的图表中使用。
        )
    )
#     .render(&quot;nested_pies.html&quot;)
).render_notebook()</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/zhang18340082962/image-rick@master/image-rick/6460608-85a5b5d8ee7790a8.5qowy1o8a20.png"></p>
<p>那个formatter配置项可以在这里了解：<br>{a}（系列名称），{b}（数据项名称），{c}（数值）, {d}（百分比）<br><a href="https://echarts.apache.org/zh/option.html#grid.tooltip.formatter">https://echarts.apache.org/zh/option.html#grid.tooltip.formatter</a></p>
<h1 id="pyecharts中page的使用类似BI大屏展示"><a href="#pyecharts中page的使用类似BI大屏展示" class="headerlink" title="pyecharts中page的使用类似BI大屏展示"></a>pyecharts中page的使用类似BI大屏展示</h1><pre class="line-numbers language-python" data-language="python"><code class="language-python">page &#x3D; Page(layout&#x3D; Page.DraggablePageLayout, page_title&#x3D; &quot;大屏展示&quot;)
# page &#x3D; Page()
page.add(
    bar_datazoom_slider(),
    line_markpoint(),
    pie_rosetype(),
    grid_mutil_yaxis(),
    liquid_data_precision(),
    table_base(),
)
page.render(&quot;temp.html&quot;)</code></pre>
<p>然后自己点那开个temp.html文件进行拖拽，缩放，布局称自己想要的样子，最后点击save_config按钮，下载那个chart_config.json文件。</p>
<h3 id="不带标题，修改配置文件为百分比"><a href="#不带标题，修改配置文件为百分比" class="headerlink" title="不带标题，修改配置文件为百分比"></a>不带标题，修改配置文件为百分比</h3><ul>
<li><p>修改json配置文件，改成百分比主要是为了页面自适应屏幕大小。</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">df &#x3D; pd.read_json(&quot;chart_config.json&quot;)
df[&quot;width&quot;] &#x3D; df.width.apply(lambda x: x[:-2])
df[&quot;height&quot;] &#x3D; df.height.apply(lambda x: x[:-2])
df[&quot;top&quot;] &#x3D; df.top.apply(lambda x: x[:-2])
df[&quot;left&quot;] &#x3D; df.left.apply(lambda x: x[:-2])
# df.astype(&#123;&#39;width&#39;:&#39;float&#39;,&#39;height&#39;:&#39;float&#39;,&#39;top&#39;:&#39;float&#39;,&#39;height&#39;:&#39;float&#39;&#125;).dtypes
df[&quot;width&quot;]&#x3D; df.width.apply(lambda x: str(round(float(x)&#x2F;1256*100,4))+&quot;%&quot;)#这里1256、640是你自己电脑屏幕的px值
df[&quot;height&quot;] &#x3D; df.height.apply(lambda x: str(round(float(x)&#x2F;640*100*11&#x2F;12,4))+&quot;%&quot;)#如果出现右侧滑块，可适当进行缩放，这里按11&#x2F;12的比例缩放
df[&quot;top&quot;] &#x3D; df.top.apply(lambda x: str(round(float(x)&#x2F;640*100*11&#x2F;12,4))+&quot;%&quot;)
df[&quot;left&quot;] &#x3D; df.left.apply(lambda x: str(round(float(x)&#x2F;1256*100,4))+&quot;%&quot;)
df.to_json(&quot;chart_config2.json&quot;,orient &#x3D; &quot;records&quot;)</code></pre></li>
<li><p>修改好json数据之后，再运行这行代码</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">#第一个字段是前面拖拽的html文件名，cfg_file就是你刚save的json文件名，dest是你要生成的文件名
page.save_resize_html( &#39;temp.html&#39;, cfg_file&#x3D; &#39;chart_config2.json&#39;,dest&#x3D; &#39;设置好位置后的BI看板.html&#39;)</code></pre>
<h3 id="加上标题，可自定义html"><a href="#加上标题，可自定义html" class="headerlink" title="加上标题，可自定义html"></a>加上标题，可自定义html</h3></li>
</ul>
<p>这样弄完有点问题就是背景页面可能和图片背景有违和感，你可以使用BeautifulSoup再修改下页面背景颜色啥的,相关网课链接<a href="https://www.bilibili.com/video/BV1KT4y1c7pb?p=22">https://www.bilibili.com/video/BV1KT4y1c7pb?p=22</a></p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">from bs4 import BeautifulSoup
import os

#这里要先读取那个json文件

with open(os.path.join(os.path.abspath(&quot;.&quot;), &quot;设置好位置后的BI看板.html&quot;), &#39;r+&#39;, encoding&#x3D;&quot;utf8&quot;) as html:
    html_bf &#x3D; BeautifulSoup(html, &quot;lxml&quot;)
    divs &#x3D; html_bf.find_all(&quot;div&quot;)
    #读取config_json文件，循环写入到HTML
    for i in range(len(df_config)):
        width &#x3D; df_config.loc[i,&#39;width&#39;]
        height &#x3D; df_config.loc[i,&#39;height&#39;]
        top &#x3D; df_config.loc[i,&#39;top&#39;]
        left &#x3D; df_config.loc[i,&#39;left&#39;]
        divs[i+1][&quot;style&quot;] &#x3D; f&quot;width:&#123;width&#125;;height:&#123;height&#125;;position:absolute;top:&#123;top&#125;;left:&#123;left&#125;;&quot;
        
    body &#x3D; html_bf.find(&quot;body&quot;)
    body[&quot;style&quot;]&#x3D;&quot;background-color:#333333;&quot;
#     div_title &#x3D; &quot;&lt;div align&#x3D;\&quot;center\&quot; style&#x3D;\&quot;width:100%;\&quot;&gt;\n&lt;span style&#x3D;\&quot;font-size:30px;font face&#x3D;\&#39;微软雅黑\&#39;;color :#FFFFFF\&quot;&gt;&lt;b&gt;CD_NOW数据看板&lt;&#x2F;b&gt;&lt;&#x2F;div&gt;&quot;  # 修改页面背景色、追加标题
#     body.insert(0, BeautifulSoup(div_title, &quot;lxml&quot;).div)
    html_new &#x3D; str(html_bf)
    html.seek(0, 0)
    html.truncate()
    html.write(html_new)
    html.close()</code></pre>
<p>当然也可以把那个json文件里面的值传到对应的样式代码中在HTML页面中进行布局，需要注意的是画图时指定好每个图表的chart_id,便于通过字符串格式进行指定对应图表位置。</p>
<p>注意点：（来自<a href="https://www.jianshu.com/p/47e8f056e5cf%EF%BC%89">https://www.jianshu.com/p/47e8f056e5cf）</a><br>1.由于图片的布局是根据chart_config.json中图片id的对应关系进行布局，因此每张图片均需要指定其id；<br>如：<br>Bar(init_opts=opts.InitOpts(chart_id=1))<br>2.在本次操作工程中，发现Table类中不包含init_opts参数，可以通过修改源码，在D:\Anaconda3\Lib\site-packages\pyecharts\component\table指定char_id,具体修改的代码如下：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">class Table(ChartMixin):
    def __init__(self, page_title: str &#x3D; CurrentConfig.PAGE_TITLE, js_host: str &#x3D; &quot;&quot;,chart_id&#x3D;None):
        self.page_title &#x3D; page_title
        self.js_host &#x3D; js_host or CurrentConfig.ONLINE_HOST
        self.js_dependencies: OrderedSet &#x3D; OrderedSet()
        self.js_functions: OrderedSet &#x3D; OrderedSet()
        self.title_opts: ComponentTitleOpts &#x3D; ComponentTitleOpts()
        self.html_content: str &#x3D; &quot;&quot;
        self._component_type: str &#x3D; &quot;table&quot;
        if chart_id:
            self.chart_id: str &#x3D; chart_id
        else:
            self.chart_id: str &#x3D; uuid.uuid4().hex</code></pre>
<p><a href="https://www.bilibili.com/video/BV1KT4y1c7pb">https://www.bilibili.com/video/BV1KT4y1c7pb</a> 网课里有学习资源自己去看</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title>python电影数据分析</title>
    <url>//post/python%E7%94%B5%E5%BD%B1%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90.html</url>
    <content><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/zhang18340082962/image-rick@master/image-rick/%E5%9B%BE%E7%89%87.3pbn6ny481hc.png"></p>
<h1 id="一、数据概述"><a href="#一、数据概述" class="headerlink" title="一、数据概述"></a>一、数据概述</h1><p>id：标识号<br>imdb_id：IMDB 标识号<br>popularity：在 Movie Database 上的相对页面查看次数<br>budget：预算（美元）<br>revenue：收入（美元）<br>original_title：电影名称<br>cast：演员列表，按 | 分隔，最多 5 名演员<br>homepage：电影首页的 URL<br>director：导演列表，按 | 分隔，最多 5 名导演<br>tagline：电影的标语<br>keywords：与电影相关的关键字，按 | 分隔，最多 5 个关键字<br>overview：剧情摘要<br>runtime：电影时长<br>genres：风格列表，按 | 分隔，最多 5 种风格<br>production_companies：制作公司列表，按 | 分隔，最多 5 家公司<br>release_date：首次上映日期<br>vote_count：评分次数<br>vote_average：平均评分<br>based on novel 是否由小说改编</p>
<h1 id="二、提出问题"><a href="#二、提出问题" class="headerlink" title="二、提出问题"></a>二、提出问题</h1><p>每年上映电影数量、电影总票房表现？<br>电影票房与哪些因素最相关？<br>各类型电影表现？<br>各电影类型之间的关联性<br>原创电影与改编电影有何差异？<br>受众喜好与那些因素有关？电影时长为多少最合适？<br>Universal Pictures与Paramount Pictures两家行业巨头的业绩如何？</p>
<h1 id="三、每年上映电影数量、电影总票房是多少？"><a href="#三、每年上映电影数量、电影总票房是多少？" class="headerlink" title="三、每年上映电影数量、电影总票房是多少？"></a>三、每年上映电影数量、电影总票房是多少？</h1><p><img src="https://cdn.jsdelivr.net/gh/zhang18340082962/image-rick@master/image-rick/%E5%9B%BE%E7%89%87.6b4rg4rm8f0g.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhang18340082962/image-rick@master/image-rick/%E5%9B%BE%E7%89%87.2zjbppvcxm2o.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhang18340082962/image-rick@master/image-rick/%E5%9B%BE%E7%89%87.nkkuasvv4ww.png"></p>
<p>电影工业在最近三十几年呈现稳步式增长，2014年数量最多。虽然电影数量最近二十年内有3次较大的波动，但电影总票房仍然保持在较高的水准，说明电影市场已经成熟，有固定的消费人群，可见投资电影仍然是很好的投资方式。</p>
<h1 id="四、电影票房与哪些因素最相关？"><a href="#四、电影票房与哪些因素最相关？" class="headerlink" title="四、电影票房与哪些因素最相关？"></a>四、电影票房与哪些因素最相关？</h1><p><img src="https://cdn.jsdelivr.net/gh/zhang18340082962/image-rick@master/image-rick/%E5%9B%BE%E7%89%87.n21iikmlnb.png"></p>
<p>由以上可知，电影票房与电影预算（0.73），受欢迎度（0.66），评价次数（0.78）存在强相关。 绘制电影票房与受欢迎度，评价次数，电影预算的相关性散点图及其线性回归线。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhang18340082962/image-rick@master/image-rick/%E5%9B%BE%E7%89%87.402wi8il56kg.png"></p>
<p>如图，电影预算、评分基本与电影票房呈正线性相关的关系，这也符合正常经济规律。</p>
<h1 id="五、各类型电影表现？"><a href="#五、各类型电影表现？" class="headerlink" title="五、各类型电影表现？"></a>五、各类型电影表现？</h1><p><img src="https://cdn.jsdelivr.net/gh/zhang18340082962/image-rick@master/image-rick/%E5%9B%BE%E7%89%87.4yo6dofyk6bk.png"></p>
<p>约从1992开始，电影市场开始爆发式增长，其中戏剧类（Drama）和喜剧类（Comedy）这两个类型是随时间增长幅度最大的，现在也比较热门。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhang18340082962/image-rick@master/image-rick/%E5%9B%BE%E7%89%87.6w6fy2r0f75s.png"></p>
<p>如上图，可见投资一部电影的话，上图中的类型是最好的选择，尤以comedy和drama最佳。那不同类型电影的盈利能力如何呢？</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhang18340082962/image-rick@master/image-rick/%E5%9B%BE%E7%89%87.1jep74ld6qgw.png"></p>
<p>电影关键词主要以based on novel（基于小说）、women（女性）、independent film（独立电影）、murder（谋杀）为主</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhang18340082962/image-rick@master/image-rick/%E5%9B%BE%E7%89%87.64w9itd55j40.png"></p>
<p>由图可知，平均收益前3的电影类型为：冒险类（Adventure）、科幻类（Fantasy）、动画类（Animation），而外国电影类（Foreign）和电视电影类（TV Movie）有亏损的风险。</p>
<h1 id="六、各电影类型之间关联性"><a href="#六、各电影类型之间关联性" class="headerlink" title="六、各电影类型之间关联性"></a>六、各电影类型之间关联性</h1><p><img src="https://cdn.jsdelivr.net/gh/zhang18340082962/image-rick@master/image-rick/%E5%9B%BE%E7%89%87.2uu5wutrq6m8.png"></p>
<p>(Animation)与(Family)、(Adventure, Thriller)与(Action)、(Fantasy) 与(Family)、(Thriller, Drama)与(Crime) 在支持度阈值2.5%，提升度为3 的情况下，表现出较强的关联性，也符合人们的生活常识</p>
<h1 id="七、原创电影与改编电影有何差异？"><a href="#七、原创电影与改编电影有何差异？" class="headerlink" title="七、原创电影与改编电影有何差异？"></a>七、原创电影与改编电影有何差异？</h1><p><img src="https://cdn.jsdelivr.net/gh/zhang18340082962/image-rick@master/image-rick/%E5%9B%BE%E7%89%87.4oeqnee8dpj4.png"></p>
<p>可见，绝大部分电影还是原创为主。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhang18340082962/image-rick@master/image-rick/%E5%9B%BE%E7%89%87.3o19mntggc5c.png"></p>
<p>原创电影的利润与改编电影相差一倍多。</p>
<h1 id="八、受众喜好与那些因素有关？电影时长为多少最合适？"><a href="#八、受众喜好与那些因素有关？电影时长为多少最合适？" class="headerlink" title="八、受众喜好与那些因素有关？电影时长为多少最合适？"></a>八、受众喜好与那些因素有关？电影时长为多少最合适？</h1><p><img src="https://cdn.jsdelivr.net/gh/zhang18340082962/image-rick@master/image-rick/%E5%9B%BE%E7%89%87.1cg3xbzwubz4.png"></p>
<p>受众欢迎度较高的电影类型为Adventure，Science Fiction ，Fantasy。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhang18340082962/image-rick@master/image-rick/%E5%9B%BE%E7%89%87.777udesc9r7k.png"></p>
<p>受众欢迎度较高的电影的时长基本在90-200分钟之间。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhang18340082962/image-rick@master/image-rick/%E5%9B%BE%E7%89%87.33vaixewp474.png"></p>
<p>受欢迎度高的电影，评分肯定高。反之评分高的电影，受欢迎度可能低，这就是冷门好片的天地。</p>
<h1 id="九、Universal-Pictures与Paramount-Pictures两家行业巨头的业绩如何？"><a href="#九、Universal-Pictures与Paramount-Pictures两家行业巨头的业绩如何？" class="headerlink" title="九、Universal Pictures与Paramount Pictures两家行业巨头的业绩如何？"></a>九、Universal Pictures与Paramount Pictures两家行业巨头的业绩如何？</h1><p><img src="https://cdn.jsdelivr.net/gh/zhang18340082962/image-rick@master/image-rick/%E5%9B%BE%E7%89%87.2h5jra486agw.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhang18340082962/image-rick@master/image-rick/%E5%9B%BE%E7%89%87.26kanvogyxwg.png"></p>
<p>两家公司制作的主要电影类型几乎一致，戏剧类（Drama）、喜剧类（Comedy）、惊悚类（Thriller）、动作类（Action）占据了两家公司制作总量的60%左右，这与总的各类型电影数量分布也是相似的，可供其他公司参考其布局策略。</p>
<h1 id="十、结论"><a href="#十、结论" class="headerlink" title="十、结论"></a>十、结论</h1><p>目前电影市场成熟，产量和票房都处于较高的水平；<br>电影的预算、评价会直接影响电影票房，故一定的电影预算是电影票房成功的基础；<br>(Animation)与(Family)、(Adventure, Thriller)与(Action)、(Fantasy) 与(Family)、(Thriller, Drama)与(Crime) 在给定阈值下有较强的关联性。<br>最受欢迎的电影类型是comedy和drama，投资这两个类型的电影是不错的选择；<br>(Universal Pictures)的电影数量多于(Paramount Pictures)，两者票房表现不相上下。<br>原创电影在电影工业中占绝对主导地位，因此应重视编剧和剧本的选择；<br>电影时长应控制在90～200分钟，最符合观众的观影习惯，也最易获得成功。</p>
<h1 id="十一、Python代码"><a href="#十一、Python代码" class="headerlink" title="十一、Python代码"></a>十一、Python代码</h1><h4 id="导入包"><a href="#导入包" class="headerlink" title="导入包"></a>导入包</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python">import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
%matplotlib inline
import seaborn as sns
from wordcloud import WordCloud
from mlxtend.frequent_patterns import apriori
from mlxtend.frequent_patterns import association_rules
plt.rcParams[&#39;font.sans-serif&#39;] &#x3D; [&#39;SimHei&#39;]#显示中文
plt.style.use(&#39;ggplot&#39;)</code></pre>
<h5 id="使用apriori算法进行关联规则挖掘"><a href="#使用apriori算法进行关联规则挖掘" class="headerlink" title="使用apriori算法进行关联规则挖掘"></a>使用apriori算法进行关联规则挖掘</h5><pre class="line-numbers language-python" data-language="python"><code class="language-python">path &#x3D; &#39;D:&#x2F;python_data_file&#x2F;based_on_novel.csv&#39;
data &#x3D; pd.read_csv(path)

movie_genres &#x3D; pd.DataFrame(data,columns&#x3D;[&#39;original_title&#39;,&#39;genres&#39;])
movies_ohe &#x3D; movie_genres.drop(&#39;genres&#39;,1).join(movie_genres.genres.str.get_dummies())
# print(movies_ohe.shape)#(10866, 21)
movies_ohe.set_index([&#39;original_title&#39;],inplace&#x3D;True)

frequent_itemsets_movies &#x3D; apriori(movies_ohe,use_colnames&#x3D;True, min_support&#x3D;0.025)
result &#x3D; [i for i in frequent_itemsets_movies.itemsets if len(i)&gt;1]
# len(result)#37
rules_movies &#x3D;  association_rules(frequent_itemsets_movies, metric&#x3D;&#39;lift&#39;, min_threshold&#x3D;1.25)
# print(rules_movies)
rules_movies[(rules_movies.lift&gt;3)].sort_values(by&#x3D;[&#39;lift&#39;], ascending&#x3D;False)</code></pre>
<h5 id="处理数据"><a href="#处理数据" class="headerlink" title="处理数据"></a>处理数据</h5><pre class="line-numbers language-python" data-language="python"><code class="language-python">xdata &#x3D; data[[&#39;id&#39;,&#39;popularity&#39;,&#39;production_companies&#39;,
              &#39;budget&#39;,&#39;revenue&#39;,&#39;original_title&#39;,&#39;runtime&#39;,&#39;release_date&#39;,&#39;genres&#39;,&#39;vote_count&#39;,&#39;vote_average&#39;,&#39;based on novel&#39;]]
#要求制造商和电影类型不能为空
clean_xdata &#x3D; xdata[xdata.production_companies.notnull()&amp;xdata.genres.notnull()].reset_index(drop&#x3D;True)
# 每年总票房
clean_xdata[&#39;year&#39;] &#x3D; pd.to_datetime(clean_xdata.release_date,format&#x3D;&#39;%Y-%m-%d&#39;).dt.year
year_revenue &#x3D; clean_xdata.groupby(&#39;year&#39;)[&#39;revenue&#39;].sum()
def pic_trend(data,tit,xlab,ylab):
    plt.figure(figsize&#x3D;(12,6))
    data.plot()
    plt.title(tit,fontsize &#x3D; 20)
    plt.xlabel(xlab,fontsize&#x3D;15)
    plt.ylabel(ylab,fontsize&#x3D;15)
    plt.show()
pic_trend(year_revenue,&#39;每年总票房统计&#39;,&#39;年份&#39;,&#39;总票房&#39;)
#每年上映电影数量统计
year_count &#x3D; clean_xdata.groupby(&#39;year&#39;).id.count()
pic_trend(year_count,&#39;每年上映电影数量统计&#39;,&#39;年份&#39;,&#39;上映电影数量&#39;)
#每年上映电影数量饼图
def pic_pie(data,val,gby,tit):
    data &#x3D; data.reset_index(drop&#x3D;False)
    fig &#x3D; plt.figure(figsize&#x3D;(16,8))
    plt.pie(data[val],labels&#x3D;data[gby],autopct&#x3D;&#39;%.1f%%&#39;)
    plt.title(tit,fontsize &#x3D; 15)
pic_pie(year_count,&#39;id&#39;,&#39;year&#39;,&#39;每年上映电影数量&#39;)</code></pre>
<h4 id="画走势图"><a href="#画走势图" class="headerlink" title="画走势图"></a>画走势图</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 随时间推移如何发生变化的
genre_df &#x3D; clean_xdata.genres.str.get_dummies()#构建虚拟变量，相当于把各电影类型作为列名展开为一个稀疏矩阵
genre_df[&#39;release_date&#39;] &#x3D; clean_xdata[&#39;year&#39;]
genre_by_year &#x3D; genre_df.groupby(&#39;release_date&#39;).sum()
fig &#x3D; plt.figure(figsize&#x3D;(12,6))
plt.plot(genre_by_year,label &#x3D; genre_by_year.columns)
plt.legend(genre_by_year)
plt.xticks(range(1950,2020,10))
plt.title(&#39;电影类型随时间变动趋势图&#39;,fontsize&#x3D;20)
plt.xlabel(&#39;年份&#39;,fontsize &#x3D; 20)
plt.ylabel(&#39;数量&#39;,fontsize &#x3D; 20)

# ②电影类型数量分布
genre_sum &#x3D; genre_by_year.sum().sort_values(ascending &#x3D; False)
#这里的label参数加不加在图中没有任何变化
genre_sum.plot.barh(label&#x3D;&#39;genre&#39;,figsize &#x3D; (12,6))
plt.title(&#39;电影类型数量分布图&#39;,fontsize &#x3D; 20)
plt.xlabel(&#39;数量&#39;,fontsize&#x3D;20)
plt.ylabel(&#39;电影类型&#39;,fontsize&#x3D;20)
plt.show()</code></pre>
<h4 id="计算指标"><a href="#计算指标" class="headerlink" title="计算指标"></a>计算指标</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python"># （二）不同类型电影的盈利能力如何？
# 建立电影类型-利润数据框，计算各电影类型平均收益：
a &#x3D; clean_xdata.revenue - clean_xdata.budget
profit_df &#x3D; genre_df.join(pd.DataFrame(a,columns&#x3D;[&#39;profit&#39;]))

#计算个电影类型的利润平均值
#传递as_index&#x3D;False，把分组键的类型作为一列返回在DataFrame中，而不是默认True时作为Series的索引返回
genre_set &#x3D; clean_xdata[&#39;genres&#39;].str.get_dummies().columns.unique()
profit_by_genre &#x3D; pd.Series(index&#x3D;genre_set)
for genre in genre_set:
    profit_by_genre[genre] &#x3D; profit_df.groupby(genre,as_index &#x3D; False).profit.mean().loc[1,&#39;profit&#39;]
#画出各电影类型平均收益分布图
profit_by_genre.sort_values().plot.barh(label&#x3D;&#39;genre&#39;,figsize&#x3D;(12,6))
plt.title(&#39;各电影类型平均收益分布图&#39;,fontsize&#x3D;20)
plt.xlabel(&#39;利润&#39;,fontsize&#x3D;20)
plt.ylabel(&#39;电影类型&#39;,fontsize&#x3D;20)
plt.show()</code></pre>

<pre class="line-numbers language-python" data-language="python"><code class="language-python">original_recompose &#x3D; pd.DataFrame(clean_xdata[&#39;budget&#39;])
original_recompose.loc[:,&#39;profit&#39;] &#x3D; profit_df.profit
original_recompose[&#39;type&#39;] &#x3D; clean_xdata[&#39;based on novel&#39;].map(lambda x :1 if x&#x3D;&#x3D;&#39;based on novel&#39; else 0)
#原创或改编电影的预算与利润
#这个地方重新定义新的DataFrame --original_recompose_groupby用来存储各个指标分组后的均值（原创与改编电影概要）
original_recompose_groupby &#x3D; original_recompose.groupby(&#39;type&#39;).mean()
original_recompose_groupby[&#39;count&#39;] &#x3D; original_recompose.groupby(&#39;type&#39;).type.count()
original_recompose_groupby[&#39;profit_rate&#39;] &#x3D; original_recompose_groupby.profit&#x2F;original_recompose_groupby.budget#这里有细节,平均利润率
original_recompose_groupby.rename(index &#x3D; &#123;0:&#39;original&#39;,1:&#39;recompose&#39;&#125;,inplace &#x3D; True)#传递inplace&#x3D;True会删去原来的索引，否则会保留
#是否原创电影数量对比图
plt.figure(figsize &#x3D;(12,6))
original_recompose_groupby.loc[original_recompose_groupby.index,&#39;count&#39;].plot.bar()#传入loc【】里面的参数不能是；&#39;type&#39;,会报错
plt.title(&#39;原创改编电影数量对比&#39;,fontsize &#x3D; 20)
plt.xlabel(&#39;原创-改变&#39;,fontsize &#x3D; 20)
plt.ylabel(&#39;数量&#39;,fontsize &#x3D; 20)
plt.show()

#绘制利润柱状图
x&#x3D; list(range(len(original_recompose_groupby.index)))#索引长度序列
xl &#x3D; original_recompose_groupby.index#xl为索引实际值
fig &#x3D; plt.figure()
ax1&#x3D;fig.add_subplot(111)
plt.bar(x,original_recompose_groupby.profit)
#接下来有疑问？
plt.xticks(x,xl,rotation &#x3D; 0,fontsize&#x3D;12)
plt.yticks(fontsize&#x3D;15)
ax1.set_title(&#39;原创与改编电影平均利润对比&#39;,fontsize &#x3D; 20)
ax1.set_xlabel(&#39;原创-改变&#39;,fontsize &#x3D; 18)
ax1.set_ylabel(&#39;利润&#39;,fontsize &#x3D; 18)
ax1.legend(loc&#x3D;2,labels&#x3D;&#39;利润&#39;)

#绘制利润折线图
import matplotlib.ticker as mtick
ax2 &#x3D; ax1.twinx()
ax2.plot(x,original_recompose_groupby[&#39;profit_rate&#39;],&#39;go-&#39;,lw&#x3D;2)
fmt&#x3D;&#39;%.2f%%&#39;
yticks &#x3D; mtick.FormatStrFormatter(fmt)
ax2.yaxis.set_major_formatter(yticks)#次纵坐标标签设置为百分比显示
plt.yticks(fontsize &#x3D; 15)
ax2.set_ylabel(&#39;利润率&#39;,fontsize &#x3D; 18)
ax2.legend(loc&#x3D;4,labels &#x3D; &#39;profit_rate&#39;)#传递labels参数避免警告</code></pre>
<h4 id="生成词云"><a href="#生成词云" class="headerlink" title="生成词云"></a>生成词云</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python">keywords_data &#x3D; data[[&#39;id&#39;,&#39;popularity&#39;,&#39;production_companies&#39;,&#39;budget&#39;,&#39;revenue&#39;,&#39;original_title&#39;,&#39;runtime&#39;,&#39;release_date&#39;,&#39;genres&#39;,&#39;vote_count&#39;,&#39;vote_average&#39;,&#39;based on novel&#39;,&#39;keywords&#39;]]
keywords_data &#x3D; data[data.production_companies.notnull()&amp;data.genres.notnull()].reset_index(drop&#x3D;True)#得到 包含关键字keywords数据的列表
keywords_list1 &#x3D; []
for x in keywords_data.keywords.dropna():
    keywords_list1.append(x)
keywords_list1 &#x3D; &#39;&#39;.join(keywords_list1)
keywords_list1 &#x3D; keywords_list1.replace(&#39;\s&#39;,&#39;&#39;)#去除字符串中空字符串（\s用于匹配空白字符，可能是空格、制表符、其他空白））

wordcloud &#x3D; WordCloud(background_color&#x3D;&#39;black&#39;,max_words&#x3D;3000,scale&#x3D;1.5).generate(keywords_list1)
plt.figure(figsize&#x3D;(14,8))
plt.imshow(wordcloud)
plt.axis(&#39;off&#39;)
plt.show()</code></pre>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">popular_genre_df &#x3D; pd.concat([genre_df.iloc[:,:-1],clean_xdata.popularity],axis&#x3D;1)
#计算各类型电影受欢迎度均值
list &#x3D; []
for genre in genre_set:
    list.append(popular_genre_df.groupby(genre,as_index &#x3D; False).popularity.mean().loc[1,&#39;popularity&#39;])
popular_by_genre&#x3D; pd.DataFrame(index&#x3D;genre_set)
popular_by_genre[&#39;popularity_mean&#39;] &#x3D; list
#电影类型受欢迎度分布图
popular_by_genre.sort_values(by&#x3D;&#39;popularity_mean&#39;).plot.barh(figsize&#x3D;(14,8))
plt.title(&#39;电影类型受欢迎度分布图&#39;,fontsize&#x3D;20)
plt.xlabel(&#39;受欢迎度&#39;,fontsize&#x3D;20)
plt.ylabel(&#39;电影类型&#39;,fontsize&#x3D;20)
plt.show()
# ②电影时长与受众欢迎度
plt.scatter(clean_xdata.runtime,clean_xdata.popularity)
plt.title(&#39;时长与欢迎度散点图&#39;,fontsize&#x3D;20)
plt.xlabel(&#39;电影时长&#39;,fontsize&#x3D;20)
plt.ylabel(&#39;受欢迎度&#39;,fontsize&#x3D;20)
plt.show()
# ③电影评分与受众欢迎度
plt.scatter(clean_xdata.vote_average,clean_xdata.popularity)
plt.title(&#39;评分与欢迎度散点图&#39;,fontsize&#x3D;20)
plt.xlabel(&#39;电影评分&#39;,fontsize&#x3D;20)
plt.ylabel(&#39;受欢迎度&#39;,fontsize&#x3D;20)
plt.show()</code></pre>
<h4 id="Universal-Pictures与Paramount-Pictures"><a href="#Universal-Pictures与Paramount-Pictures" class="headerlink" title="Universal Pictures与Paramount Pictures"></a>Universal Pictures与Paramount Pictures</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python">companies_list &#x3D;[&#39;Universal Pictures&#39;,&#39;Paramount Pictures&#39;]
companies_df &#x3D; pd.DataFrame()
for company in companies_list:#各电影的电影商是否包含两者中其中一个，是则返回1，否则返回0
    companies_df[company] &#x3D;clean_xdata.production_companies.str.contains(company).map(lambda x :1 if x else 0)
companies_df &#x3D; pd.concat([companies_df,genre_df.iloc[:,:-1],profit_df.profit],axis&#x3D;1)
list &#x3D; []
for company in companies_list:
    list.append(companies_df.groupby(company,as_index&#x3D;False).profit.sum().loc[1,&#39;profit&#39;])
companies_profit&#x3D; pd.DataFrame(list,index &#x3D; companies_list,columns&#x3D;[&#39;profit_sum&#39;])
companies_profit.plot.bar(label &#x3D; companies_profit.index,figsize&#x3D;(8,6))
plt.title(&#39;两家公司利润对比&#39;,fontsize&#x3D;20)
plt.xticks(rotation &#x3D; 0)
plt.ylabel(&#39;利润&#39;,fontsize &#x3D; 20)
plt.show()

companies_df_1 &#x3D; companies_df.groupby(&#39;Universal Pictures&#39;)[[&#39;Action&#39;, &#39;Adventure&#39;, &#39;Animation&#39;, &#39;Comedy&#39;, &#39;Crime&#39;, &#39;Documentary&#39;,
       &#39;Drama&#39;, &#39;Family&#39;, &#39;Fantasy&#39;, &#39;Foreign&#39;, &#39;History&#39;, &#39;Horror&#39;, &#39;Music&#39;,
       &#39;Mystery&#39;, &#39;Romance&#39;, &#39;Science Fiction&#39;, &#39;TV Movie&#39;, &#39;Thriller&#39;, &#39;War&#39;,
       &#39;Western&#39;]].sum().loc[1,:]
companies_df_2 &#x3D; companies_df.groupby(&#39;Paramount Pictures&#39;)[[&#39;Action&#39;, &#39;Adventure&#39;, &#39;Animation&#39;, &#39;Comedy&#39;, &#39;Crime&#39;, &#39;Documentary&#39;,
       &#39;Drama&#39;, &#39;Family&#39;, &#39;Fantasy&#39;, &#39;Foreign&#39;, &#39;History&#39;, &#39;Horror&#39;, &#39;Music&#39;,
       &#39;Mystery&#39;, &#39;Romance&#39;, &#39;Science Fiction&#39;, &#39;TV Movie&#39;, &#39;Thriller&#39;, &#39;War&#39;,
       &#39;Western&#39;]].sum().loc[1,:]
company_genre_df &#x3D; pd.DataFrame([companies_df_1,companies_df_2],index &#x3D; [&#39;Universal Pictures&#39;,&#39;Paramount Pictures&#39;]).T
fig &#x3D; plt.figure(figsize&#x3D;(16,8))
ax1 &#x3D; fig.add_subplot(121)
plt.pie(company_genre_df[&#39;Universal Pictures&#39;],labels&#x3D;company_genre_df.index,autopct&#x3D;&#39;%.1f%%&#39;)
plt.title(&#39;Universal Pictures&#39;,fontsize &#x3D; 15)

ax2 &#x3D; fig.add_subplot(122)
plt.pie(company_genre_df[&#39;Paramount Pictures&#39;],labels&#x3D;company_genre_df.index,autopct&#x3D;&#39;%.1f%%&#39;)
plt.title(&#39;Paramount Pictures&#39;,fontsize&#x3D;15)</code></pre>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"># 电影票房与哪些因素最相关？
clean_xdata[[&#39;budget&#39;,&#39;popularity&#39;,&#39;release_date&#39;,&#39;runtime&#39;,&#39;vote_average&#39;,&#39;vote_count&#39;,&#39;revenue&#39;]].corr()
import seaborn as sns
revenue_corr &#x3D; clean_xdata[[&#39;budget&#39;,&#39;popularity&#39;,&#39;vote_count&#39;,&#39;revenue&#39;]]
fig &#x3D; plt.figure(figsize&#x3D;(18,6))
#电影票票房与电影预算相关性散点图

ax1 &#x3D; plt.subplot(1,3,1)
ax1 &#x3D; sns.regplot(x&#x3D;&#39;popularity&#39;, y&#x3D;&#39;revenue&#39;, data&#x3D;revenue_corr, x_jitter&#x3D;.1)
ax1.text(400,2e9,&#39;r&#x3D;0.64&#39;,fontsize&#x3D;15)
plt.title(&#39;revenue by popularity&#39;,fontsize&#x3D;15)
plt.xlabel(&#39;popularity&#39;,fontsize&#x3D;13)
plt.ylabel(&#39;revenue&#39;,fontsize&#x3D;13)
 
ax2 &#x3D; plt.subplot(1,3,2)
ax2 &#x3D; sns.regplot(x&#x3D;&#39;vote_count&#39;, y&#x3D;&#39;revenue&#39;, data&#x3D;revenue_corr, x_jitter&#x3D;.1,color&#x3D;&#39;g&#39;,marker&#x3D;&#39;+&#39;)
ax2.text(6800,1.1e9,&#39;r&#x3D;0.78&#39;,fontsize&#x3D;15)
plt.title(&#39;revenue by vote_count&#39;,fontsize&#x3D;15)
plt.xlabel(&#39;vote_count&#39;,fontsize&#x3D;13)
plt.ylabel(&#39;revenue&#39;,fontsize&#x3D;13)
 
ax3 &#x3D; plt.subplot(1,3,3)
ax3 &#x3D; sns.regplot(x&#x3D;&#39;budget&#39;, y&#x3D;&#39;revenue&#39;, data&#x3D;revenue_corr, x_jitter&#x3D;.1,color&#x3D;&#39;r&#39;,marker&#x3D;&#39;^&#39;)
ax3.text(1.6e8,2.2e9,&#39;r&#x3D;0.73&#39;,fontsize&#x3D;15)
plt.title(&#39;revenue by budget&#39;,fontsize&#x3D;15)
plt.xlabel(&#39;budget&#39;,fontsize&#x3D;13)
plt.ylabel(&#39;revenue&#39;,fontsize&#x3D;13)</code></pre>
<p>思路要明确，代码要简洁，以后尽量都写成函数。</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title>python数据采集：selenium爬虫、自动化</title>
    <url>//post/python%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86%EF%BC%9Aselenium%E7%88%AC%E8%99%AB%E3%80%81%E8%87%AA%E5%8A%A8%E5%8C%96.html</url>
    <content><![CDATA[<pre class="line-numbers language-none"><code class="language-none">中文文档https:&#x2F;&#x2F;python-selenium-zh.readthedocs.io&#x2F;zh_CN&#x2F;latest&#x2F;</code></pre>
<p>装包：pip install selenium<br>下载chrome：<a href="https://www.google.cn/chrome/">https://www.google.cn/chrome/</a><br>下驱动：<a href="https://chromedriver.storage.googleapis.com/index.html">https://chromedriver.storage.googleapis.com/index.html</a>  注意浏览器驱动 必须要和浏览器版本匹配<br>这是个zip包，下载下来之后，解压里面的程序文件 chromedriver.exe 到scripts路径下<br>跑一下看看感觉来了没有</p>
<pre class="line-numbers language-none"><code class="language-none">from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.support.wait import WebDriverWait

browser &#x3D; webdriver.Chrome()
try:
    browser.get(&#39;https:&#x2F;&#x2F;www.baidu.com&#39;)
    input &#x3D; browser.find_element_by_id(&#39;kw&#39;)
    input.send_keys(&#39;Python&#39;)
    input.send_keys(Keys.ENTER)
    wait &#x3D; WebDriverWait(browser, 10)
    wait.until(EC.presence_of_element_located((By.ID, &#39;content_left&#39;)))
    print(browser.current_url)
    print(browser.get_cookies())
    print(browser.page_source)
finally:hexo
    browser.close()</code></pre>
<p>不可能一下就会的，慢慢来</p>
<pre class="line-numbers language-none"><code class="language-none">https:&#x2F;&#x2F;blog.csdn.net&#x2F;weixin_54733110&#x2F;article&#x2F;details&#x2F;119027005  python万字博文教你玩嗨selenium库
https:&#x2F;&#x2F;mp.weixin.qq.com&#x2F;s?__biz&#x3D;MzI0OTc0MzAwNA&#x3D;&#x3D;&amp;mid&#x3D;2247487680&amp;idx&#x3D;1&amp;sn&#x3D;e40947f382116ff59761f250ee45dce3  模拟登录淘宝
https:&#x2F;&#x2F;www.pianshen.com&#x2F;article&#x2F;345981989&#x2F;  判断元素16种方法expected_conditions
https:&#x2F;&#x2F;github.com&#x2F;Python3WebSpider&#x2F;Python3WebSpider&#x2F;blob&#x2F;master&#x2F;7.1-Selenium%E7%9A%84%E4%BD%BF%E7%94%A8.md
http:&#x2F;&#x2F;www.byhy.net&#x2F;tut&#x2F;auto&#x2F;selenium&#x2F;01&#x2F;这个作者写的很好
https:&#x2F;&#x2F;www.bilibili.com&#x2F;video&#x2F;av64421994&#x2F;?p&#x3D;1简直是保姆级教学，
希望你学会了不要乱搞</code></pre>

]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>自动化</tag>
      </tags>
  </entry>
  <entry>
    <title>python酒类数据分析</title>
    <url>//post/python%E9%85%92%E7%B1%BB%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90.html</url>
    <content><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/zhang18340082962/image-rick@master/image-rick/%E5%9B%BE%E7%89%87.kf1spxcftw0.png"></p>
<h1 id="一、数据概述"><a href="#一、数据概述" class="headerlink" title="一、数据概述"></a>一、数据概述</h1><p>‘id’,’name’,’price’,’sales’,’ad_word’,’buy_act’,’vote_count’,’url’,’date’,’brand’分别为销售数据的商品ID，商品名称，单价，销量，广告词，促销活动，链接，日期，品牌。<br>以及自构属性‘amount’：销售额，‘month’：月份，‘price_level’：价格区间。</p>
<h1 id="二、提出问题"><a href="#二、提出问题" class="headerlink" title="二、提出问题"></a>二、提出问题</h1><p>1、行业大盘近期（2018/2/27）表现？各价位段表现？<br>总体表现，各价位表现，哪个价位的产品最火，各厂家表现？<br>近期各行业的广告词、促销活动怎么样<br>2、行业大盘总体态势怎样？<br>销量与评论数、单价的关系？<br>时间序列下的行业产品走势？<br>3、如何评价泸州老窖品牌？(可从多角度，规模增长趋势、产品结构等)<br>产品规模、增长趋势、友商竞争、行业水平？</p>
<h1 id="三、行业大盘近周期（2018-2-27）表现？各价位段表现？"><a href="#三、行业大盘近周期（2018-2-27）表现？各价位段表现？" class="headerlink" title="三、行业大盘近周期（2018/2/27）表现？各价位段表现？"></a>三、行业大盘近周期（2018/2/27）表现？各价位段表现？</h1><h3 id="行业大盘2018-2-27总体表现"><a href="#行业大盘2018-2-27总体表现" class="headerlink" title="行业大盘2018/2/27总体表现"></a>行业大盘2018/2/27总体表现</h3><p><img src="https://cdn.jsdelivr.net/gh/zhang18340082962/image-rick@master/image-rick/%E5%9B%BE%E7%89%87.4jvl2phdo45c.png"></p>
<h6 id="2018-2-27行业的总销售量为5-663030e-05，总评价数为1-255655e-06，总销售额达1-842307e-08。"><a href="#2018-2-27行业的总销售量为5-663030e-05，总评价数为1-255655e-06，总销售额达1-842307e-08。" class="headerlink" title="2018/2/27行业的总销售量为5.663030e+05，总评价数为1.255655e+06，总销售额达1.842307e+08。"></a>2018/2/27行业的总销售量为5.663030e+05，总评价数为1.255655e+06，总销售额达1.842307e+08。</h6><h6 id="平均单价价格为417元，平均销售642份，平均销售额达209115-4元"><a href="#平均单价价格为417元，平均销售642份，平均销售额达209115-4元" class="headerlink" title="平均单价价格为417元，平均销售642份，平均销售额达209115.4元"></a>平均单价价格为417元，平均销售642份，平均销售额达209115.4元</h6><h6 id="单价中位数199，说明少数高价位的酒提高了总体均值"><a href="#单价中位数199，说明少数高价位的酒提高了总体均值" class="headerlink" title="单价中位数199，说明少数高价位的酒提高了总体均值"></a>单价中位数199，说明少数高价位的酒提高了总体均值</h6><h6 id="销量中位数为148，说明少数及销量高的天数提升了平均交易量"><a href="#销量中位数为148，说明少数及销量高的天数提升了平均交易量" class="headerlink" title="销量中位数为148，说明少数及销量高的天数提升了平均交易量"></a>销量中位数为148，说明少数及销量高的天数提升了平均交易量</h6><h6 id="销售额中位数低于总体均值相差巨大，可能存在爆发交易的情况。"><a href="#销售额中位数低于总体均值相差巨大，可能存在爆发交易的情况。" class="headerlink" title="销售额中位数低于总体均值相差巨大，可能存在爆发交易的情况。"></a>销售额中位数低于总体均值相差巨大，可能存在爆发交易的情况。</h6><h6 id="一天中出现的最高交易量是21685份订单，最高交易额是65011630元，最高单价的白酒为6588元，最高评论数为67514条，最低为0条。"><a href="#一天中出现的最高交易量是21685份订单，最高交易额是65011630元，最高单价的白酒为6588元，最高评论数为67514条，最低为0条。" class="headerlink" title="一天中出现的最高交易量是21685份订单，最高交易额是65011630元，最高单价的白酒为6588元，最高评论数为67514条，最低为0条。"></a>一天中出现的最高交易量是21685份订单，最高交易额是65011630元，最高单价的白酒为6588元，最高评论数为67514条，最低为0条。</h6><h3 id="各价位表现"><a href="#各价位表现" class="headerlink" title="各价位表现"></a>各价位表现</h3><p><img src="https://cdn.jsdelivr.net/gh/zhang18340082962/image-rick@master/image-rick/%E5%9B%BE%E7%89%87.6dcpqx9r3pts.png"></p>
<p>在行业大盘最近一个周期内，可以看到销量最好和评论数最高的均是是100-200价位的白酒。<br>在价位50以下白酒销量和评论数出现大反差，在销量差距悬殊的情况下，该类白酒的评论数超过200-500价位白酒的评论数，但是销量偏低说明该类白酒在市场中有较高流行度的同时可能也存在较多的槽点。<br>中等价位（100-500）是市场的主要潮流所在，由中价位向低价位过度的产品（50-100）同样能稳住市场，获得较高的销量与人气。<br>3000以上的销量与评论数极低，符合当今社会人们财富资源分配或生活消费水平的差距，高消费人群只占极少数。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhang18340082962/image-rick@master/image-rick/%E5%9B%BE%E7%89%87.3ltt1wzyecxs.png"></p>
<p>1000-3000价位席卷市场，高单价情况下即时在低销量时也能远超越其他价位销售额。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhang18340082962/image-rick@master/image-rick/%E5%9B%BE%E7%89%87.2gkvdbfp9w3k.png"></p>
<p>基本呈现单价越高，评论数越少。人们总是低价商品的要求过于执着？</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhang18340082962/image-rick@master/image-rick/%E5%9B%BE%E7%89%87.52y9ub6wn7gg.png"></p>
<p>由于其1000-3000单价基数大，导致金额最大</p>
<h3 id="各厂家表现"><a href="#各厂家表现" class="headerlink" title="各厂家表现"></a>各厂家表现</h3><p><img src="https://cdn.jsdelivr.net/gh/zhang18340082962/image-rick@master/image-rick/%E5%9B%BE%E7%89%87.4sep09ocakcg.png"></p>
<p>最近一周期五粮液销量最高达到10万瓶以上，远领先于其他厂家。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhang18340082962/image-rick@master/image-rick/%E5%9B%BE%E7%89%87.3nszvh59q70g.png"></p>
<p>五粮液产品市场评论数最高，应该是广告宣传或者产品质量做得好。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhang18340082962/image-rick@master/image-rick/%E5%9B%BE%E7%89%87.3ar839q1g2io.png"></p>
<p>茅台近期销售总额位于行业最高水平，销售额近7500万。五粮液可能由于产品单价偏低，销售总额位居第三，接近2000万。</p>
<h3 id="最近一个周期广告、促销活动怎么做的？"><a href="#最近一个周期广告、促销活动怎么做的？" class="headerlink" title="最近一个周期广告、促销活动怎么做的？"></a>最近一个周期广告、促销活动怎么做的？</h3><p><img src="https://cdn.jsdelivr.net/gh/zhang18340082962/image-rick@master/image-rick/%E5%9B%BE%E7%89%87.6gq0tn4yo9og.png"></p>
<p>广告词一以‘天猫配送’，‘正品保证’等为主要标语，‘东方习酒’，‘猫超自营’，‘地道北京味’也是主要宣传方向。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhang18340082962/image-rick@master/image-rick/%E5%9B%BE%E7%89%87.5ancn0q8cccg.png"></p>
<p>促销活动主要以‘满一1或2送任意一件赠品，赠完为止’作为主要促销活动。</p>
<h1 id="四、行业大盘总体态势怎样？"><a href="#四、行业大盘总体态势怎样？" class="headerlink" title="四、行业大盘总体态势怎样？"></a>四、行业大盘总体态势怎样？</h1><h3 id="销量与单价、评论数的关系"><a href="#销量与单价、评论数的关系" class="headerlink" title="销量与单价、评论数的关系"></a>销量与单价、评论数的关系</h3><p><img src="https://cdn.jsdelivr.net/gh/zhang18340082962/image-rick@master/image-rick/%E5%9B%BE%E7%89%87.3mw3xybva7nk.png"></p>
<p>评论数量变化与销量基本呈线性变化。评论数代表市场反应，市场热度越高，销量越高。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhang18340082962/image-rick@master/image-rick/%E5%9B%BE%E7%89%87.4o6xp1btc9g.png"></p>
<p>单价与销量基本成反比例变化。单价越高，销量越低，单价越低，销量越高。<br>###时间序列下的行业产品走势<br><img src="https://cdn.jsdelivr.net/gh/zhang18340082962/image-rick@master/image-rick/%E5%9B%BE%E7%89%87.3dp2nbjq0t34.png"></p>
<p>200-500价位段的商品销量呈上升趋势，0-50和50-100的商品在2017年11月上升后出现持续下降，100-200的商品在上升后保持平稳，基本站稳市场。500-3000区间内商品在同年12月后出现小范围增长，因其单价基数较大，可能引起销售额大幅增长。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhang18340082962/image-rick@master/image-rick/%E5%9B%BE%E7%89%87.5ucvrzq2vfcw.png"></p>
<p>除0-50和3000以上产品外，其他商品都在2017年11月后出现销售额显著增长，推测可能是双十一以及其他促销活动，但是对0-50和3000以上的商品销售状态基本无影响。1000-3000区间商品在2017年12月过后出现直线式增长，100-500区间产品作为市场主力也出现增长趋势。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhang18340082962/image-rick@master/image-rick/%E5%9B%BE%E7%89%87.4ucsu4issccg.png"></p>
<p>3000月以上的酒类在11月出现价格大额下跌，其他区间商品单价均走势平稳。</p>
<h1 id="五、泸州老窖自身增长的趋势，产品结构，行业水平"><a href="#五、泸州老窖自身增长的趋势，产品结构，行业水平" class="headerlink" title="五、泸州老窖自身增长的趋势，产品结构，行业水平"></a>五、泸州老窖自身增长的趋势，产品结构，行业水平</h1><h3 id="泸州老窖产品规模"><a href="#泸州老窖产品规模" class="headerlink" title="泸州老窖产品规模"></a>泸州老窖产品规模</h3><p><img src="https://cdn.jsdelivr.net/gh/zhang18340082962/image-rick@master/image-rick/%E5%9B%BE%E7%89%87.t3dlkrd7ojk.png"></p>
<p>泸州老窖品牌主打50-500价位产品覆盖市场，其中3000+超高价酒类占比与0-50低价品类占比最低，均低于500-3000档位，说明泸州老窖在市场的品牌形象与战略目标是做好中高端酒类产品。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhang18340082962/image-rick@master/image-rick/%E5%9B%BE%E7%89%87.2jviql0m0lc0.png"></p>
<p>在2017年12月产品规模突然增大，应该是与行业竞争或市场需求相关。 </p>
<p><img src="https://cdn.jsdelivr.net/gh/zhang18340082962/image-rick@master/image-rick/%E5%9B%BE%E7%89%87.nkodwqpgads.png"></p>
<p>销量在十一月份出现大幅增长，持续到次年一月份出现显著下降。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhang18340082962/image-rick@master/image-rick/%E5%9B%BE%E7%89%87.hxptteb9rh.png"></p>
<p>总销售额与销量表现相似，也是在十一月份出现大幅增长，持续到次年一月份出现显著下降。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhang18340082962/image-rick@master/image-rick/%E5%9B%BE%E7%89%87.5cjonwptotq8.png"></p>
<p>0-50区间产品在十一月后大幅增长，后持续衰弱。50-500区间商品同期均出现显著增长，后缓慢下降趋于稳定。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhang18340082962/image-rick@master/image-rick/%E5%9B%BE%E7%89%87.2n30ocmjuzr4.png"></p>
<p>200-500与1000-3000区间商品由于其单价基数较大，在同年十一月销量保证的前提下，出现大幅增长。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhang18340082962/image-rick@master/image-rick/%E5%9B%BE%E7%89%87.4843aw978akg.png"></p>
<p>3000+产品在2017年7月-9月出现波动后趋于平稳。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhang18340082962/image-rick@master/image-rick/%E5%9B%BE%E7%89%87.3g6dp00zw7cw.png"></p>
<p>17年9月可能出现了一些问题，除500-1000区间外，都出现了先增后降的趋势。</p>
<h3 id="那种广告词、促销标语出现的最多"><a href="#那种广告词、促销标语出现的最多" class="headerlink" title="那种广告词、促销标语出现的最多"></a>那种广告词、促销标语出现的最多</h3><p><img src="https://cdn.jsdelivr.net/gh/zhang18340082962/image-rick@master/image-rick/%E5%9B%BE%E7%89%87.79nh5qchwhds.png"></p>
<p>该品牌主打广告关键词： ‘’限时直降‘’，‘甄选好货’，‘厂家直供’。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhang18340082962/image-rick@master/image-rick/%E5%9B%BE%E7%89%87.6vpepnq4p2m8.png"></p>
<p>主打的促销标语为 ‘’送任意一件赠品，赠完即止‘’。</p>
<h3 id="选择牛栏山作为泸州老窖竞争对手"><a href="#选择牛栏山作为泸州老窖竞争对手" class="headerlink" title="选择牛栏山作为泸州老窖竞争对手"></a>选择牛栏山作为泸州老窖竞争对手</h3><p><img src="https://cdn.jsdelivr.net/gh/zhang18340082962/image-rick@master/image-rick/%E5%9B%BE%E7%89%87.7k75jdss8f0g.png"></p>
<p>牛栏山品牌在产品布局上和泸州老窖都是主打50-500价位段商品布局，但是牛栏山在0-50上的产品数多于500-1000价位的产品数量。且没有3000元以上产品上市，可见牛栏山品牌试图留住中端价位产品客户，拉拢低价位产品客户的战略方针。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhang18340082962/image-rick@master/image-rick/%E5%9B%BE%E7%89%87.585gbomsxjsw.png"></p>
<p>与泸州老窖相似均在十二月出现了较大幅度的增长。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhang18340082962/image-rick@master/image-rick/%E5%9B%BE%E7%89%87.5tcjs54m9rwg.png"></p>
<p>泸州老窖只在200-300和超1000元以上的产品销量小范围领先友商，但由于单价基数较大，可能会有意想不到的效果哦</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhang18340082962/image-rick@master/image-rick/%E5%9B%BE%E7%89%87.696y93qi0eps.png"></p>
<p>泸州老窖销售额仅在200-500和1000元以上三个价位段领先友商，在50-200价位，销售额较大程度低于友商。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhang18340082962/image-rick@master/image-rick/%E5%9B%BE%E7%89%87.65kolxn2i16o.png"></p>
<p>除了200-500和1000以上价位的产品，泸州老窖品牌产品收到的市场评论与反馈均低于友商，可见友商的宣传力度或产品口碑在市场中占有较高热度 。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhang18340082962/image-rick@master/image-rick/%E5%9B%BE%E7%89%87.1ebr4yfjo2n4.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhang18340082962/image-rick@master/image-rick/%E5%9B%BE%E7%89%87.6uo6tbp5jfk0.png"></p>
<p>可以看到两个品牌的销售额主要来源产品类别有明显差异。</p>
<h3 id="泸州老窖在行业的水平如何"><a href="#泸州老窖在行业的水平如何" class="headerlink" title="泸州老窖在行业的水平如何"></a>泸州老窖在行业的水平如何</h3><p><img src="https://cdn.jsdelivr.net/gh/zhang18340082962/image-rick@master/image-rick/%E5%9B%BE%E7%89%87.23phzpw6q96o.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhang18340082962/image-rick@master/image-rick/%E5%9B%BE%E7%89%87.535us8b7xog0.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhang18340082962/image-rick@master/image-rick/%E5%9B%BE%E7%89%87.6n2czq2ijcow.png"><br>泸州老窖位于行业的上游水平，产品规模完善，各价位商品数量布局体现了明确的行业目标：要做中高端酒类产品的佼佼者。且不放弃低价位的0-50系列产品，全面覆盖市场，在给定的时间数据中，各区间段产品除0-50与3000+以外，其他商品的销量与销售额均呈持续缓慢上升趋势。可以看到该企业处于一个蓬勃向上，逐步冲向高端的行业发展状态。</p>
<h1 id="六、分析结论"><a href="#六、分析结论" class="headerlink" title="六、分析结论"></a>六、分析结论</h1><p>1、近期行业呈现蓬勃向上的发展状态，0-50价位产品的销量与评论数出现较大市场反差，100-200价位段的商品销量最火，位于市场销量及销售额榜首的是茅台品牌，五粮液以市场获评数最高位居榜首。行业广告词以‘天猫配送’，‘正品保证’等作为主要标语，以‘满1或2件送任意一件赠品，赠完为止’作为主要促销活动。<br>2、行业总体发展十分成熟，各品牌产品竞争力都十分明显，销量与评论基本呈正相关线性关系，与单价成反比例关系，100-500区间产品销量作为市场主流，1000元以上产品可能在销售额上反超其他高销量产品，双十一对市场的刺激反响极为强烈。<br>3、泸州老窖主打中高端酒类产品，全价位品类布局全面，综合实力处于全行业上游水平。销量受双十一影响显著，导致200-500与1000-3000区间商品销售额大幅增长。该品牌主打广告关键词： ‘’限时直降‘’，‘甄选好货’，‘厂家直供’。主要促销活动为 ‘’送任意一件赠品，赠完即止‘’。其总体销售额主要来源于100-3000价位产品，相比牛栏山不相上下，在中高价位品类优势明显，0-100价位段还有较大进步空间。</p>
<h1 id="七、python代码"><a href="#七、python代码" class="headerlink" title="七、python代码"></a>七、python代码</h1><h3 id="导入包，设定字体和画图风格"><a href="#导入包，设定字体和画图风格" class="headerlink" title="导入包，设定字体和画图风格"></a>导入包，设定字体和画图风格</h3><pre class="line-numbers language-none"><code class="language-none">import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
%matplotlib inline
import seaborn as sns
from wordcloud import WordCloud
plt.rcParams[&#39;font.sans-serif&#39;] &#x3D; [&#39;SimHei&#39;]#显示中文
plt.style.use(&#39;ggplot&#39;)</code></pre>
<h3 id="导入并清洗数据"><a href="#导入并清洗数据" class="headerlink" title="导入并清洗数据"></a>导入并清洗数据</h3><pre class="line-numbers language-none"><code class="language-none">#导入数据
path &#x3D; &#39;D:&#x2F;python_data_file&#x2F;Alcohol.xlsx&#39;
def load_alcohol_data(path):
    df &#x3D; pd.read_excel(path)
    df.columns &#x3D; [&#39;id&#39;,&#39;name&#39;,&#39;price&#39;,&#39;sales&#39;,&#39;ad_word&#39;,&#39;buy_act&#39;,&#39;vote_count&#39;,&#39;url&#39;,&#39;date&#39;,&#39;brand&#39;]
    df &#x3D; df[df.price.notnull()]
    df[&#39;amount&#39;] &#x3D; df[&#39;sales&#39;]*df[&#39;price&#39;]
    df[&#39;month&#39;] &#x3D; df.date.values.astype(&#39;datetime64[M]&#39;)#日期时间序列转化为月份时间序列
    return df
df &#x3D; load_alcohol_data(path)
#对酒类单价分层
def price_level(data):
    a&#x3D;[]
    for i in data.price:
        if i &lt;50:
            a.append(&#39;0-50&#39;)
        elif i &lt;100:
            a.append(&#39;50-100&#39;)
        elif i &lt;200:
            a.append(&#39;100-200&#39;)
        elif i&lt;500:
            a.append(&#39;200-500&#39;)
        elif i &lt;1000:
            a.append(&#39;500-1000&#39;)
        elif i&lt;3000:
            a.append(&#39;1000-3000&#39;)
        else:
            a.append(&#39;3000+&#39;)
    data[&#39;price_level&#39;] &#x3D; a
    data &#x3D; data.reset_index(drop&#x3D;True)
    return data
df &#x3D; price_level(df)
recent_df &#x3D; df[df.date&#x3D;&#x3D;&#39;2018-02-27&#39;]
recent_df[[&#39;sales&#39;,&#39;vote_count&#39;,&#39;amount&#39;]].sum()
recent_df.describe()
lzlj_df &#x3D; df[df.brand&#x3D;&#x3D;&#39;泸州老窖&#39;].reset_index(drop&#x3D;True)
lzlj_df &#x3D; price_level(lzlj_df)
lzlj_df.describe()</code></pre>
<h3 id="近期各厂家的表现"><a href="#近期各厂家的表现" class="headerlink" title="近期各厂家的表现"></a>近期各厂家的表现</h3><pre class="line-numbers language-none"><code class="language-none">#各厂家的表现就在这了
all_brand &#x3D; recent_df.groupby(&#39;brand&#39;)[[&#39;sales&#39;,&#39;vote_count&#39;,&#39;amount&#39;]].sum().sort_values(by&#x3D;
&#39;amount&#39;,ascending &#x3D; True).reset_index()
all_brand.sales.plot.bar()
plt.title(&#39;各厂家销量对比&#39;)
all_brand.vote_count.plot.bar()
plt.title(&#39;各厂家评论数&#39;)
all_brand.amount.plot.bar()
plt.title(&#39;各厂家销售额&#39;)
</code></pre>
<h3 id="画柱状图"><a href="#画柱状图" class="headerlink" title="画柱状图"></a>画柱状图</h3><pre class="line-numbers language-none"><code class="language-none">#x写个画图函数，不然太麻烦了
def pic_barh(data,tit,xbel,ybel):
    data.sort_values().plot.barh(figsize&#x3D;(12,6))
    plt.title(tit,fontsize &#x3D; 20)
    plt.xlabel(xbel,fontsize &#x3D; 20)
    plt.ylabel(ybel,fontsize &#x3D; 20)
    plt.show()
pic_barh(level_performance_mean.price,&#39;近期平均价格表现&#39;,&#39;价格&#39;,&#39;区间&#39;)
pic_barh(level_performance_sum.amount,&#39;近期销售额表现&#39;,&#39;金额&#39;,&#39;区间&#39;)
pic_barh(level_performance_mean.vote_count,&#39;近期评论表现&#39;,&#39;评论数&#39;,&#39;区间&#39;)
pic_barh(level_performance_mean.amount,&#39;近期平均金额表现&#39;,&#39;金额&#39;,&#39;区间&#39;)</code></pre>
<h3 id="近期各价位段表现"><a href="#近期各价位段表现" class="headerlink" title="近期各价位段表现"></a>近期各价位段表现</h3><pre class="line-numbers language-none"><code class="language-none">level_performance_sum &#x3D; recent_df.groupby(&#39;price_level&#39;)[
&#39;sales&#39;,&#39;vote_count&#39;,&#39;amount&#39;].sum().sort_values(by&#x3D;&#39;sales&#39;,ascending&#x3D;False)
level_performance_mean &#x3D; recent_df.groupby(&#39;price_level&#39;)[
&#39;price&#39;,&#39;sales&#39;,&#39;vote_count&#39;,&#39;amount&#39;].mean().sort_values(by&#x3D;&#39;sales&#39;,ascending&#x3D;False)
#绘制利润与评论数柱状图
level_performance_sum.loc[:,[&#39;sales&#39;,&#39;vote_count&#39;]].plot.bar(figsize&#x3D;(12,6))</code></pre>
<h3 id="寻找竞争品牌"><a href="#寻找竞争品牌" class="headerlink" title="寻找竞争品牌"></a>寻找竞争品牌</h3><pre class="line-numbers language-none"><code class="language-none">#想写个函数找出泸州老窖的上下各相邻两个的品牌，也就是它的竞争品牌
def lookup_name(data):
    for i in range(len(data)):
        if data.loc[i,&#39;brand&#39;] &#x3D;&#x3D;&#39;泸州老窖&#39;:
            return [data.loc[i-1,&#39;brand&#39;],data.loc[i-2,&#39;brand&#39;],data.loc[i+1,&#39;brand&#39;],data.loc[i+2,&#39;brand&#39;]]
        else:
            continue
#按品牌分组求均值，再分别按价格、销量和金额排序，然后找出竞争品牌
df_brand_price_mean &#x3D; df.groupby(&#39;brand&#39;,as_index&#x3D;False)[[
    &#39;price&#39;,&#39;sales&#39;,&#39;amount&#39;]].mean().sort_values(by&#x3D;&#39;price&#39;,ascending&#x3D;True).reset_index(drop&#x3D;True)
lookup_name(df_brand_price_mean)#[&#39;汾酒&#39;, &#39;珍酒&#39;, &#39;剑南春&#39;, &#39;白云边&#39;]
df_brand_sales_mean&#x3D;df.groupby(&#39;brand&#39;,as_index&#x3D;False)[[
    &#39;price&#39;,&#39;sales&#39;,&#39;amount&#39;]].mean().sort_values(by&#x3D;&#39;sales&#39;,ascending&#x3D;True).reset_index(drop&#x3D;True)
df_brand_amount_mean&#x3D; df.groupby(&#39;brand&#39;,as_index&#x3D;False)[[
    &#39;price&#39;,&#39;sales&#39;,&#39;amount&#39;]].mean().sort_values(by&#x3D;&#39;amount&#39;,ascending&#x3D;True).reset_index(drop&#x3D;True)
#按品牌分组求和，再分别按价格、销量和金额排序，然后找出竞争品牌
df_brand_amount_sum&#x3D;df.groupby(&#39;brand&#39;,as_index&#x3D;False)[[
    &#39;sales&#39;,&#39;amount&#39;]].sum().sort_values(by&#x3D;&#39;amount&#39;,ascending &#x3D; True).reset_index(drop&#x3D;True)
df_brand_sales_sum&#x3D;df.groupby(&#39;brand&#39;,as_index&#x3D;False)[[
    &#39;sales&#39;,&#39;amount&#39;]].sum().sort_values(by&#x3D;&#39;sales&#39;,ascending &#x3D; True).reset_index(drop&#x3D;True)
a_sums &#x3D; set(lookup_name(df_brand_amount_sum)+lookup_name(df_brand_sales_sum))
a_means &#x3D; set(lookup_name(df_brand_price_mean)+lookup_name(df_brand_sales_mean)+lookup_name(df_brand_amount_mean))
s &#x3D; set(list(a_means)+list(a_sums))
#&#123;&#39;习酒&#39;,&#39;五粮液&#39;,&#39;剑南春&#39;,&#39;劲酒&#39;,&#39;古井贡酒&#39;, &#39;水井坊&#39;, &#39;江小白&#39;, &#39;汾酒&#39;, &#39;洋河&#39;, &#39;牛栏山&#39;,&#39;珍酒&#39;,
# &#39;白云边&#39;,&#39;红星&#39;,&#39;茅台&#39;&#125; 选取剑南春 古井贡酒 牛栏山 五粮液作为泸州老窖的竞争对手</code></pre>
<h3 id="生成词云图"><a href="#生成词云图" class="headerlink" title="生成词云图"></a>生成词云图</h3><pre class="line-numbers language-none"><code class="language-none">#提取广告词字符串
def ad_words_str(data):
    ad_words_list &#x3D; []
    for x in data.ad_word.dropna():
        ad_words_list.append(x)
    ad_words_list &#x3D; &#39;&#39;.join(ad_words_list)
    return ad_words_list
#提取促销活动字符串
def buy_act_str(data):
    buy_act_list&#x3D;[]
    for x in data.buy_act.dropna():
        buy_act_list.append(x)
    buy_act_list &#x3D; &#39;&#39;.join(buy_act_list)
    return buy_act_list
#生成词云
def pic_words(keywords_list):
    keywords_list.replace(&#39;\s&#39;,&#39;&#39;)#去除字符串中空字符串（\s用于匹配空白字符，可能是空格、制表符、其他空白））
    font &#x3D; &#39;C:\Windows\Fonts\msyh.ttc&#39;
    wordcloud &#x3D; WordCloud(background_color&#x3D;&#39;white&#39;,max_words&#x3D;3000,scale&#x3D;1.5,font_path&#x3D;font).generate(keywords_list)
    plt.figure(figsize&#x3D;(14,8))
    plt.imshow(wordcloud)
    plt.axis(&#39;off&#39;)
    plt.show()
listb &#x3D; ad_words_str(lzlj_df)+buy_act_str(lzlj_df)
#行业大盘最近一个周期的词云
pic_words(ad_words_str(recent_df))
pic_words(buy_act_str(recent_df))
pic_words(ad_words_str(lzlj_df))
pic_words(buy_act_str(lzlj_df))</code></pre>
<h1 id="画走势图"><a href="#画走势图" class="headerlink" title="画走势图"></a>画走势图</h1><pre class="line-numbers language-none"><code class="language-none">df.plot.scatter(x&#x3D;&#39;price&#39;,y&#x3D;&#39;sales&#39;)
plt.title(&#39;销量与单价&#39;)
df.plot.scatter(x&#x3D;&#39;vote_count&#39;,y&#x3D;&#39;sales&#39;)
plt.title(&#39;销量与评论数&#39;)
#写个画图函数，它不香吗
def pic_trend(data,val,agg,tit,ylab):
    a_sum &#x3D; data.pivot_table(
        index&#x3D;&#39;price_level&#39;,columns&#x3D;&#39;month&#39;,values&#x3D;val,aggfunc&#x3D;agg).fillna(0).T
    plt.figure(figsize&#x3D;(12,6))
    a_sum.plot()
    plt.title(tit,fontsize&#x3D;20)
    plt.ylabel(ylab,fontsize&#x3D;15)
    plt.show()
pic_trend(lzlj_df,&#39;sales&#39;,&#39;sum&#39;,&#39;泸州老窖各区间产品销量走势&#39;,&#39;sales&#39;)
pic_trend(lzlj_df,&#39;amount&#39;,&#39;sum&#39;,&#39;泸州老窖销售额走势&#39;,&#39;amount&#39;)
pic_trend(lzlj_df,&#39;price&#39;,&#39;mean&#39;,&#39;泸州老窖产品单价走势&#39;,&#39;price&#39;)
pic_trend(lzlj_df,&#39;vote_count&#39;,&#39;sum&#39;,&#39;泸州老窖产品评论走势&#39;,&#39;vote_count&#39;)
pic_trend(df,&#39;sales&#39;,&#39;sum&#39;,&#39;总体各区间产品销量走势&#39;,&#39;sales&#39;)
pic_trend(df,&#39;amount&#39;,&#39;sum&#39;,&#39;总体产品销售额走势&#39;,&#39;amount&#39;)
pic_trend(df,&#39;price&#39;,&#39;mean&#39;,&#39;总体产品单价走势&#39;,&#39;price&#39;)
pic_trend(df,&#39;vote_count&#39;,&#39;sum&#39;,&#39;总体产品评论走势&#39;,&#39;vote_count&#39;)</code></pre>
<h1 id="得到各品牌数据"><a href="#得到各品牌数据" class="headerlink" title="得到各品牌数据"></a>得到各品牌数据</h1><pre class="line-numbers language-none"><code class="language-none">#写个函数用来对各品牌数据拆分
def df_brand(data,brand):
    data &#x3D; data[data.brand&#x3D;&#x3D;brand].reset_index(drop&#x3D;True)
    data &#x3D; price_level(data)
    data[&#39;amount&#39;] &#x3D; data[&#39;sales&#39;]*data[&#39;price&#39;]
    return data
# list_brand &#x3D; [&#39;剑南春&#39;,&#39;古井贡酒&#39;,&#39;牛栏山&#39;,&#39;五粮液&#39;,&#39;泸州老窖&#39;]
# for i in list_brand:
#     df_brand(df,i)
#对该品牌的各价位段进行分组求和
def df_brand_groupby_sum(data):
    data &#x3D; data.groupby(&#39;price_level&#39;).sum().loc[:,[&#39;sales&#39;,&#39;vote_count&#39;,&#39;amount&#39;]]
    return data

# 剑南春 古井贡酒 牛栏山 五粮液 #各个价格段的销量、评论量、销售额汇总
lzlj_sum &#x3D; df_brand_groupby_sum(df_brand(df,&#39;泸州老窖&#39;))
jlc_sum &#x3D; df_brand_groupby_sum(df_brand(df,&#39;剑南春&#39;))
gjgj_sum &#x3D; df_brand_groupby_sum(df_brand(df,&#39;古井贡酒&#39;))
nls_sum &#x3D; df_brand_groupby_sum(df_brand(df,&#39;牛栏山&#39;))
wly_sum &#x3D; df_brand_groupby_sum(df_brand(df,&#39;五粮液&#39;))</code></pre>
<h3 id="画饼图"><a href="#画饼图" class="headerlink" title="画饼图"></a>画饼图</h3><pre class="line-numbers language-none"><code class="language-none">def pic_pie(data,gby,tit):
    price_count &#x3D; data.groupby(gby).count().reset_index(drop&#x3D;False)
    fig &#x3D; plt.figure(figsize&#x3D;(16,8))
    plt.pie(price_count.price,labels&#x3D;price_count[gby],autopct&#x3D;&#39;%.1f%%&#39;)
    plt.title(tit,fontsize &#x3D; 15)
pic_pie(nls_df,&#39;price_level&#39;,&#39;牛栏山产品价位规模&#39;)
pic_pie(nls_df,&#39;month&#39;,&#39;牛栏山产品月份规模&#39;)
pic_pie(lzlj_df,&#39;price_level&#39;,&#39;泸州老窖产品价位规模&#39;)
pic_pie(lzlj_df,&#39;month&#39;,&#39;泸州老窖产品月份规模&#39;)

fig &#x3D; plt.figure(figsize&#x3D;(16,8))
plt.pie(lzlj_sum.sales,labels&#x3D;lzlj_sum.index,autopct&#x3D;&#39;%.1f%%&#39;)
plt.title(&#39;泸州老窖各价位销量图&#39;,fontsize &#x3D; 15)
fig &#x3D; plt.figure(figsize&#x3D;(16,8))
plt.pie(nls_sum.vote_count,labels&#x3D;nls_sum.index,autopct&#x3D;&#39;%.1f%%&#39;)
plt.title(&#39;牛栏山各价位评论数图&#39;,fontsize &#x3D; 15)

#按月份销量变化
lzlj_df.groupby(&#39;month&#39;).sales.sum().plot()
plt.title(&#39;销量按月份变化&#39;)
#总销售额随时间变化
lzlj_df.groupby(&#39;month&#39;).amount.sum().plot()
plt.title(&#39;总销售额随时间变化&#39;)

def pic_bar2(arg):
    sales_dif &#x3D; nls_sum.sales.reset_index().merge(lzlj_sum[arg].reset_index(),on&#x3D;&#39;price_level&#39;,how&#x3D;&#39;outer&#39;,suffixes&#x3D;[&#39;_nls&#39;,&#39;_lzlj&#39;])
    sales_dif &#x3D; sales_dif.set_index(&#39;price_level&#39;)
    plt.figure(figsize&#x3D;(12,10))
    sales_dif.plot.bar()
    plt.title(&#39;泸州老窖与牛栏山&#39;+str(arg)+&#39;对比&#39;)
pic_bar2(&#39;sales&#39;)
pic_bar2(&#39;amount&#39;)
pic_bar2(&#39;vote_count&#39;)

pic_barh(df_brand_sum.sales,&#39;各品牌销售总量对比&#39;,&#39;销量&#39;,&#39;品牌&#39;)
pic_barh(df_brand_sum.amount,&#39;各品牌销售总金额对比&#39;,&#39;金额&#39;,&#39;品牌&#39;)
pic_barh(df_brand_sum.vote_count,&#39;各品牌产品评论数对比&#39;,&#39;评论数&#39;,&#39;品牌&#39;)</code></pre>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title>python面向对象习题</title>
    <url>//post/python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%A0%E9%A2%98.html</url>
    <content><![CDATA[<p>写完对对象这个东西了解很多了</p>
<pre class="line-numbers language-none"><code class="language-none"># coding&#x3D;utf-8
&quot;&quot;&quot;
一：定义一个学生类。有下面的类属性：
1 姓名
2 年龄
3 成绩（语文，数学，英语)[每课成绩的类型为整数]
类方法：
1 获取学生的姓名：get_name() 返回类型:str
2 获取学生的年龄：get_age() 返回类型:int
3 返回3门科目中最高的分数。get_course() 返回类型:int
写好类以后，可以定义2个同学测试下:
zm &#x3D; Student(&#39;zhangming&#39;,20,[69,88,100])
返回结果：
zhangming
20
100
&quot;&quot;&quot;
class Student(object):
    def __init__(self, name, age, scores):
        self.name &#x3D; name
        self.age &#x3D; age
        self.scores &#x3D; scores
    def get_name(self):
        return self.name
    def get_age(self):
        return self.age
    def get_course(self):
        return max(self.scores)
zm &#x3D; Student(&#39;zhangming&#39;, 20, [69, 88, 100])
print zm.get_name()
print zm.get_age()
print zm.get_course()</code></pre>

<pre class="line-numbers language-none"><code class="language-none">&quot;&quot;&quot;
二：定义一个字典类：dictclass。完成下面的功能：
dict &#x3D; dictclass(&#123;你需要操作的字典对象&#125;)
1 删除某个key
del_dict(key)
2 判断某个键是否在字典里，如果在返回键对应的值，不存在则返回&quot;not found&quot;
get_dict(key)
3 返回键组成的列表：返回类型;(list)
get_key()
4 合并字典，并且返回合并后字典的values组成的列表。返回类型:(list)
update_dict(&#123;要合并的字典&#125;)
&quot;&quot;&quot;
class dictclass(object):
    def __init__(self, dict):
        self.dict &#x3D; dict
    def get_dict(self, key):
        if self.dict. has_key(key):
            return self.dict[key]
        return &#39;not found&#39;
    def del_dict(self, key):
        if self.dict.has_key(key):
            self.dict.pop(key)
        else:
            return &#39;no that key&#39;
    def get_key(self):
        return self.dict.keys()
    def updata_dict(self, dict2):
        self.dict &#x3D; dict(self.dict, **dict2)
        return self.dict.values()
 
A &#x3D; dictclass(&#123;&#39;a&#39;: 1, &#39;b&#39;: 2&#125;)
print A.get_dict(&#39;c&#39;)
print A.del_dict(&#39;c&#39;)
print A.get_key()
print A.updata_dict(&#123;&#39;c&#39;: 3, &#39;d&#39;: 4&#125;)
 
# 关于删除字典中的元素
# pop 删除并返回对应的value值
B &#x3D; &#123;&#39;a&#39;: 1, &#39;b&#39;: 2&#125;
print B.pop(&#39;b&#39;)
print B
# del void不返回值
C &#x3D; &#123;&#39;a&#39;: 1, &#39;b&#39;: 2&#125;
del C[&#39;a&#39;]
print C
# del dict 删除字典，不存在这个字典
# dict.clear()删除字典内所有元素但字典还是存在只是没有元素
D &#x3D; &#123;&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3&#125;
D.clear()
# 关于合并字典
A &#x3D; &#123;&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3&#125;
B &#x3D; &#123;&#39;d&#39;: 4, &#39;e&#39;: 5, &#39;f&#39;: 6&#125;
C &#x3D; dict(A.items() + B.items())
D &#x3D; dict(A, **B)  # 这种合并方法会比上一种快很多对于重复的key，B会覆盖A</code></pre>
<pre class="line-numbers language-none"><code class="language-none">&quot;&quot;&quot;
定义一个列表的操作类：Listinfo
包括的方法:
1 列表元素添加: add_key(keyname)  [keyname:字符串或者整数类型]
2 列表元素取值：get_key(num) [num:整数类型]
3 列表合并：update_list(list)	  [list:列表类型]
4 删除并且返回最后一个元素：del_key()
list_info &#x3D; Listinfo([44,222,111,333,454,&#39;sss&#39;,&#39;333&#39;])
&quot;&quot;&quot;
class Listinfo(object):
    def __init__(self, list_val):
        self.varlist &#x3D; list_val
 
    def add_key(self, key_name):
        if isinstance(key_name, (str, int)):
            self.varlist.append(key_name)
            return self.varlist
        else:
            return &#39;error&#39;
 
    def get_key(self, num):
        if num &gt;&#x3D; 0 and num &lt; len(self.varlist):
            return self.varlist[num]
        else:
            return &#39;error&#39;
 
    def update_list(self, List_et):
        self.varlist.extend(List_et)
        return self.varlist
 
    def del_key(self):
        if len(self.varlist) &gt;&#x3D; 0:
            return self.varlist.pop(-1)
        else:
            return &#39;error&#39;
list_info &#x3D; Listinfo([44, 222, 111, 333, 454, &#39;sss&#39;, &#39;333&#39;])
print list_info.add_key(&#39;1111&#39;)
print list_info.get_key(4)
print list_info.update_list([&#39;1&#39;, &#39;2&#39;, &#39;3&#39;])
print list_info.del_key()</code></pre>
<pre class="line-numbers language-none"><code class="language-none">&quot;&quot;&quot;
定义一个集合的操作类：Setinfo
包括的方法:
1 集合元素添加: add_setinfo(keyname)  [keyname:字符串或者整数类型]
2 集合的交集：get_intersection(unioninfo) [unioninfo :集合类型]
3 集合的并集： get_union(unioninfo)[unioninfo :集合类型]
4 集合的差集：del_difference(unioninfo) [unioninfo :集合类型]
set_info &#x3D;  Setinfo(你要操作的集合)
&quot;&quot;&quot;
class Setinfo(object):
    def __init__(self, my_Set):
        self.Sett &#x3D; my_Set
 
    def add_setinfo(self, keyname):
        if isinstance(keyname, (int, str)):
            self.Sett.add(keyname)
            return self.Sett
        return &#39;error&#39;
 
    def get_intersection(self, unioninfo):
        if isinstance(unioninfo, set):
            return self.Sett &amp; unioninfo
        return &#39;error&#39;
 
    def get_union(self, unioninfo):
        if isinstance(unioninfo, set):
            return self.Sett | unioninfo
        return &#39;error&#39;
 
    def del_difference(self, unioninfo):
        if isinstance(unioninfo, set):
            return self.Sett - unioninfo
        return &#39;error&#39;
 
A &#x3D; set([1, 2, 3, 4, 5, 2])
B &#x3D; set([5, 6, 3])
set_info &#x3D; Setinfo(A)
print set_info.add_setinfo(&#39;f&#39;)
print set_info.get_intersection(B)
print set_info.get_union(B)
print set_info.del_difference(B)</code></pre>
<pre class="line-numbers language-none"><code class="language-none">&quot;&quot;&quot;
题目一： 写一个网页数据操作类。完成下面的功能：
提示：需要用到urllib模块
get_httpcode()获取网页的状态码，返回结果例如：200,301,404等 类型为int
get_htmlcontent() 获取网页的内容。返回类型:str
get_linknum()计算网页的链接数目。
&quot;&quot;&quot;
import urllib
import urllib2
class page_data(object):
    def __init__(self, url_add):
        self.url &#x3D; url_add
 
    def get_httpcode(self):
        status &#x3D; urllib.urlopen(self.url).code
        return status
 
    def get_htmlcontent(self):
        contentstr &#x3D; urllib2.urlopen(self.url).read()
        return contentstr
 
    def get_linknum(self):
        content &#x3D; urllib2.urlopen(self.url).read()
        return len(content.split(&#39;&lt;a href&#x3D;&#39;)) - 1
 
A &#x3D; page_data(&quot;http:&#x2F;&#x2F;www.baidu.com&quot;)
print A.get_httpcode()
print A.get_htmlcontent()
print A.get_linknum()</code></pre>

<pre class="line-numbers language-none"><code class="language-none"># coding&#x3D;utf-8
class SchoolMember:
    # Represents any school member.
    def __init__(self, name, age):
        self.name &#x3D; name
        self.age &#x3D; age
        print &#39;(Initialized SchoolMember: %s)&#39; % self.name
 
    def tell(self):
        # Tell my details.
        print &#39;Name:&quot;%s&quot; Age:&quot;%s&quot;&#39; % (self.name, self.age),
 
 
class Teacher(SchoolMember):
    # Represents a teacher.
    def __init__(self, name, age, salary):
        SchoolMember.__init__(self, name, age)
        self.salary &#x3D; salary
        print &#39;(Initialized Teacher: %s)&#39; % self.name
 
    def tell(self):
        SchoolMember.tell(self)
        print &#39;Salary: &quot;%d&quot;&#39; % self.salary
 
 
class Student(SchoolMember):
    # Represents a student.
    def __init__(self, name, age, marks):
        SchoolMember.__init__(self, name, age)
        self.marks &#x3D; marks
        print &#39;(Initialized Student: %s)&#39; % self.name
 
    def tell(self):
        SchoolMember.tell(self)
        print &#39;Marks: &quot;%d&quot;&#39; % self.marks
 
t &#x3D; Teacher(&#39;Mrs. Shrividya&#39;, 40, 30000)
s &#x3D; Student(&#39;Swaroop&#39;, 22, 75)
c &#x3D; SchoolMember(&#39;Swar&#39;, 22)
t.tell()
s.tell()
c.tell()</code></pre>

<p><a href="https://blog.csdn.net/bullpride/article/details/52022701">https://blog.csdn.net/bullpride/article/details/52022701</a></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title>python中requests使用中文乱码的解决方案</title>
    <url>//post/requests%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3.html</url>
    <content><![CDATA[<ul>
<li> 中文乱码处理<pre class="line-numbers language-none"><code class="language-none">import requests

url &#x3D; &quot;http:&#x2F;&#x2F;www.baidu.com&quot;
r &#x3D; requests.get(url)
# 自动选择合适的编码方式
r.encoding &#x3D; r.apparent_encoding
print(r.text)</code></pre>
中文乱码显示正常了！！</li>
</ul>
<p>有时候，我们还会遇到通过这个操作后无法解决的情况，比如新浪首页的表现：<br>出现这种情况，据说是使用gzip将网页压缩了，必须先对其解码，使用r.content会自动解码：</p>
<pre class="line-numbers language-none"><code class="language-none">import requests

url &#x3D; &quot;http:&#x2F;&#x2F;www.sina.com.cn&#x2F;&quot;
r &#x3D; requests.get(url)
# 指定编码解码方式
html &#x3D; r.content.decode(&#39;UTF-8&#39;)
# r.encoding &#x3D; &#39;utf-8&#39;</code></pre>
<p>其实吧，处理的方式有很多，大家注意一点，那就是看请求的html数据中最前面对的charset设置的是啥！！</p>
<ul>
<li><p> html实体编码解析</p>
<pre class="line-numbers language-none"><code class="language-none">In [1]: s &#x3D; &#39;目前玩的挺好的，就&amp;hellip;&amp;hellip;&lt;br&gt;给四星是因为为什么不是同一个服的就不能进社团😬😬😬😬😬😬😬😬😬😬😬😬😬😬😬😬😬😬😬&#39;
#可以看到，有个&#39;&amp;hellip;&#39;，这玩意是html实体表示省略号&#39;...&#39;，因此需要进行处理！
In [2]: import html

In [3]: html.unescape(s)
Out[3]: &#39;目前玩的挺好的，就……&lt;br&gt;给四星是因为为什么不是同一个服的就不能进社团😬😬😬😬😬😬😬😬😬😬😬😬😬😬😬😬😬😬😬&#39;</code></pre></li>
<li><p>也是一种情况吧~</p>
</li>
</ul>
<p><a href="https://www.cnblogs.com/xieqiankun/p/lxmlencoding.html">https://www.cnblogs.com/xieqiankun/p/lxmlencoding.html</a></p>
<pre class="line-numbers language-none"><code class="language-none">显然这应该是编码的问题，在使用:
etree.HTML(r)
处理源文件的时候，由于没有指定编码，所以它使用了一个默认编码，从而导致和UTF-8冲突，产生乱码。

经过查阅lxml.etree.HTML的文档，我发现etree.HTML有一个参数是parser,这个参数不是必须的，因此省略以后它就会自动使用一个默认的parser。既然如此，那我手动指定一个：
contentTree &#x3D; etree.HTML(r, parser&#x3D;etree.HTMLParser(encoding&#x3D;&#39;utf-8&#39;))
这里我指定了etree.HTMLParser来作为一个parser,同时，etree.HTMLParser可以接受编码作为参数。于是我指定为UTF-8。</code></pre>

<pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">import requests
from lxml import etree
import sys
reload(sys)
sys.setdefaultencoding(&quot;utf-8&quot;)

r &#x3D; requests.get(url&#x3D;&#39;http:&#x2F;&#x2F;sports.sina.cn&#x2F;nba&#x2F;rockets&#x2F;2015-10-07&#x2F;detail-ifximrxn8235561.d.html?vt&#x3D;4&amp;pos&#x3D;10&#39;)# 最基本的GET请求
r.encoding &#x3D; &#39;utf-8&#39;
r &#x3D; r.content
print r</code></pre>]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title>sql排名函数</title>
    <url>//post/sql%E6%8E%92%E5%90%8D%E5%87%BD%E6%95%B0.html</url>
    <content><![CDATA[<ul>
<li><p>rank()排名是不连续的，出现同名的排序序号会相同(比较常规的排序)，存在并列，且序号会跳跃</p>
<p>适合求第一名，名次这类</p>
</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">select 
employee_id
,last_name
,department_id
,salary
,rank() over(partition by department_id order by salary desc) 
from employees</code></pre>
<ul>
<li><p>row_number()排名是连续的,出现同名的序号仍然会连续，不存在并列和跳跃</p>
<p>适合计算个数，位置，连续购买场景</p>
</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">select 
employee_id 
,last_name 
,department_id 
,salary 
,row_number() over(partition by department_id order by salary desc) 
from employees </code></pre>
<ul>
<li><p>dense_rank()排名是连续的，出现同名的序号会相同，存在并列，且序号不会跳跃</p>
<p>（用的比较少的，单纯需要排名且存在并列也不跳跃）</p>
</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">select 
employee_id 
,last_name 
,department_id 
,salary 
,dense_rank() over(partition by department_id order by salary desc) 
from employees </code></pre>
<p>– ntile()根据排序指定数量进行分区编号（分区编号排序）</p>
<pre class="line-numbers language-none"><code class="language-none">select 
employee_id 
,last_name 
,department_id 
,salary 
,ntile(3) over(partition by department_id order by salary desc) 
from employees </code></pre>]]></content>
      <categories>
        <category>sql</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title>sql互联网游戏数据分析</title>
    <url>//post/sql%E4%BA%92%E8%81%94%E7%BD%91%E6%B8%B8%E6%88%8F%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90.html</url>
    <content><![CDATA[<h1 id="一、数据概览"><a href="#一、数据概览" class="headerlink" title="一、数据概览"></a>一、数据概览</h1><p>数据共有828934条，108列标签</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhang18340082962/image-rick@master/image-rick/%E5%9B%BE%E7%89%87.14j5jvjer19c.png"></p>
<p>本文主要对以下10个字段进行分析</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhang18340082962/image-rick@master/image-rick/%E5%9B%BE%E7%89%87.15fg7qqjowkg.png"></p>
<p>使用工具：Navicat Premium ，jupyter notebook<br>技能要求：SQL掌握到子查询，Python连接数据库（不连也可以）</p>
<h1 id="二、提出问题："><a href="#二、提出问题：" class="headerlink" title="二、提出问题："></a>二、提出问题：</h1><p>1、新增玩家分析：从玩家数量、玩家占比、每日新增玩家数展开分析<br>2、玩家活跃度分析：从不同用户在线时长、分布特征展开分析<br>3、玩家付费情况分析：从PUR（付费比率）、ARPPU（活跃付费用户平均消费金额）等关键指标展开分析<br>4、玩家游戏习惯分析：从不同玩家类型、游戏模式（PVP与PVE）得出的情况来展开分析</p>
<h1 id="三、新增玩家分析"><a href="#三、新增玩家分析" class="headerlink" title="三、新增玩家分析"></a>三、新增玩家分析</h1><p>新增玩家数量：828934人</p>
<pre class="line-numbers language-none"><code class="language-none">SELECT count(DISTINCT user_id) 新增玩家数量 FROM &#96;tap_fun_test&#96;</code></pre>
<p>新增付费玩家数量：19549</p>
<pre class="line-numbers language-none"><code class="language-none">select count(DISTINCT(user_id))  新增付费玩家数量 from tap_fun_test where pay_price &gt;0;</code></pre>
<p>付费玩家占比:0.0236</p>
<pre class="line-numbers language-none"><code class="language-none">select 新增付费玩家&#x2F;新增玩家数 as 付费玩家占比 from 
(SELECT count(distinct user_id) 新增玩家数 from tap_fun_test) as t1 ,
(SELECT count(DISTINCT user_id)  新增付费玩家 from tap_fun_test where pay_price&gt;0) as t2 ;</code></pre>
<p>每日新增用户数量</p>
<pre class="line-numbers language-none"><code class="language-none">select date(register_time) 日期,count(DISTINCT(user_id)) from tap_fun_test GROUP BY 日期;</code></pre>

<p>每日新增付费用户数</p>
<pre class="line-numbers language-none"><code class="language-none">select date(register_time) 日期,count(DISTINCT(user_id)) from tap_fun_test where pay_price&gt;0 GROUP BY 日期;</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/zhang18340082962/image-rick@master/image-rick/%E5%9B%BE%E7%89%87.1w7wlbjdniow.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhang18340082962/image-rick@master/image-rick/%E5%9B%BE%E7%89%87.4v3ad1gpu2v4.png"></p>
<p>每日新增玩家在3月10日有一次大高峰增长，可能举办活动，但活动一过后续新增玩家数并没有显著提升，可见活动没有游戏的人气带来实质性的帮助。<br>活动需要力度加强并保持一定时间维度，给玩家充分时间了解游戏，才能提高秀逸热度。</p>
<p>全部玩家平均在线时长:11.741103057664969</p>
<pre class="line-numbers language-none"><code class="language-none">SELECT avg(avg_online_minutes)  as 全部玩家平均在线时长 from tap_fun_test;</code></pre>
<p>付费玩家平均在线时长:135.8732415946089</p>
<pre class="line-numbers language-none"><code class="language-none">select avg(avg_online_minutes) from tap_fun_test where pay_price&gt;0;</code></pre>
<h1 id="四、玩家活跃度分析"><a href="#四、玩家活跃度分析" class="headerlink" title="四、玩家活跃度分析"></a>四、玩家活跃度分析</h1><p>平均在线时长的分布特点<br>###全部玩家人数的中位数、上下四分位数</p>
<pre class="line-numbers language-none"><code class="language-none">select round(count(distinct user_id)&#x2F;4) as 下四分位数,
round(count(distinct user_id)&#x2F;2) as 中位数,
round(count(distinct user_id)&#x2F;4*3) as 上四分位数
from tap_fun_test;</code></pre>
<h4 id="下四分位数：207234-中位数：414467-上四分位数：621701"><a href="#下四分位数：207234-中位数：414467-上四分位数：621701" class="headerlink" title="下四分位数：207234    中位数：414467    上四分位数：621701"></a>下四分位数：207234    中位数：414467    上四分位数：621701</h4><h3 id="全部玩家在线时长箱线图关键值"><a href="#全部玩家在线时长箱线图关键值" class="headerlink" title="全部玩家在线时长箱线图关键值"></a>全部玩家在线时长箱线图关键值</h3><pre class="line-numbers language-none"><code class="language-none">SELECT min(avg_online_minutes) 最小值,
(select avg_online_minutes from tap_fun_test ORDER BY avg_online_minutes LIMIT 207233,1) as 下四分位数,
(select avg_online_minutes from tap_fun_test ORDER BY avg_online_minutes LIMIT 414466,1) as 中位数,
(select avg_online_minutes from tap_fun_test ORDER BY avg_online_minutes LIMIT 621700,1) as 上四分位数,
max( avg_online_minutes) 最大值
FROM &#96;tap_fun_test&#96;	</code></pre>
<h4 id="最小值0-0-下四分位数-0-5-中位数-1-666667，上四分位数：5，最大值：1605-833333"><a href="#最小值0-0-下四分位数-0-5-中位数-1-666667，上四分位数：5，最大值：1605-833333" class="headerlink" title="最小值0.0,下四分位数:0.5,中位数:1.666667，上四分位数：5，最大值：1605.833333"></a>最小值0.0,下四分位数:0.5,中位数:1.666667，上四分位数：5，最大值：1605.833333</h4><h3 id="付费玩家的人数最大值最小值、中位数、上下四分位数"><a href="#付费玩家的人数最大值最小值、中位数、上下四分位数" class="headerlink" title="付费玩家的人数最大值最小值、中位数、上下四分位数"></a>付费玩家的人数最大值最小值、中位数、上下四分位数</h3><pre class="line-numbers language-none"><code class="language-none">select round(count(distinct user_id)&#x2F;4) as 下四分位数,
round(count(distinct user_id)&#x2F;2) as 中位数,
round(count(distinct user_id)&#x2F;4*3) as 上四分位数
from tap_fun_test 
WHERE pay_price&gt;0;</code></pre>
<h4 id="下四分位数：4887，-中位数：9775-上四分位数：14662"><a href="#下四分位数：4887，-中位数：9775-上四分位数：14662" class="headerlink" title="下四分位数：4887，    中位数：9775    上四分位数：14662"></a>下四分位数：4887，    中位数：9775    上四分位数：14662</h4><h1 id="付费玩家在线时长箱线图关键值"><a href="#付费玩家在线时长箱线图关键值" class="headerlink" title="付费玩家在线时长箱线图关键值"></a>付费玩家在线时长箱线图关键值</h1><pre class="line-numbers language-none"><code class="language-none">SELECT min(avg_online_minutes) 最小值,
(select avg_online_minutes from tap_fun_test where pay_price&gt;0 ORDER BY avg_online_minutes LIMIT 4886,1) as 下四分位数,
(select avg_online_minutes from tap_fun_test where pay_price&gt;0 ORDER BY avg_online_minutes LIMIT 9774,1) as 中位数,
(select avg_online_minutes from tap_fun_test where pay_price&gt;0 ORDER BY avg_online_minutes LIMIT 14661,1) as 上四分位数,
max( avg_online_minutes) 最大值
FROM &#96;tap_fun_test&#96; 
where pay_price&gt;0;</code></pre>
<h4 id="最小值：0-3333-下四分位数-30-6667-中位数-84-5，上四分位数：191-1667，最大值：1081-5"><a href="#最小值：0-3333-下四分位数-30-6667-中位数-84-5，上四分位数：191-1667，最大值：1081-5" class="headerlink" title="最小值：0.3333 ,下四分位数:30.6667,中位数:84.5，上四分位数：191.1667，最大值：1081.5"></a>最小值：0.3333 ,下四分位数:30.6667,中位数:84.5，上四分位数：191.1667，最大值：1081.5</h4><p><img src="https://cdn.jsdelivr.net/gh/zhang18340082962/image-rick@master/image-rick/%E5%9B%BE%E7%89%87.25066jtzv1vk.png"></p>
<p>全部玩家的在线时长箱线图中向下压缩的很厉害，全部玩家上四分位数为5，说明75%的玩家平均在线只有大约5分钟，可能一局游戏都没有玩完，可见玩家流失情况比较严重。<br>付费用户的箱型图中下四分位数为30，中位数84，上四分位数为191，说明付费用户中75%以上的用户在线时长都超过了30分钟。</p>
<h1 id="五、玩家付费情况分析"><a href="#五、玩家付费情况分析" class="headerlink" title="五、玩家付费情况分析"></a>五、玩家付费情况分析</h1><h3 id="关键指标"><a href="#关键指标" class="headerlink" title="关键指标"></a>关键指标</h3><p>AU（active users）活跃用户：游戏时长超过15分钟<br> PU（Paying users）付费用户<br>APA（Active Paying Account）:活跃付费用户数<br>ARPU：平均每个活跃用户的收入，总收入/AU<br> ARPPU：平均活跃付费用户收入,总收入/APU<br> PUR(付费比率)：APA/AU</p>
<h2 id="每个活跃玩家的收入"><a href="#每个活跃玩家的收入" class="headerlink" title="每个活跃玩家的收入"></a>每个活跃玩家的收入</h2><pre class="line-numbers language-none"><code class="language-none">select count(DISTINCT user_id) as AU,
(select sum(pay_price) from tap_fun_test as 总收入),
(select sum(pay_price) from tap_fun_test) &#x2F;count(DISTINCT user_id) as 每个活跃玩家收入 
from tap_fun_test 
where avg_online_minutes &gt; 15;
#and pay_price&gt;0;每个活跃付费玩家的收入</code></pre>
<h5 id="AU：99846，总收入：556900-04，每个活跃玩家收入ARPU：5-57758989"><a href="#AU：99846，总收入：556900-04，每个活跃玩家收入ARPU：5-57758989" class="headerlink" title="AU：99846，总收入：556900.04，每个活跃玩家收入ARPU：5.57758989"></a>AU：99846，总收入：556900.04，每个活跃玩家收入ARPU：5.57758989</h5><h2 id="每个活跃付费玩家的收入"><a href="#每个活跃付费玩家的收入" class="headerlink" title="每个活跃付费玩家的收入"></a>每个活跃付费玩家的收入</h2><h5 id="APA：16982，总收入：556900-04，每个活跃付费玩家收入ARPPU：32-79354846"><a href="#APA：16982，总收入：556900-04，每个活跃付费玩家收入ARPPU：32-79354846" class="headerlink" title="APA：16982，总收入：556900.04，每个活跃付费玩家收入ARPPU：32.79354846"></a>APA：16982，总收入：556900.04，每个活跃付费玩家收入ARPPU：32.79354846</h5><p><img src="https://cdn.jsdelivr.net/gh/zhang18340082962/image-rick@master/image-rick/%E5%9B%BE%E7%89%87.19kx2qgrrty8.png"></p>
<h1 id="付费比率"><a href="#付费比率" class="headerlink" title="付费比率"></a>付费比率</h1><pre class="line-numbers language-none"><code class="language-none">select count(DISTINCT user_id) as APA ,
(SELECT count(DISTINCT user_id) from tap_fun_test WHERE avg_online_minutes&gt;&#x3D;15) as AU ,
count(DISTINCT user_id)&#x2F;(select count(DISTINCT user_id) from tap_fun_test 
where avg_online_minutes&gt;&#x3D;15) as PUR
from tap_fun_test 
where avg_online_minutes&gt;&#x3D;15 and pay_price &gt;0;</code></pre>
<h5 id="APA：17005；AU：100649；活跃玩家的付费率PUR：0-169，全部玩家的付费比率：0-021"><a href="#APA：17005；AU：100649；活跃玩家的付费率PUR：0-169，全部玩家的付费比率：0-021" class="headerlink" title="APA：17005；AU：100649；活跃玩家的付费率PUR：0.169，全部玩家的付费比率：0.021"></a>APA：17005；AU：100649；活跃玩家的付费率PUR：0.169，全部玩家的付费比率：0.021</h5><p><img src="https://cdn.jsdelivr.net/gh/zhang18340082962/image-rick@master/image-rick/%E5%9B%BE%E7%89%87.7esl7b48tf28.png"></p>
<p>该游戏的PUR（人均付费率）为0.169较低，且ARPU（活跃玩家平均消费额）为5.58，说明收入表现差；相对于ARPPU，活跃付费用户消费很高，是ARPU的6倍左右，针对这点我们可以做首次消费门槛和专属大V玩家的福利与活动进行调整与优化。</p>
<h1 id="六、玩家游戏习惯分析"><a href="#六、玩家游戏习惯分析" class="headerlink" title="六、玩家游戏习惯分析"></a>六、玩家游戏习惯分析</h1><pre class="line-numbers language-none"><code class="language-none">select AVG(pvp_battle_count) as 平均PVP次数 ,
sum(pvp_lanch_count)&#x2F;sum(pvp_battle_count) as 主动发起PVP概率,
sum(pvp_win_count)&#x2F;sum(pvp_battle_count) as PVP获胜概率
from tap_fun_test
where avg_online_minutes&gt;&#x3D;15;
PVP活跃玩家
平均PVP次数：15.164651412333953；主动发起PVP概率：0.5688357584679884；PVP获胜概率：0.532222547626395
PVP活跃付费玩家(加一个pay_price&gt;0)
平均PVP次数：27.301911202587473；主动发起PVP概率：0.6553937480210826；PVP获胜概率：0.6872459716242092</code></pre>

<p>PVE活跃玩家<br>平均PVE次数：28；主动发起PVE概率：0.9967；PVE获胜概率：0.9041<br>PVE活跃付费玩家<br>平均PVE次数：52；主动发起PVE概率：0.9957；PVE获胜概率：0.9110</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhang18340082962/image-rick@master/image-rick/%E5%9B%BE%E7%89%87.qcf66hymhfk.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhang18340082962/image-rick@master/image-rick/%E5%9B%BE%E7%89%87.5z2txq9ht3wg.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhang18340082962/image-rick@master/image-rick/%E5%9B%BE%E7%89%87.6ycbt2l7v340.png"></p>
<p>APA（付费活跃用户）玩家的平均PVE和PVP次数都是AU（活跃）玩家次数的两倍左右，显然APA玩家是重要的发展对象。<br>PVP活动中，APA玩家主动发起和胜利的概率都明显高于AU玩家。<br>PVE活动中，APA玩家主动发起和胜利的概率与AU玩家都基本持平，其中主动发起PVE的概率非常高，且二者的PVE胜率高达90%，游戏体验较好。</p>
]]></content>
      <categories>
        <category>sql</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title>sql数据分析：自动化报表，多场景持续更新</title>
    <url>//post/sql%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%EF%BC%9A%E8%87%AA%E5%8A%A8%E5%8C%96%E6%8A%A5%E8%A1%A8%EF%BC%8C%E5%A4%9A%E5%9C%BA%E6%99%AF%E6%9B%B4%E6%96%B0.html</url>
    <content><![CDATA[<h3 id="建表"><a href="#建表" class="headerlink" title="建表"></a>建表</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">CREATE TABLE &#96;cd_20210414&#96; (
  &#96;id&#96; int(11) NOT NULL AUTO_INCREMENT,
  &#96;platform&#96; varchar(10) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT &#39;&#39; COMMENT &#39;平台&#39;,
  &#96;platform_id&#96; varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT &#39;0&#39; COMMENT &#39;平台id 即storeid&#39;,
  &#96;product_id&#96; varchar(255) CHARACTER SET utf8mb4 DEFAULT &#39;0&#39; COMMENT &#39;商品id&#39;,
  &#96;barcode&#96; varchar(50) CHARACTER SET utf8mb4 DEFAULT &#39;0&#39; COMMENT &#39;商品upc编码&#39;,	
  &#96;sort_id&#96; int(11) DEFAULT &#39;0&#39; COMMENT &#39;商品排序&#39;,
  &#96;title&#96; varchar(255) COLLATE utf8mb4_general_ci DEFAULT &#39;&#39; COMMENT &#39;商品名称&#39;,
  &#96;promotion_price&#96; float(10,2)  DEFAULT null COMMENT &#39;促销价&#39;,
  &#96;full_price&#96;  float(10,2)  DEFAULT null COMMENT &#39;商品原价&#39;,
  &#96;product_month_sale&#96; varchar(10) DEFAULT null COMMENT &#39;月销&#39;,
  &#96;promotion&#96; varchar(255)  CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci COMMENT &#39;促销活动&#39;,
  &#96;image_url&#96; text CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci,
  &#96;catname1&#96; varchar(50) CHARACTER SET utf8mb4 DEFAULT &#39; &#39;,
&#96;brand&#96; varchar(10) COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT &#39;品牌&#39;,
  &#96;time&#96; datetime DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (&#96;id&#96;),
  KEY &#96;a&#96; (&#96;platform&#96;,&#96;platform_id&#96;)
) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8mb4 COLLATE&#x3D;utf8mb4_general_ci;</code></pre>
<h3 id="新增标签列，加索引"><a href="#新增标签列，加索引" class="headerlink" title="新增标签列，加索引"></a>新增标签列，加索引</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">alter table cd_20210414 add COLUMN crawler_id VARCHAR(30);
alter table cd_20210414 add COLUMN detail_full_price float(12,2);
alter table cd_20210414 add index a(sku);
alter table cd_20210414 add index b(platform,platform_id);</code></pre>
<h3 id="查询当月日期及对应上月日期"><a href="#查询当月日期及对应上月日期" class="headerlink" title="查询当月日期及对应上月日期"></a>查询当月日期及对应上月日期</h3><p>mysql</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">#当月日期
select DATE_ADD(DATE_SUB(CURDATE(),INTERVAL 1 DAY),interval -day(DATE_SUB(CURDATE(),INTERVAL 1 DAY))+1 day),
DATE_SUB(CURDATE(),INTERVAL 1 DAY);
#对应上月日期
select DATE_SUB(DATE_ADD(DATE_SUB(CURDATE(),INTERVAL 1 DAY),interval -day(DATE_SUB(CURDATE(),INTERVAL 1 DAY))+1 day),INTERVAL 1 MONTH),
DATE_SUB(DATE_SUB(CURDATE(),INTERVAL 1 DAY),INTERVAL 1 MONTH);</code></pre>

<p>hive</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">#昨天
select date_format(date_sub(current_date(),1), &#39;yyyyMMdd&#39;);
#当月月初
select concat(from_unixtime(unix_timestamp(), &#39;yyyyMM&#39;),&#39;01&#39;);
#上月同期
select date_format(add_months(from_unixtime(unix_timestamp(), &#39;yyyy-MM-dd&#39;),-1),&#39;yyyyMMdd&#39;);
#昨天环比上月同期
select date_format(date_sub(add_months(from_unixtime(unix_timestamp(), &#39;yyyy-MM-dd&#39;),-1),1),&#39;yyyyMMdd&#39;);
#上月月初
select concat(date_format(add_months(from_unixtime(unix_timestamp(), &#39;yyyy-MM-dd&#39;),-1),&#39;yyyyMM&#39;),&#39;01&#39;);</code></pre>

<h3 id="每个部门薪水最高的员工-包含部门名称"><a href="#每个部门薪水最高的员工-包含部门名称" class="headerlink" title="每个部门薪水最高的员工(包含部门名称)"></a>每个部门薪水最高的员工(包含部门名称)</h3><ul>
<li>员工表和部门表进行连接，对部门id进行组内分组根据薪资降序排序，这里使用rank()并列也算</li>
<li>筛选排序序号为1的部门，并查询员工薪资</li>
</ul>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">select * 
from 
    (SELECT 
    employee_id
    ,first_name
    ,e.department_id
    ,department_name
    ,salary 
    ,rank() over(partition by department_id order by salary desc) as salary_rank 
    FROM &#96;employees&#96; e 
    inner join 
    &#96;departments&#96; d 
    on e.department_id &#x3D; d.department_id
    ) a 
where a.salary_rank&#x3D;1;</code></pre>
<h3 id="众数、平均数、中位数"><a href="#众数、平均数、中位数" class="headerlink" title="众数、平均数、中位数"></a>众数、平均数、中位数</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">-- 求员工工资的众数

SELECT salary,count(1) AS cnt
FROM employees
GROUP BY salary
HAVING count(*) &gt;&#x3D; ALL(SELECT COUNT(*) FROM employees GROUP BY salary)

-- 求员工工资的平均数
select AVG(salary) from employees

select sum(salary)&#x2F;count(0) as avg_salary 
from employees 

-- 求员工工资的中位数
-- 中位数定义：将数从小到大排列，若总数为奇数，取中间位置的数值。若总数为偶数，取中间位置两个数的平均值

select avg(emp_salary)
from
(#排位次
select salary,
 row_number() over(order by salary) as rn,
count(*) over() as n
from employees
) t 
where rn in (floor(n&#x2F;2)+1,if(mod(n,2) &#x3D; 0,floor(n&#x2F;2),floor(n&#x2F;2)+1))</code></pre>

<h3 id="上、下四分位数"><a href="#上、下四分位数" class="headerlink" title="上、下四分位数"></a>上、下四分位数</h3><ul>
<li>全部玩家人数的中位数、上下四分位数</li>
<li>再根据人数总量细拆 排序好的玩家在线时长表</li>
</ul>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">select round(count(distinct user_id)&#x2F;4) as 下四分位数,
round(count(distinct user_id)&#x2F;2) as 中位数,
round(count(distinct user_id)&#x2F;4*3) as 上四分位数
from tap_fun_test;
下四分位数：207234 中位数：414467 上四分位数：621701
SELECT min(avg_online_minutes) 最小值,
(select avg_online_minutes from tap_fun_test ORDER BY avg_online_minutes LIMIT 207233,1) as 下四分位数,
(select avg_online_minutes from tap_fun_test ORDER BY avg_online_minutes LIMIT 414466,1) as 中位数,
(select avg_online_minutes from tap_fun_test ORDER BY avg_online_minutes LIMIT 621700,1) as 上四分位数,
max( avg_online_minutes) 最大值
FROM &#96;tap_fun_test&#96;	
最小值0.0,下四分位数:0.5,中位数:1.666667，上四分位数：5，最大值：1605.833333</code></pre>

<h3 id="截至当前，每个用户已经连续签到的天数"><a href="#截至当前，每个用户已经连续签到的天数" class="headerlink" title="截至当前，每个用户已经连续签到的天数"></a>截至当前，每个用户已经连续签到的天数</h3><ul>
<li>查出最后一次不登录的日期（即未登录时间的最大值）</li>
<li>与当前日期进行比较，二者差值为几就是连续登录几天</li>
</ul>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">select 
user_id ,
max(date),
DATEDIFF(&#39;2021-02-19&#39;,max(date)) as max_con_days 
from user_attendence 
where is_sign &#x3D; 0 
group by user_id;</code></pre>
<h3 id="计算有史以来用户最大连续签到天数；"><a href="#计算有史以来用户最大连续签到天数；" class="headerlink" title="计算有史以来用户最大连续签到天数；"></a>计算有史以来用户最大连续签到天数；</h3><ul>
<li>对用户分组，按日期进行row_number()over()排序，排序序号为rank;（一个用户一天只能签到一次）</li>
<li>如果日期与序号的差值为相等，按这个差值进行分组并计数，取最大值</li>
</ul>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">select 
user_id 
,max(次数) &#96;最大连续登录天数&#96;
from 
    (select user_id 
    ,subdate(a.&#96;date&#96;,a.rn) diff 
    ,count(*) 次数
    from 
        (select 
        user_id 
        ,date,
        row_number() over(partition by user_id order by date asc) rn
        from user_attendence  
        where is_sign &#x3D; 1
        ) a 
    group by user_id,diff
    ) b 
group by user_id;</code></pre>
<h3 id="用户最大连续购买天数及次数"><a href="#用户最大连续购买天数及次数" class="headerlink" title="用户最大连续购买天数及次数"></a>用户最大连续购买天数及次数</h3><p>最里面子查询先对日期进行聚合，将购买次数求和，然后类比连续签到</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">select 
user_id 
,max(count_days) &#96;天数&#96;
,sum(sum_user_counts) &#96;次数&#96;
from 
    (select user_id 
    ,subdate(a.&#96;date&#96;,a.rn) diff 
    ,count(*) count_days
	,sum(user_counts) sum_user_counts
    from 
        (select 
        user_id 
        ,&#96;date&#96;
        ,row_number() over(partition by user_id order by &#96;date&#96; asc) rn
		,user_counts
        from (
				select user_id
				,DATE_FORMAT(pur_dt,&quot;%Y-%m-%d&quot;) &#96;date&#96;
				,count(&#96;month&#96;) user_counts 
				from cd_now 
				group by user_id,DATE_FORMAT(pur_dt,&quot;%Y-%m-%d&quot;)
				) m 
        ) a 
    group by user_id,diff
    ) b 
group by user_id;</code></pre>

<h3 id="某一天以及近七天新增用户数"><a href="#某一天以及近七天新增用户数" class="headerlink" title="某一天以及近七天新增用户数"></a>某一天以及近七天新增用户数</h3><ul>
<li>指定当前日期为1998-02-10，使用date_sub确定前七天日期</li>
<li>使用if判定用户是否当日注册，DISTINCT进行去重</li>
</ul>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">set @date_day &#x3D; &quot;1998-02-10&quot;;

select 
count(DISTINCT if(DATE_FORMAT(pur_dt,&quot;%Y-%m-%d&quot;)&#x3D;@date_day,user_id,null)) as new_id
,count(DISTINCT user_id) as user_7
,count(DISTINCT user_id)&#x2F;7 as avg7_id
from 
cd_now 
where 
DATE_FORMAT(pur_dt,&quot;%Y-%m-%d&quot;) between DATE_SUB(@date_day,INTERVAL 7 day) and @date_day</code></pre>
<h3 id="支付金额在前-20-的用户"><a href="#支付金额在前-20-的用户" class="headerlink" title="支付金额在前 20%的用户"></a>支付金额在前 20%的用户</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">-- 问题：求支付金额在前 20%的用户
select 
a.user_name 
,a.sum_amount 
from 
(select 
user_name 
,sum(pay_amount) sum_amount 
,ntile(5) over(order by sum(pay_amount) desc) sum_amount_rank 
-- ,sum(pay_amount) over(order by user_name) cumsum
-- ,round(sum(pay_amount) over(order by user_name)&#x2F;sum(pay_amount) over(),4) cumsum_rate
from user_sales_table 
group by user_name ) a 
where a.sum_amount_rank &#x3D; 1 </code></pre>
<h3 id="每月最受欢迎的前三名"><a href="#每月最受欢迎的前三名" class="headerlink" title="每月最受欢迎的前三名"></a>每月最受欢迎的前三名</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">select 
*
from 
	(select 
	a.品牌
	,a.mon
	,a.num
	,row_number()over(PARTITION by a.mon order by a.num desc) as num_rank	
	from 
		(SELECT 
		*
		,date_format(日期,&quot;%Y-%m-01&quot;) mon
		,count(orser_id) num
		FROM &#96;alcohol&#96;
		group by 
		date_format(日期,&quot;%Y-%m-01&quot;) ,品牌) a
	) b 
where b.num_rank&lt;4 
order by b.mon asc </code></pre>
<h3 id="用户留存"><a href="#用户留存" class="headerlink" title="用户留存"></a>用户留存</h3><ul>
<li>用户第一次购买时间和最后一次购买时间，根据user_id进行连接，计算购买时间间隔</li>
<li>使用case when 进行判定</li>
</ul>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">select 
(case when t3.day_value&#x3D;1 then &quot;次日留存&quot;
when t3.day_value &#x3D; 3 then &quot;三日留存&quot;
when t3.day_value &#x3D; 7 then &quot;七日留存&quot;
else &quot;其他&quot;
end
) as type
,count(t3.user_id) &quot;用户个数&quot;
from 
	(select 
	t1.user_id
	,t1.first_time
	,t2.last_time
	,datediff(t2.last_time,t1.first_time) day_value
	from
		(select 
		user_id
		,date(min(pur_dt)) first_time
		from cd_now 
		group by 
		user_id) t1
		left join 
		(select 
		user_id
		,date(max(pur_dt)) last_time
		from cd_now
		group by 
		user_id
		) t2
	on t1.user_id&#x3D;t2.user_id
	) t3
group by 
(case when t3.day_value&#x3D;1 then &quot;次日留存&quot;
when t3.day_value &#x3D; 3 then &quot;三日留存&quot;
when t3.day_value &#x3D; 7 then &quot;七日留存&quot;
else &quot;其他&quot;
end
) </code></pre>
<h3 id="产品留存"><a href="#产品留存" class="headerlink" title="产品留存"></a>产品留存</h3><p>一共三个字段：下单日期，产品名称，用户id；</p>
<p>前7天的购买用户作为新客，后24天无购买的为流失；后24天有购买为复购：购买相同产品的为留存，购买其他的为替换；</p>
<p>先查total全量数据temp1，然后前7天购买和后24天购买数据，接着依次查询新客、复购、留存。</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">with temp1 as (
	SELECT 
	pt
	,spec_name
	,user_id
	FROM &#96;order_item&#96; 
	where pt between &#39;20211001&#39; and &#39;20211031&#39; 
),
temp07 as (
	select 
	pt
	,spec_name
	,user_id
	from temp1
	where pt between &#39;20211001&#39; and &#39;20211007&#39;
),
temp24 as (
	select 
	pt
	,spec_name
	,user_id
	from temp1
	where pt between &#39;20211008&#39; and &#39;20211031&#39;
),
temp_xinke as (
	select 
	spec_name
	,count(distinct user_id) &#96;user_xinke&#96;
	from temp07
	group by spec_name
),
temp_fugou as (
	select 
	temp07.spec_name 
	,count(distinct temp07.user_id) &#96;user_fugou&#96;
	from temp07 
	inner join temp24
	on temp07.user_id&#x3D;temp24.user_id 
	group by temp07.spec_name
),
temp_liucun as (
	select 
	temp07.spec_name 
	,count(distinct temp07.user_id) &#96;user_liucun&#96;
	from temp07 
	inner join temp24
	on temp07.user_id&#x3D;temp24.user_id and temp07.spec_name&#x3D;temp24.spec_name 
	group by temp07.spec_name
),
temp_total as (
	select 
	temp_xinke.spec_name &#96;产品名称&#96;
	,temp_xinke.&#96;user_xinke&#96; &#96;新客人数&#96;
	,temp_fugou.&#96;user_fugou&#96; &#96;复购人数&#96;
	,temp_liucun.&#96;user_liucun&#96; &#96;留存人数&#96;
	,temp_xinke.&#96;user_xinke&#96;-temp_fugou.&#96;user_fugou&#96; &#96;流失人数&#96;
	,temp_fugou.&#96;user_fugou&#96;-temp_liucun.&#96;user_liucun&#96; &#96;替换人数&#96;
	from temp_xinke 
	inner join temp_fugou on temp_xinke.spec_name&#x3D; temp_fugou.spec_name
	inner join temp_liucun on temp_xinke.spec_name &#x3D; temp_liucun.spec_name
) select * from temp_total;</code></pre>



<h3 id="新老客-amp-复购"><a href="#新老客-amp-复购" class="headerlink" title="新老客&amp;复购"></a>新老客&amp;复购</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">with temp1 as ( # 1、找出每个用户第一次下单的时间和年月
select user_id,min(pur_dt),date_format(min(pur_dt),&#39;%Y-%m&#39;) &#96;年月&#96;
from cd_now 
group by user_id 
),
 temp2 as(# 2、找出每月的新客户数目 
select user_id,&#96;年月&#96;,count(user_id) as &#96;新客户数&#96; 
from 
 temp1 
group by &#96;年月&#96; 
 ),
 temp3 as( # 3.1、找出当月有复购的新客户数目，第一步找出用户在第一次下单的那个月的购买次数
select n.user_id,count(n.order_id) as &#96;次数&#96;,&#96;年月&#96; 
from cd_now n 
 inner join temp1 
on n.user_id &#x3D; temp1.user_id and temp1.&#96;年月&#96; &#x3D; date_format(pur_dt,&quot;%Y-%m&quot;)
group by temp1.user_id
 ),
 temp4 as ( # 3.2、找出当月有复购的新客户数目,第二步是将有复购的新客筛选出来（购买次数&gt;&#x3D;2）
select &#96;年月&#96;,temp3.user_id,count(temp3.user_id) as &#96;有复购的新客户数目&#96;
from temp3 
where &#96;次数&#96;&gt;&#x3D;2
group by temp3.&#96;年月&#96;
 ),
 temp5 as ( # 计算复购率
select temp2.&#96;年月&#96;,temp2.&#96;新客户数&#96;,ifnull(temp4.&#96;有复购的新客户数目&#96;,0) &#96;老客户数&#96;,
 ifnull(temp4.&#96;有复购的新客户数目&#96;&#x2F;temp2.&#96;新客户数&#96;,0) &#96;复购率&#96;
 from temp2
 left join temp4
on temp2.&#96;年月&#96; &#x3D; temp4.&#96;年月&#96;
 ) select * from temp5</code></pre>
<h3 id="rfm模型"><a href="#rfm模型" class="headerlink" title="rfm模型"></a>rfm模型</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">-- 用户id,下单次数,最近下单时间,顾客实付,下单间隔,实付客单,rfm类型,
select 
a.user_id
,a.&#96;下单次数&#96;
,a.&#96;最近下单时间&#96;
,a.&#96;顾客实付&#96;
,a.&#96;下单间隔&#96;
,a.&#96;实付客单&#96;
,case 
when a.&#96;下单间隔&#96; &gt; 45 and a.&#96;下单次数&#96; &lt;&#x3D; 1 and a.&#96;实付客单&#96; &lt;&#x3D;50 then &#39;111&#39; 
when a.&#96;下单间隔&#96; &gt; 45 and a.&#96;下单次数&#96; &lt;&#x3D; 1 and a.&#96;实付客单&#96; &gt;50 then &#39;112&#39; 
when a.&#96;下单间隔&#96; &gt; 45 and a.&#96;下单次数&#96; &gt; 1 and a.&#96;实付客单&#96; &lt;&#x3D;50 then &#39;121&#39; 
when a.&#96;下单间隔&#96; &lt;&#x3D; 45 and a.&#96;下单次数&#96; &lt;&#x3D; 1 and a.&#96;实付客单&#96; &lt;&#x3D;50 then &#39;211&#39; 
when a.&#96;下单间隔&#96; &lt;&#x3D; 45 and a.&#96;下单次数&#96; &gt; 1 and a.&#96;实付客单&#96; &lt;&#x3D;50 then &#39;221&#39; 
when a.&#96;下单间隔&#96; &lt;&#x3D; 45 and a.&#96;下单次数&#96; &lt;&#x3D; 1 and a.&#96;实付客单&#96; &gt; 50 then &#39;212&#39; 
when a.&#96;下单间隔&#96; &lt;&#x3D; 45 and a.&#96;下单次数&#96; &gt; 1 and a.&#96;实付客单&#96; &gt; 50 then &#39;222&#39; 
when a.&#96;下单间隔&#96; &gt; 45 and a.&#96;下单次数&#96; &gt; 1 and a.&#96;实付客单&#96; &gt; 50 then &#39;122&#39; 
end as &#39;rfm_type&#39;
from 
(select 
user_id 
,count(pur_dt) &#96;下单次数&#96;
,date_format(max(pur_dt),&quot;%Y-%m-%d&quot;) &#96;最近下单时间&#96;
,sum(pur_amount) &#96;顾客实付&#96;
,datediff(&quot;1998-03-31&quot;,date_format(max(pur_dt),&quot;%Y-%m-%d&quot;)) &#96;下单间隔&#96;
,avg(pur_amount) as &#96;实付客单&#96;
from supermanzwg.cd_now 
where date_format(month,&quot;%Y-%m-%d&quot;) between &quot;1998-01-01&quot; and &quot;1998-03-01&quot;
group by 
user_id ) a ;</code></pre>

<h3 id="用户行为"><a href="#用户行为" class="headerlink" title="用户行为"></a>用户行为</h3><ul>
<li><p>有订单事务表、收藏事务表,要求：请用一句SQL取出所有用户对商品的行为特征，特征分为已购买、</p>
</li>
<li><p>购买未收藏、收藏未购买、收藏且购买</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"># 数据准备
create table redbk_orders(
 &#96;id&#96; int(5),
 &#96;user_id&#96; varchar(10),
 &#96;item_id&#96; int(5),
 &#96;par_time&#96; varchar(30),
 &#96;item_num&#96; int(5)
);
insert into redbk_orders values(1,&#39;001&#39;,&#39;201&#39;,&#39;2018-08-31 00:00:01&#39;,1);
insert into redbk_orders values(2,&#39;002&#39;,&#39;203&#39;,&#39;2018-09-02 12:00:02&#39;,2);
insert into redbk_orders values(3,&#39;003&#39;,&#39;203&#39;,&#39;2018-09-01 00:00:01&#39;,1);
insert into redbk_orders values(4,&#39;003&#39;,&#39;203&#39;,&#39;2018-09-04 09:10:30&#39;,1);
create table redbk_favorites(
 &#96;id&#96; int(5),
 &#96;user_id&#96; varchar(10),
 &#96;item_id&#96; INT(5),
 &#96;fav_time&#96; varchar(30)
);
insert into redbk_favorites values(1,&#39;001&#39;,201,&#39;2018-08-31 00:00:01&#39;);
insert into redbk_favorites values(2,&#39;002&#39;,202,&#39;2018-09-02 12:00:02&#39;);
insert into redbk_favorites values(3,&#39;003&#39;,204,&#39;2018-09-01 00:00:01&#39;);</code></pre>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">select 
o.user_id 
,o.item_id 
,1 as &quot;已购买&quot; 
,case when f.item_id is null then 1 else 0 end as &quot;购买未收藏&quot;
,0 as &quot;收藏未购买&quot; 
,case when f.item_id is not null then 1 else 0 end as &quot;收藏且购买&quot;
from myemployees.redbk_orders o 
left join myemployees.redbk_favorites f 
on o.user_id &#x3D; f.user_id and o.item_id &#x3D; f.item_id 
where o.user_id is not null 
union 
select 
o.user_id 
,o.item_id 
,case when o.item_id is not null then 1 else 0 end as &quot;已购买&quot; 
,0 as &quot;购买未收藏&quot;
,case when o.item_id is null then 1 else 0 end as &quot;收藏未购买&quot; 
,case when o.item_id is not null then 1 else 0 end as &quot;收藏且购买&quot;
from myemployees.redbk_favorites f 
left join myemployees.redbk_orders o 
on o.user_id &#x3D; f.user_id and o.item_id &#x3D; f.item_id
where o.user_id is not null;</code></pre></li>
<li><p>某购物APP最近上线了一个新功能，用户签到后可以跳转到大转盘抽奖，抽奖获得的奖金可以抵消购物的费用，以此来培养用户使用app的习惯。</p>
</li>
<li><p>现有一张用户行为表user_log，主要字段如下，记录了用户在app上的所有行为日志，即何人user_id在何时event_time进行了什么操作event_id。</p>
</li>
</ul>
<h3 id="贡献度-累计求和"><a href="#贡献度-累计求和" class="headerlink" title="贡献度-累计求和"></a>贡献度-累计求和</h3><ul>
<li>计算各个用户的消费金额综合</li>
<li>对用户消费金额进行累加，并计算累计占比，就是贡献度<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">select 
t.*
from
	(select 
	user_id 
	,round(amount,2) amount
	,round(sum(amount)over(order by amount desc) ,2) cum_amount
	,round(sum(amount)over(order by amount desc)&#x2F;(select sum(pur_amount) from cd_now),4) as cum_rate
	from 
		(select 
		user_id 
		,sum(pur_amount) amount
		from 
		cd_now 
		where pur_amount &gt;0
		group by 
		user_id ) user_table
	) t
where t.cum_rate&lt;0.8</code></pre></li>
</ul>
<h3 id="电商类"><a href="#电商类" class="headerlink" title="电商类"></a>电商类</h3><ul>
<li><p>商品活动流水表，表名为event，字段：goods_id， time；</p>
</li>
<li><p>求参加活动次数最多的商品的最近一次参加活动的时间</p>
</li>
</ul>
<p>数据准备：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">#创建 event 表
CREATE TABLE &#96;event&#96; (
 &#96;goods_id&#96; varchar(255),
 &#96;time&#96; varchar(255)
 );
#插入数据
INSERT INTO &#96;event&#96; VALUES (&#39;可口可乐&#39;, &#39;2021-02-22&#39;);
INSERT INTO &#96;event&#96; VALUES (&#39;雪碧&#39;, &#39;2021-03-01&#39;);
INSERT INTO &#96;event&#96; VALUES (&#39;可口可乐&#39;, &#39;2021-03-04&#39;);
INSERT INTO &#96;event&#96; VALUES (&#39;东鹏特饮&#39;, &#39;2021-03-06&#39;);
INSERT INTO &#96;event&#96; VALUES (&#39;雪碧&#39;, &#39;2021-03-07&#39;);
INSERT INTO &#96;event&#96; VALUES (&#39;红牛&#39;, &#39;2021-03-07&#39;);
INSERT INTO &#96;event&#96; VALUES (&#39;东鹏特饮&#39;, &#39;2021-03-08&#39;);
INSERT INTO &#96;event&#96; VALUES (&#39;雪碧&#39;, &#39;2021-03-08&#39;);</code></pre>

<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">-- 求参加活动次数最多的商品的最近一次参加活动的时间
-- 统计每种商品参加活动的次数，以及最近一次参与活动的时间
select 
*
from 
(select 
goods_id
,count(*) goods_num
,max(time) max_time
from event 
group by goods_id) a 
order by goods_num desc limit 1</code></pre>

<ul>
<li>新老客 <code>trans</code>和<code>profile</code></li>
</ul>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">-- 请计算每一类客户在2019年每月产生的销售(即购买金额大于0，及发生购买的人数(客户类型分为:新客，老客；新客:2019年产生第一次购买；老客:2019年之前已经购买过)
-- 先分清新老客,在分类统计
select 
month(purchase_date) &#96;月份&#96;
,customer_type  
,sum(Quantity*Unit_price) &#96;金额&#96;
,count(*)
from 
(select 
t.*
,case when year(p.FIRST_PUR_DATE)&#x3D;2019 then &#39;新客&#39; else &#39;老客&#39; end as &#96;customer_type&#96;
from &#96;trans&#96; t 
left join &#96;profile&#96; p
on t.Customer_ID &#x3D; p.Customer_ID
where year(purchase_date)&#x3D;2019) a
group by month(purchase_date),customer_type;</code></pre>

<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">-- 现要给2019年新客发送A、B小样，线上新客发放A小样，线下新客发放B小样，请编写程序抽取相应的名单
-- 字段 COUNTERID : offline 线下，online 线上
select 
*
,case when COUNTER_ID like &#39;online%&#39; then &#39;A&#39; else &#39;B&#39; end as &#39;demo_type&#39;
from 
(select 
t.*
,case when year(p.FIRST_PUR_DATE)&#x3D;2019 then &#39;新客&#39; else &#39;老客&#39; end as &#96;customer_type&#96;
from &#96;trans&#96; t 
left join &#96;profile&#96; p
on t.Customer_ID &#x3D; p.Customer_ID
where year(purchase_date)&#x3D;2019) a
where &#96;customer_type&#96;&#x3D;&#39;新客&#39;;</code></pre>

<h3 id="相邻座位互换"><a href="#相邻座位互换" class="headerlink" title="相邻座位互换"></a>相邻座位互换</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">create TABLE 
&#96;Seat&#96; (
	&#96;id&#96; VARCHAR(255),
	&#96;employee&#96; VARCHAR(255)
);
insert INTO &#96;Seat&#96; VALUES (&#39;1&#39;, &#39;Jack&#39;);
INSERT INTO &#96;Seat&#96; VALUES (&#39;2&#39;, &#39;Scott&#39;);
INSERT INTO &#96;Seat&#96; VALUES (&#39;3&#39;, &#39;Emery&#39;);
INSERT INTO &#96;Seat&#96; VALUES (&#39;4&#39;, &#39;Green&#39;);
INSERT INTO &#96;Seat&#96; VALUES (&#39;5&#39;, &#39;Linda&#39;);
INSERT INTO &#96;Seat&#96; VALUES (&#39;6&#39;, &#39;Jane&#39;);

#查询每两个相邻的座位互换（可以看作是两两相邻奇数和偶数呼唤，奇数下移，偶数上移）
select 
(case 
when mod(id,2)!&#x3D;0 and id!&#x3D;a.counts then id+1 
when mod(id,2)!&#x3D;0 and id&#x3D;a.counts then id 
else id-1 end) as id 
,employee
from 
&#96;Seat&#96;,(select count(*) counts from &#96;Seat&#96;) a
order by id;</code></pre>

]]></content>
      <categories>
        <category>sql</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title>sql查询连续签到天数</title>
    <url>//post/sql%E6%9F%A5%E8%AF%A2%E8%BF%9E%E7%BB%AD%E7%AD%BE%E5%88%B0%E5%A4%A9%E6%95%B0.html</url>
    <content><![CDATA[<p>先建表</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">create table user_attendence(
user_id bigint comment &#39;用户名&#39;, 
date TIMESTAMP comment &#39;日期&#39; ,
is_sign bigint comment &#39;是否登录，0为否，1为是&#39;);
-- delete from user_attendence;</code></pre>
<p>接下来用python自己导入随机数据,500个用户、时间2021-1-1~2021-5-5。</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">import pymysql
import pandas as pd
from sqlalchemy import create_engine
import numpy as np
df &#x3D; pd.DataFrame()
date &#x3D; pd.date_range(&#39;2021-1-1&#39;,&#39;2021-5-5&#39;).strftime(&#39;%Y-%m-%d&#39;)
df[&quot;user_id&quot;]&#x3D;[i for i in np.arange(1,500)]*len(date)
df[&#39;date&#39;] &#x3D; [i for i in date]*len(np.arange(1,500))
df[&quot;is_sign&quot;] &#x3D; [np.random.choice([0,1]) for i in range(len(df))]
df &#x3D; df.sort_values(by&#x3D;[&#39;user_id&#39;,&#39;date&#39;],na_position&#x3D;&#39;first&#39;)
#写入数据库
con &#x3D; &#39;mysql+pymysql:&#x2F;&#x2F;root:3333@localhost:3306&#x2F;supermanzwg?charset&#x3D;utf8&#39;
#如果出现字符串编码错误记得在Navicat运行alter table 表名 convert to character set utf8mb4;
df.to_sql(name&#x3D;&#39;user_attendence&#39;,con&#x3D;con,if_exists&#x3D;&#39;append&#39;,index &#x3D; False)</code></pre>
<p>#截至当前，每个用户已经连续签到的天数<br>查出最后一次不登录的日期，与当前日期进行比较，二者差值为几就是连续登录几天</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">select max(date) from user_attendence;</code></pre>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">select 
user_id ,
max(date),
DATEDIFF(&#39;2021-02-19&#39;,max(date)) as max_con_days
from user_attendence 
where is_sign &#x3D; 0 
group by user_id;</code></pre>
<p>#计算有史以来用户最大连续签到天数；<br>对用户分组，按日期进行排序，排序序号为rank;<br>如果日期与序号的差值为相等，按这个差值进行分组并计数，取最大值</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">select 
user_id
,max(&#96;次数&#96;)  &#96;最大连续登陆天数&#96;
from 
    (select user_id
    ,date
    ,a.date-a.rn diff
    ,count(*) &#96;次数&#96;
    from 
        (select 
        user_id
        ,date,
        row_number() over(partition by user_id order by date asc) rn
        from user_attendence  
        where is_sign &#x3D; 1
        ) a 
    group by user_id,diff
    ) b 
group by user_id order by max(&#96;次数&#96;) desc;</code></pre>

]]></content>
      <categories>
        <category>sql</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title>大学三年，写给那个迟到的人</title>
    <url>//post/%E5%A4%A7%E5%AD%A6%E4%B8%89%E5%B9%B4%EF%BC%8C%E5%86%99%E7%BB%99%E9%82%A3%E4%B8%AA%E8%BF%9F%E5%88%B0%E7%9A%84%E4%BA%BA.html</url>
    <content><![CDATA[<p>亲爱的X姑娘：</p>
<p>你好！给你写这封信的时候，我正在学校的机电楼B301上第一节课。看了简书里好多给异性朋友写信的文章，我也心血来潮，忍不住想要和你说说话了。</p>
<p>—1—</p>
<p>早上醒的很早，在床上平躺到闹铃声响起，依旧照常的起床，洗漱，整理好出门。</p>
<p>没有胃口，不太想吃饭。但想到将来要在你面前呈现一个健康阳光的自己，还是买了一份豆浆和两个早餐包。</p>
<p>吃完走进教室，已经零零散散的坐满了一些人，我打开耳机里的纯音乐，想着舒缓下情绪，来迎接这节并不怎么让我心动的课程。</p>
<p>邻桌有一对情侣坐得很近，我看着老师走进教室，紧接着用余光一瞥到他们有说有笑的样子，顿时心生怅惘。</p>
<p>如果，我想说是如果，你在后面轻轻地拍一下我的肩膀，我回头看到一个嘴角微微上扬的弧度，那这节课我一定带着满满的能量。</p>
<p>或者，你就只是静静地坐在我的前面，我看着你，心生欢喜，脸上也应该会不自觉的泛起笑容……</p>
<p>有时候我会一个人坐在三个座位的中间，就好像潜意识里给你留了一个位置一样。</p>
<p>其实，一个人，一个座位，一支沙沙作响的笔，一个低下视线的背影。总是会显得孤零零的，在周围整齐的人群背景下，不免会有些格格不入…</p>
<p>—2—</p>
<p>你知道吗，我已经习惯了一个人走在去图书馆的路上，我听着音乐，看着一路沿途的风景，为了包裹住心中的孤独，我昂首挺胸，略显悠闲、惬意的走着。</p>
<p>但是，如果是你和我一起，我可能会满含笑意地和你谈天说地，像个孩子一样大大方方的走着…</p>
<p>又或是，你挽着我的手，不需要讲太多话，一起慢悠悠的走在石头小路上。就像《成都》里描绘的意境那样：”你会挽着我的衣袖，我会把手揣进裤兜……”</p>
<p>有一个秘密要告诉你，我会用吉他弹唱这首歌了，不知道在你面前的时候，我能不能饱含深情的唱出来带给你浪漫的感觉。</p>
<p>从图书馆出来，我们一起去食堂买饭，我会想先去你喜欢的窗口排队，你是想拿着书包去寻找空着的座位，还是想和我走在一起呢…</p>
<p>你知道吗，平时都是和舍友一起吃饭，聊的也都是各自的事情。但是如果是和你一起，我想不但胃口会大涨，我们还可以有更多的故事一起回忆…</p>
<p>吃完饭，我们坐在图书馆旁林荫小道的长凳上，听微风拂过耳边的声音，看那阳光沐浴下的一片绿林。</p>
<p>你慢慢地把头靠在我的臂弯，我低头捕捉你眸底似海一般的温柔…</p>
<p>我会想调皮地刮你的鼻子，你会闭上眼睛满意地笑吗，还是轻轻的戳我一下。</p>
<p>你知道吗，就这样一个简单的动作，也会让我的整个世界都开满了花。</p>
<p>—3—</p>
<p>﻿假期的时候你会去哪玩呢！是在宿舍刷刷剧，和朋友聊聊天，还是出去旅游，拍照，发朋友圈，或是和我一样会去商业街兼职呢！﻿</p>
<p>﻿我也会想着挣钱去买自己喜欢的东西呀，或是旅游去一个心驰神往的地方呢，又或者是，和我爱的人一起去吃顿火锅怎么样！oh！ that’s a good idea!﻿</p>
<p>﻿当然，有时候他也会把握不好分寸，甚至不愿意安排自己学习的时间，逃课去做一些他感兴趣的东西呢。﻿</p>
<p>﻿他觉得，要是有个心思细腻的你在身边的话，他们一起，一定能过着更有节奏、充实的生活！﻿</p>
<p>﻿节日的时候我们去看场电影吧！要是去的比较早，那就在休息区玩一个超级有趣的双人小游戏怎么样！你知道怎么玩吗，不会？那我教你好了…﻿</p>
<p>﻿我会宠爱地喂你爆米花，你会不会依偎在我的肩膀呢！不然的话我可能会把送到你嘴边的零食马上缩回到我嘴边哦！啊！你别生气，还是给你吃好了…</p>
<p>﻿你知道吗，从这个时候起，在他期待的未来里，全都将是你……</p>
<p>—4—</p>
<p>晚上你喜欢出去逛逛吗！下自习后我常常会去超市，即便只买那几样东西，我也会在里面多逛一小会儿，可能是因为那里有浓浓的生活气息吧。</p>
<p>愿在将来的某一天，我推着购物车，你牵着我的手，走在喧闹的商场。我悄悄把你喜欢的零食放进车里，你认真地挑着我爱吃的水果，然后我们拎着这简单而平凡的幸福，满载而归。</p>
<p>我还有个夜跑的小习惯，我也希望和你一起，趁着夜幕降临，去草坪上繁星点点的操场。戴上耳机，跟着音乐的节奏，在皎洁的月光下挥洒汗水。</p>
<p>一圈一圈的轮回，甩掉心中所有的不愉快，接着再去澡堂，冲去一天中纷乱的小情绪…</p>
<p>又或是，我带着吉他，你当我的专属观众，在柔软舒适的草坪席地而坐，弹唱那些为你学过的歌好不好呢！</p>
<p>你和我一起唱怎么样，可不能放过你那被天使吻过的嗓子，还有我可能会跑调哦，你会笑吗，还是大声一点，带回我跑偏的部分呢…</p>
<p>想到这个唯美的画面，也会让我感动的红了眼。</p>
<p>忙着为下一段人生做准备，好久都不去KTV了，好像也没有那种想在人前表现的冲动了，只希望现在的拼搏能为余生发掘出与众不凡的核心竞争力。</p>
<p>不知道你是不是也正处于人生的某一个风口浪尖呢，你是不是已经完成蜕变了呢，你憧憬的未来里有没有一个像我这样的人呢。</p>
<p>我相信，你肯定正走在和我相遇的路上呢。而我，也正在寻找着那一份懂你的资格呀。</p>
<p>﻿突然间，清晨的一缕阳光掠过窗帘的缝隙撞到我的手上，照在这些热烈而又抽象的文字上，我顿下笔来，多想能永远保存此刻心里正诞生的阵阵暖意…</p>
<p>他多么希望可以有一个人陪他看陌生城市里的每一个落日，他们一起去听喜欢的课程。一起规划未来，一起带着足够的知识，去闯荡这色彩斑斓的平凡世界。</p>
<p>——你东半球官方指定唯一的男朋友</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>成长，旧时光</tag>
      </tags>
  </entry>
  <entry>
    <title>大学里，最丧的时候</title>
    <url>//post/%E5%A4%A7%E5%AD%A6%E9%87%8C%EF%BC%8C%E6%9C%80%E4%B8%A7%E7%9A%84%E6%97%B6%E5%80%99.html</url>
    <content><![CDATA[<p>—1—</p>
<p>看到香港大学孙教授的一段话：</p>
<p>﻿﻿“大学，就应该是早起吃点早餐；跑跑步；专业课认真听；公共课看看自己喜欢的杂志；中午小睡一会儿；下午参加个社团活动或打打篮球；晚上陪着喜欢的人散散步；或去自习室安静地看看书……  社会不需要学霸，也不认什么学生会主席，更不希望看到学生放弃学业去创业。你只要能平稳完整地读完大学，寻找到自己所爱的人和兴趣，多去没有目的的看些能丰富自己思想的书，认识几个好的不成样子的朋友，锻炼或是塑造自己的身体，学精自己想要从事事业的专业知识…… 做到这些，平淡地度过大学这几年你就已经足够优秀了。 ”</p>
<p>可为什么今年大三的我，感觉这辈子算是完了。</p>
<p>—2—</p>
<p>大学，是一段没有烟火气的生活，是一个比毕业后舒服的状态。</p>
<p>调剂到一个一眼无缘的理科专业，而你做的最无力的抗拒，就是在课上看自己感兴趣的东西，在宿舍听歌，看电影，打游戏，一日三餐，南来北往。渐渐，这成了一个司空见惯的事情。失落的时候练下吉他，你也曾想活在音乐的小世界里无人问津…</p>
<p>每天坚持吃早饭，天气暖和会去操场跑步，中午很难睡着，晚上精力旺盛到连开玩笑都尤其认真，每一次赶作业都是一场和时间赛跑的特殊行动，当然你还可以在期末的时候完成一些感觉惊天动地的事情﻿…</p>
<p>你慢慢疏远书本理论里面的成就感，开始厌倦众口一词的最佳答案，逃避一次又一次选择中的唯唯诺诺，沉醉在自己对于儿时梦境的美好想往里…</p>
<p>你不是学霸也没进学生会，你总是庆幸地以为低分通过就是比那个挂了科的室友强，你甚至想着在学校待上四年然后发财，慢慢地，你变得不愿意参加带着利益性质炫耀嘲讽的社团活动，没有能力去美化人家的游戏体验…</p>
<p>这是一个记忆稍纵即逝的年纪，你读的那些感觉挺有意思的书，随着旋转的时间轴忘得所剩无几。你做了一些兼职，挣了一点小钱，在同学面前过得洋洋洒洒。你去过几个地方，认识了好少好少可以交心的人，每次吃饭想说心里话的时候，你总害怕别人抓住你的软肋而欲言又止。你还考了几个希望能给未来生活带来惊喜的证书……</p>
<p>做到这些，平淡的度过大学，你也很害怕平凡的你一无所成。﻿﻿</p>
<p>—3—</p>
<p>这是一个花里胡哨的时代，你可能永远都不会知道，那个在朋友圈里高大上的陌生人，在真实里，究竟是怎样的际遇。﻿﻿</p>
<p>你尽可能的在人前把自己装点得光鲜亮丽，绅士般的接受所有的缘行渐远。你变得害怕承诺，躲避爱情，却又不愿意享受孤独，独当一面…﻿﻿</p>
<p>你见识到的世界的确比父辈要大，可是对自我的认知却很浅。</p>
<p>你每天在爆炸的信息中学习各种道理，通过网络你知道了身边好多人赢，于是你变得更加不甘平凡，时而凝神聚气的笃定，时而云淡风轻的随意，在对比中渐渐迷失﻿…﻿﻿</p>
<p>﻿你感觉自己变成了一台机器，可以不对生活付诸任何情感，他能一直工作，只是会越来越慢。﻿﻿</p>
<p>如果现在有一个可以看到的决定，未来你会在世界的某一个角落，从事一份称心如意的职业，可能你就不会在错过一节专业课的时候坐立不安，更不会因为身边的人活的体面潇洒而心惊胆战了。﻿﻿</p>
<p>也许正是因为这种人生的不确定性，才愈加增大了人们对未来五彩缤纷的构想吧。﻿﻿</p>
<p>克莱顿在《你要如何衡量你的人生》中提到，人对自己一生的规划，无非是周密战略和意外机遇相结合的产物，关键是要走出去，并行动起来，直到你明白应该将自己的聪明才智，兴趣和重点放在哪里，再将应急战略转化为周密战略。</p>
<p>我希望你，在试图跳出规则之前，能做出关于自己本心的选择，愿你强大到能冲破社会的桎梏，以自己愿意的姿态生活下去。﻿﻿﻿</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>成长，旧时光</tag>
      </tags>
  </entry>
  <entry>
    <title>我们这样的人，谈爱都太奢侈</title>
    <url>//post/%E6%88%91%E4%BB%AC%E8%BF%99%E6%A0%B7%E7%9A%84%E4%BA%BA%EF%BC%8C%E8%B0%88%E7%88%B1%E9%83%BD%E5%A4%AA%E5%A5%A2%E4%BE%88.html</url>
    <content><![CDATA[<p>爱是人类的本能，可是成年人的世界里，所谓的真心，更多的换来的却是失落与沮丧，渐渐的他们学会了伪装与克制，变得沉默且凉薄。前几天和朋友闲聊，突然听到现如今找女朋友就像找大熊猫一样，哈哈哈，还是大学的时候投资好啊，现在估计早都不担心了。</p>
<p>房子带来的安稳，汽车带来的便捷，手机平板带来的时尚，不早不晚的都让九零后赶上了，他们也许是物质体验最丰富的一代人，但同时也会是对物质需求最挑剔的一代人。同学不满领导安排毅然辞去了干了不满五个月的工作；朋友上次分手后，突然告诉我决定今年国庆结婚，和一个认识半年左右的女孩；从小一起长大的兄弟在犹豫该不该留在大城市发展，毕竟对于房价有时候也会低声苦笑。</p>
<p>雷军先生说过：“现在的物质已经很丰富了，现在的年轻人面对的可能更多的是精神上的痛苦”。人口比例失衡带来的红利，就像是资本家看上的蓝海市场，在物质与精神的两相施压下，猫猫狗狗都成了家居必备物种。谁能想到许多年后的今天人类会隔着彩色的屏幕去感受人情冷暖，体验世态炎凉。物欲横流的世界，浮躁成了这个时代最真实的写照。我们都想要牵了手就能结婚的爱情，却活在了一个上了床都不一定有结果的年代。那个男人他终究还是没有活成你希望的样子，可是你知道吗，在他会鼓起勇气和你表达之前，真的是会考虑现在和未来的呀。为了能配得上你，都还在沉住气不停的坚持呢。</p>
<p>有时候会有一种奇怪的感受，如果说读书时代遇到问题所面对的失落，是为了锻炼克服困难的能力，从而学习到更好的思维方式；参加高考上大学遭遇就业压力所承受的焦虑，是要鞭策自己为了过上更好的生活实现所谓的个人理想而努力。但当你真正走上社会的那一霎那，发现一切都不像你想象得那么有条有理，你可能还是会需要蛰伏很长一段时间。你拼尽全力的想要去缩短需要奋斗的距离，却还是会难以扛住资本家构造蓝图时行业给出的亲民价。我们这样的人，谈爱都太奢侈。</p>
<p>就写到这吧，闲来几笔，一个人还是要心无所恃，随遇而安。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>成长，旧时光</tag>
      </tags>
  </entry>
  <entry>
    <title>至少你，存在过我的记忆</title>
    <url>//post/%E8%87%B3%E5%B0%91%E4%BD%A0%EF%BC%8C%E5%AD%98%E5%9C%A8%E8%BF%87%E6%88%91%E7%9A%84%E8%AE%B0%E5%BF%86.html</url>
    <content><![CDATA[<p>人海中错过的那个人，至少，在我失眠梦呓间，脑海里还是会依稀浮现出你的容颜。</p>
<p>贝蒂，我是里克。最近你的城市下雨了吗，我这里的温度有些难过，不知道你过得怎么样。</p>
<p>济南的天照旧那样调皮，就像世界末日里的那句歌词，Why dose the sun go on shining一样，一次又一次地挑战着我出门的勇气，还好我坐的地方阳光有所收敛，不然我炽热的内心暴露在烈日下，真不知道会发生什么化学反应。</p>
<p>家庭生活的原因，我很早就开始了一个人的生活，可能除了自己，没有谁能左右我的想法了。一个人无拘无束，一个人天马行空，一个人桀骜不驯，一个人胆怯如鼠。</p>
<p>周国平说，在多数场合，我不是觉得对方乏味，就是害怕对方觉得我乏味，我既不愿意忍受对方的乏味，又不愿意费劲使自己有趣，所以我选择独处，那就自己承受自己的乏味，不累及他人。我大概就是这样一种人吧，得意的时候手舞足蹈，逢场作戏，可稍不如意就黯然失色，冷若冰霜，你说乏味不乏味。</p>
<p>浮躁的生活中让人有太多无法控制的遐想，也许，我应该找到一个更好的娱乐方式，以至于不会在休息的时候，不由自主的沦陷。</p>
<p>每次听到廖俊涛的那首《谁》，特别想拿起吉他练琴，弹着弹着，就忘记了后天还要考试的束缚感。有时候真希望时间定格在这一刻，不用去想其他任何事情。</p>
<p>当然也好羡慕那些在架子鼓上不可一世的乐手们，想学习打鼓，一直追求这样的发泄方式，可是生活总归会有些小遗憾，习惯了时光静好，心情似乎一直都波澜不惊。</p>
<p>最近经历了一连串的考核，带着满满的用心，和一丁点慌张，完成着之前感觉惊天动地的事情。</p>
<p>前段时间帮驾校招生，拿到了辛苦换来的一点小回报。不过贝蒂，很多次的社会经验使我觉得，人们好像都不愿意看到别人变好的样子，他们尽可能与遭遇苦难的人找到共鸣，要么保持缄默，要么施以怜悯。当他们发现别人的好时，它们立刻感到毛骨悚然。</p>
<p>贝蒂，你说像我这样的人，会活成自己想要成为的样子吗，我要学习的东西在需要通过考试拿到的学分面前，已经搁浅了一阵时间。我想，过完这一阵，我会继续坚持。因为，在这场游戏中，并没有什么其他的角色供我选择。</p>
<p>当然我相信，这些很快就会过去的。时间总是这样无情地切割我们的生命，夜里想着心事，第二天的闹铃就响了；下几次雨，夏天也结束了；等反应过来的时候，那个穿着开裆裤在邻居家乱跑的小屁孩，都长这么大了。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>成长，旧时光</tag>
      </tags>
  </entry>
</search>
